

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>6.2 错误检测与纠正技术 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c6/s2';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="6.3 多路访问链路与协议" href="s3.html" />
    <link rel="prev" title="6.1 链路层简介" href="s1.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c2/index.html">第 2 章 应用层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c2/s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s3.html">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s4.html">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s5.html">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c4/index.html">第 4 章 网络层：数据平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c4/s1.html">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 6 章 链路层与局域网（LANs）</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c8/index.html">第 8 章 计算机网络中的安全</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c8/s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s2.html">8.2 密码学原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s3.html">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c9/index.html">第 9 章 多媒体网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c9/s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s2.html">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c6/s2.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>6.2 错误检测与纠正技术</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c6-2-1">6.2.1 奇偶校验</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c6-2-2">6.2.2 校验和方法</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#crc">6.2.3 循环冗余校验（CRC）</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="c6-2">
<span id="id1"></span><h1>6.2 错误检测与纠正技术<a class="headerlink" href="#c6-2" title="此标题的永久链接">#</a></h1>
<p>6.2 Error-Detection and -Correction Techniques</p>
<p>在上一节中，我们提到， <strong>比特级的错误检测与纠正</strong> ——即检测和纠正从一个节点发送到另一个物理相邻节点的链路层帧中的比特损坏——是链路层通常提供的两项服务。在 <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">第3章</span></a> 中我们也看到，错误检测与纠正服务常常在传输层中提供。本节中，我们将考察一些最简单的用于检测（在某些情况下也能纠正）比特错误的技术。全面探讨该主题的理论与实现本身就是许多教材的内容（例如 <a class="reference internal" href="../references.html#schwartz-1980"><span class="std std-ref">[Schwartz 1980]</span></a> 或 <a class="reference internal" href="../references.html#bertsekas-1991"><span class="std std-ref">[Bertsekas 1991]</span></a>），因此我们这里只做简要介绍。我们的目标是对错误检测与纠正技术所能提供的能力建立直观理解，并了解几个简单技术在链路层中的实际工作原理和使用方式。</p>
<p><span class="xref std std-ref">图 6.3</span> 展示了我们的研究场景。在发送节点，待保护的数据 <code class="docutils literal notranslate"><span class="pre">D</span></code> 会被附加上错误检测与纠正比特（<code class="docutils literal notranslate"><span class="pre">EDC</span></code>）。通常，待保护的数据不仅包括从网络层下传到链路层用于传输的数据报，也包括链路级地址信息、序列号以及帧头中的其他字段。 <code class="docutils literal notranslate"><span class="pre">D</span></code> 和 <code class="docutils literal notranslate"><span class="pre">EDC</span></code> 都会一起被打包进链路层帧发送到接收节点。在接收节点，会接收到一组比特序列 <code class="docutils literal notranslate"><span class="pre">D'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">EDC'</span></code>。注意，由于传输中的比特翻转， <code class="docutils literal notranslate"><span class="pre">D'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">EDC'</span></code> 可能与原始的 <code class="docutils literal notranslate"><span class="pre">D</span></code> 和 <code class="docutils literal notranslate"><span class="pre">EDC</span></code> 不同。</p>
<p>接收方的挑战是，仅凭接收到的 <code class="docutils literal notranslate"><span class="pre">D‘</span></code> 和 <code class="docutils literal notranslate"><span class="pre">EDC'</span></code>，来判断 <code class="docutils literal notranslate"><span class="pre">D'</span></code> 是否等于原始的 D。在 <span class="xref std std-ref">图 6.3</span> 中对接收方决策的表述非常关键（我们问的是是否检测到错误，而不是是否发生了错误！）。错误检测与纠正技术可以让接收方有时（但并非总是）检测到比特错误的发生。即使使用了错误检测比特，仍然可能存在 <strong>未检测到的比特错误</strong> ，即接收方无法察觉接收到的信息中包含比特错误。因此，接收方可能会将一个损坏的数据报递交给网络层，或者没能察觉帧头中的某个字段已经损坏。因此，我们希望选择一种能尽可能降低此类错误概率的错误检测机制。通常，越复杂的错误检测与纠正技术（即未检测到错误的概率越小）所带来的开销也越大——需要更多的计算资源来计算和传输更多的检测与纠正比特。</p>
<figure class="align-center" id="figure-6-3">
<img alt="../_images/501-0.png" src="../_images/501-0.png" />
</figure>
<p><strong>图 6.3 错误检测与纠正场景</strong></p>
<p>现在我们来看看三种数据传输中错误检测技术——奇偶校验（用于说明错误检测与纠正的基本概念）、校验和方法（通常用于传输层）以及循环冗余校验（CRC，通常用于链路层和适配器中）。</p>
<div class="toggle docutils container">
<p>In the previous section, we noted that <strong>bit-level error detection and correction</strong>—detecting and correcting the corruption of bits in a link-layer frame sent from one node to another physically connected neighboring node—are two services often ­provided by the link layer. We saw in <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a> that error- detection and -correction services are also often offered at the transport layer as well. In this section, we’ll examine a few of the simplest techniques that can be used to detect and, in some cases, correct such bit errors. A full treatment of the theory and implementation of this topic is itself the topic of many textbooks (for example, <a class="reference internal" href="../references.html#schwartz-1980"><span class="std std-ref">[Schwartz 1980]</span></a> or <a class="reference internal" href="../references.html#bertsekas-1991"><span class="std std-ref">[Bertsekas 1991]</span></a>), and our treatment here is necessarily brief. Our goal here is to develop an intuitive feel for the capabilities that error-detection and -correction techniques provide and to see how a few simple techniques work and are used in practice in the link layer.</p>
<p><span class="xref std std-ref">Figure 6.3</span> illustrates the setting for our study. At the sending node, data, D, to be protected against bit errors is augmented with error-detection and -correction bits (EDC). Typically, the data to be protected includes not only the datagram passed down from the network layer for transmission across the link, but also link-level addressing information, sequence numbers, and other fields in the link frame header. Both D and EDC are sent to the receiving node in a link-level frame. At the receiving node, a sequence of bits, D′ and EDC′ is received. Note that D′ and EDC′ may differ from the original D and EDC as a result of in-transit bit flips.</p>
<p>The receiver’s challenge is to determine whether or not D′ is the same as the original D, given that it has only received D′ and EDC′. The exact wording of the receiver’s decision in <span class="xref std std-ref">Figure 6.3</span> (we ask whether an error is detected, not whether an error has occurred!) is important. Error-detection and -correction techniques allow the receiver to sometimes, but not always, detect that bit errors have occurred. Even with the use of error-detection bits there still may be <strong>undetected bit errors</strong>; that is, the receiver may be unaware that the received information contains bit errors. As a consequence, the receiver might deliver a corrupted datagram to the network layer, or be unaware that the contents of a field in the frame’s header has been corrupted. We thus want to choose an error- detection scheme that keeps the probability of such occurrences small. Generally, more sophisticated error-detection and-correction techniques (that is, those that have a smaller probability of allowing undetected bit errors) incur a larger overhead—more computation is needed to compute and transmit a larger number of error-detection and -correction bits.</p>
<figure class="align-center">
<img alt="../_images/501-0.png" src="../_images/501-0.png" />
</figure>
<p id="id2"><strong>Figure 6.3 Error-detection and -correction scenario</strong></p>
<p>Let’s now examine three techniques for detecting errors in the transmitted data—parity checks (to illustrate the basic ideas behind error detection and correction), checksumming methods (which are more typically used in the transport layer), and cyclic redundancy checks (which are more typically used in the link layer in an adapter).</p>
</div>
<section id="c6-2-1">
<span id="id3"></span><h2>6.2.1 奇偶校验<a class="headerlink" href="#c6-2-1" title="此标题的永久链接">#</a></h2>
<p>6.2.1 Parity Checks</p>
<p>最简单的错误检测形式可能是使用单个 <strong>奇偶校验位</strong>。假设要发送的信息 D 如 <a class="reference internal" href="#figure-6-4"><span class="std std-ref">图 6.4</span></a> 所示，共有 <code class="docutils literal notranslate"><span class="pre">d</span></code> 个比特。在偶校验方案中，发送方只需添加一个额外比特，并设置其值，使得 <code class="docutils literal notranslate"><span class="pre">d+1</span></code> 个比特（原始数据加上奇偶校验位）中 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的个数为偶数。在奇校验方案中，奇偶校验位的值应使得 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的个数为奇数。<a class="reference internal" href="#figure-6-4"><span class="std std-ref">图 6.4</span></a> 展示了一个偶校验的方案，其中单个位的奇偶校验被保存在一个单独的字段中。</p>
<p>当使用单个奇偶校验位时，接收方的操作也很简单。接收方只需统计收到的 <code class="docutils literal notranslate"><span class="pre">d+1</span></code> 个比特中 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的数量。如果使用偶校验方案时发现有奇数个 <code class="docutils literal notranslate"><span class="pre">1</span></code>，则说明至少发生了一个比特错误。更准确地说，是发生了奇数个比特错误。</p>
<p>但如果发生的是偶数个比特错误会怎样？你可以验证一下，这种情况将导致错误未被检测到。如果比特错误概率较小，并且可以假设错误在各比特间是独立发生的，那么一个分组中发生多个比特错误的概率将非常小。在这种情况下，使用单个奇偶校验位可能已足够。然而，实际测量表明，错误通常并非独立发生，而是集中成“突发错误”。在突发错误条件下，单个位奇偶校验保护的帧中未检测到错误的概率可能高达 50% <a class="reference internal" href="../references.html#spragins-1991"><span class="std std-ref">[Spragins 1991]</span></a>。显然，需要一种更健壮的错误检测方案（幸运的是，实践中确实使用了更健壮的方案！）。但在探讨实际使用的错误检测方案之前，我们先来看单个位奇偶校验的一种简单推广，它将帮助我们理解错误纠正技术。</p>
<figure class="align-center" id="figure-6-4">
<img alt="../_images/502-0.png" src="../_images/502-0.png" />
</figure>
<p><strong>图 6.4 单个位偶校验</strong></p>
<p><a class="reference internal" href="#figure-6-5"><span class="std std-ref">图 6.5</span></a> 展示了单个位奇偶校验方案的二维推广形式。这里， <code class="docutils literal notranslate"><span class="pre">d</span></code> 个比特被划分为 <code class="docutils literal notranslate"><span class="pre">i</span></code> 行 <code class="docutils literal notranslate"><span class="pre">j</span></code> 列。每一行和每一列都计算一个奇偶校验值。最终产生的 <code class="docutils literal notranslate"><span class="pre">i+j+1</span></code> 个奇偶校验位构成链路层帧的错误检测比特。</p>
<p>假设现在在原始 d 个比特中发生了一个比特错误。在这种 <strong>二维奇偶校验</strong> 方案中，包含错误比特的行和列的奇偶校验都会出错。因此，接收方不仅可以检测到发生了单个比特错误，还可以通过错误行和列的索引，定位出损坏的比特并纠正错误！<a class="reference internal" href="#figure-6-5"><span class="std std-ref">图 6.5</span></a> 展示了一个例子：位置 <code class="docutils literal notranslate"><span class="pre">(2,2)</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的比特被翻转为0——这是一个接收方可以检测并纠正的错误。虽然我们主要关注的是原始的 <code class="docutils literal notranslate"><span class="pre">d</span></code> 个比特，但即使奇偶校验位本身发生错误，也可以被检测并纠正。二维奇偶校验还可以检测（但不能纠正）任意两个比特的组合错误。有关二维奇偶校验方案的其他特性将在本章末尾的习题中探讨。</p>
<figure class="align-center" id="figure-6-5">
<img alt="../_images/503-0.png" src="../_images/503-0.png" />
</figure>
<p><strong>图 6.5 二维偶校验</strong></p>
<p>接收方既能检测又能纠正错误的能力称为 <strong>前向纠错（FEC）</strong>。这些技术广泛应用于音频存储与播放设备，如音频 CD。在网络环境中，FEC 技术可以独立使用，也可以与类似于我们在 <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">第3章</span></a> 中讨论的链路层 ARQ 技术结合使用。FEC 技术的价值在于它能减少发送方所需的重传次数。更重要的是，它允许接收方即时纠正错误，避免了等待往返传播延迟以接收 NAK 包及重传包返回的过程——这对实时网络应用 <a class="reference internal" href="../references.html#rubenstein-1998"><span class="std std-ref">[Rubenstein 1998]</span></a> 或传播延迟长的链路（如深空链路）来说尤为重要。研究 FEC 在错误控制协议中应用的相关文献包括 [<a class="reference internal" href="../references.html#biersack-1992"><span class="std std-ref">Biersack 1992</span></a>；<a class="reference internal" href="../references.html#nonnenmacher-1998"><span class="std std-ref">Nonnenmacher 1998</span></a>；<a class="reference internal" href="../references.html#byers-1998"><span class="std std-ref">Byers 1998</span></a>；<a class="reference internal" href="../references.html#shacham-1990"><span class="std std-ref">Shacham 1990</span></a>]。</p>
<div class="toggle docutils container">
<p>Perhaps the simplest form of error detection is the use of a single <strong>parity bit</strong>. Suppose that the information to be sent, D in <a class="reference internal" href="#figure-6-4"><span class="std std-ref">Figure 6.4</span></a>, has d bits. In an even parity scheme, the sender simply includes one additional bit and chooses its value such that the total number of 1s in the d+1 bits (the original information plus a parity bit) is even. For odd parity schemes, the parity bit value is chosen such that there is an odd number of 1s. <a class="reference internal" href="#figure-6-4"><span class="std std-ref">Figure 6.4</span></a> illustrates an even parity scheme, with the single parity bit being stored in a separate field.</p>
<p>Receiver operation is also simple with a single parity bit. The receiver need only count the number of 1s in the received d+1 bits. If an odd number of 1-valued bits are found with an even parity scheme, the receiver knows that at least one bit error has occurred. More precisely, it knows that some odd number of bit errors have occurred.</p>
<p>But what happens if an even number of bit errors occur? You should convince yourself that this would result in an undetected error. If the probability of bit errors is small and errors can be assumed to occur independently from one bit to the next, the probability of multiple bit errors in a packet would be extremely small. In this case, a single parity bit might suffice. However, measurements have shown that, rather than occurring independently, errors are often clustered together in “bursts.” Under burst error conditions, the probability of undetected errors in a frame protected by single-bit parity can approach 50 percent <a class="reference internal" href="../references.html#spragins-1991"><span class="std std-ref">[Spragins 1991]</span></a>. Clearly, a more robust error-detection scheme is needed (and, fortunately, is used in practice!). But before examining error-detection schemes that are used in practice, let’s consider a simple generalization of one-bit parity that will provide us with insight into error-correction techniques.</p>
<figure class="align-center">
<img alt="../_images/502-0.png" src="../_images/502-0.png" />
</figure>
<p><strong>Figure 6.4 One-bit even parity</strong></p>
<p><a class="reference internal" href="#figure-6-5"><span class="std std-ref">Figure 6.5</span></a> shows a two-dimensional generalization of the single-bit parity scheme. Here, the d bits in D
are divided into i rows and j columns. A parity value is computed for each row and for each column. The resulting i+j+1 parity bits comprise the link-layer frame’s error-detection bits.</p>
<p>Suppose now that a single bit error occurs in the original d bits of information. With this <strong>two-dimensional parity</strong> scheme, the parity of both the column and the row containing the flipped bit will be in error. The receiver can thus not only detect the fact that a single bit error has occurred, but can use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted and correct that error! <a class="reference internal" href="#figure-6-5"><span class="std std-ref">Figure 6.5</span></a> shows an example in which the 1-valued bit in position (2,2) is corrupted and switched to a 0—an error that is both detectable and correctable at the receiver. Although our discussion has focused on the original d bits of information, a single error in the parity bits themselves is also detectable and correctable. Two-dimensional parity can also detect (but not correct!) any combination of two errors in a packet. Other properties of the two-dimensional parity scheme are explored in the problems at the end of the chapter.</p>
<figure class="align-center">
<img alt="../_images/503-0.png" src="../_images/503-0.png" />
</figure>
<p><strong>Figure 6.5 Two-dimensional even parity</strong></p>
<p>The ability of the receiver to both detect and correct errors is known as <strong>forward error correction (FEC)</strong>. These techniques are commonly used in audio storage and playback devices such as audio CDs. In a network setting, FEC techniques can be used by themselves, or in conjunction with link-layer ARQ techniques similar to those we examined in <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a>. FEC techniques are valuable because they can decrease the number of sender retransmissions required. Perhaps more important, they allow for immediate correction of errors at the receiver. This avoids having to wait for the round-trip propagation delay needed for the sender to receive a NAK packet and for the retransmitted packet to propagate back to the receiver—a potentially important advantage for real-time network applications <a class="reference internal" href="../references.html#rubenstein-1998"><span class="std std-ref">[Rubenstein 1998]</span></a> or links (such as deep-space links) with long propagation delays. Research examining the use of FEC in error-control protocols includes [<a class="reference internal" href="../references.html#biersack-1992"><span class="std std-ref">Biersack 1992</span></a>; <a class="reference internal" href="../references.html#nonnenmacher-1998"><span class="std std-ref">Nonnenmacher 1998</span></a>; <a class="reference internal" href="../references.html#byers-1998"><span class="std std-ref">Byers 1998</span></a>; <a class="reference internal" href="../references.html#shacham-1990"><span class="std std-ref">Shacham 1990</span></a>].</p>
</div>
</section>
<section id="c6-2-2">
<span id="id4"></span><h2>6.2.2 校验和方法<a class="headerlink" href="#c6-2-2" title="此标题的永久链接">#</a></h2>
<p>6.2.2 Checksumming Methods</p>
<p>在校验和技术中， <a class="reference internal" href="#figure-6-4"><span class="std std-ref">图 6.4</span></a> 中的 d 位数据被视为一组 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位整数序列。一种简单的校验和方法就是将这些 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位整数相加，并使用所得总和作为错误检测比特。Internet 校验和就是基于该方法实现的——数据按字节划分为 16 位整数并求和。其 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的补码即构成携带在段头中的 Internet 校验和。如 <a class="reference internal" href="../c3/s3.html#c3-3"><span class="std std-ref">第3.3节</span></a> 所述，接收方通过计算接收到的数据（包括校验和）的总和的 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的补码，并检查结果是否全为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 来验证校验和。如果存在任何 <code class="docutils literal notranslate"><span class="pre">0</span></code>，则说明发生了错误。 <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1071.html"><strong>RFC 1071</strong></a> 中详细讨论了 Internet 校验和算法及其实现。在 TCP 和 UDP 协议中，Internet 校验和计算覆盖所有字段（包括头部和数据字段）。而在 IP 协议中，校验和只覆盖 IP 头部（因为 UDP 或 TCP 段有自己的校验和）。在其他协议中，例如 XTP <a class="reference internal" href="../references.html#strayer-1992"><span class="std std-ref">[Strayer 1992]</span></a>，会分别计算头部校验和与整个数据包的校验和。</p>
<p>校验和方法的报文开销相对较小。例如，在 TCP 和 UDP 中，校验和仅使用 16 位。然而，与接下来讨论的循环冗余校验（CRC）相比，它们提供的错误保护能力相对较弱。此时一个自然的问题是，为什么传输层使用校验和而链路层使用 CRC？回想一下，传输层通常作为主机操作系统的一部分由软件实现。因为传输层错误检测是由软件实现的，因此使用像校验和这样简单快速的检测方法显得尤为重要。而链路层的错误检测则由适配器中的专用硬件实现，能够快速完成更复杂的 CRC 运算。Feldmeier <a class="reference internal" href="../references.html#feldmeier-1995"><span class="std std-ref">[Feldmeier 1995]</span></a> 提出了快速实现加权校验和代码、CRC（见下文）及其他代码的软件技术。</p>
<div class="toggle docutils container">
<p>In checksumming techniques, the d bits of data in Figure 6.4 are treated as a sequence of k-bit integers. One simple checksumming method is to simply sum these k-bit integers and use the resulting sum as the error-detection bits. The Internet checksum is based on this approach—bytes of data are treated as 16-bit integers and summed. The 1s complement of this sum then forms the Internet checksum that is carried in the segment header. As discussed in <a class="reference internal" href="../c3/s3.html#c3-3"><span class="std std-ref">Section 3.3</span></a>, the receiver checks the checksum by taking the 1s complement of the sum of the received data (including the checksum) and checking whether the result is all 1 bits. If any of the bits are 0, an error is indicated. RFC 1071 discusses the Internet checksum algorithm and its implementation in detail. In the TCP and UDP protocols, the Internet checksum is computed over all fields (header and data fields included). In IP the checksum is computed over the IP header (since the UDP or TCP segment has its own checksum). In other protocols, for example, XTP <a class="reference internal" href="../references.html#strayer-1992"><span class="std std-ref">[Strayer 1992]</span></a>, one checksum is computed over the header and another checksum is computed over the entire packet.</p>
<p>Checksumming methods require relatively little packet overhead. For example, the checksums in TCP and UDP use only 16 bits. However, they provide relatively weak protection against errors as compared with cyclic redundancy check, which is discussed below and which is often used in the link layer. A natural question at this point is, Why is checksumming used at the transport layer and cyclic redundancy check used at the link layer? Recall that the transport layer is typically implemented in software in a host as part of the host’s operating system. Because transport-layer error detection is implemented in software, it is important to have a simple and fast error-detection scheme such as checksumming. On the other hand, error detection at the link layer is implemented in dedicated hardware in adapters, which can rapidly perform the more complex CRC operations. Feldmeier <a class="reference internal" href="../references.html#feldmeier-1995"><span class="std std-ref">[Feldmeier 1995]</span></a> presents fast software implementation techniques for not only weighted checksum codes, but CRC (see below) and other codes as well.</p>
</div>
</section>
<section id="crc">
<span id="c6-2-3"></span><h2>6.2.3 循环冗余校验（CRC）<a class="headerlink" href="#crc" title="此标题的永久链接">#</a></h2>
<p>6.2.3 Cyclic Redundancy Check (CRC)</p>
<p>在当今的计算机网络中被广泛使用的一种错误检测技术是基于 <strong>循环冗余校验（CRC）码</strong> 的。CRC 码也称为 <strong>多项式码</strong>，因为我们可以将待发送的比特串视作一个多项式，其系数由比特串中的 0 和 1 值组成，对该比特串的操作即为多项式算术。</p>
<p>CRC 码的工作原理如下。假设发送节点希望发送 <code class="docutils literal notranslate"><span class="pre">d</span></code> 位数据 <code class="docutils literal notranslate"><span class="pre">D</span></code>。发送方和接收方首先要协商一个 <code class="docutils literal notranslate"><span class="pre">r+1</span></code> 位的模式，称为 <strong>生成多项式（G）</strong>。我们要求 <code class="docutils literal notranslate"><span class="pre">G</span></code> 的最高有效位（最左边一位）为1。CRC 码的核心思想如 <a class="reference internal" href="#figure-6-6"><span class="std std-ref">图 6.6</span></a> 所示。对于给定的数据 <code class="docutils literal notranslate"><span class="pre">D</span></code>，发送方会选择 <code class="docutils literal notranslate"><span class="pre">r</span></code> 位额外比特 <code class="docutils literal notranslate"><span class="pre">R</span></code> 并将其附加在 <code class="docutils literal notranslate"><span class="pre">D</span></code> 之后，使得最终得到的 <code class="docutils literal notranslate"><span class="pre">d+r</span></code> 比特模式（作为二进制数）可以被 <code class="docutils literal notranslate"><span class="pre">G</span></code> 整除（即模2算术下无余数）。CRC 的错误检测过程非常简单：接收方将接收到的 <code class="docutils literal notranslate"><span class="pre">d+r</span></code> 比特除以 <code class="docutils literal notranslate"><span class="pre">G</span></code>。如果余数不为零，则说明发生了错误；否则接收方接受该数据为正确。</p>
<p>所有的 CRC 计算均在模2算术下进行，既无进位加法也无借位减法。这意味着加法与减法等价，二者都等价于按位异或（XOR）操作。例如，</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1011 XOR 0101 = 1110
1001 XOR 1101 = 0100
</pre></div>
</div>
<p>同样我们有：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1011 - 0101 = 1110
1001 - 1101 = 0100
</pre></div>
</div>
<p>乘法和除法操作与普通二进制运算相同，不同之处在于所需的加减法在无进位/借位的条件下进行。正如普通二进制运算中那样，乘以 <span class="math notranslate nohighlight">\(2^k\)</span> 会将比特串向左移动 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位。因此，给定 <code class="docutils literal notranslate"><span class="pre">D</span></code> 和 <code class="docutils literal notranslate"><span class="pre">R</span></code>，表达式 <span class="math notranslate nohighlight">\(D⋅2^r \space \text{XOR} \space R\)</span> 表示 <a class="reference internal" href="#figure-6-6"><span class="std std-ref">图 6.6</span></a> 所示的 <code class="docutils literal notranslate"><span class="pre">d+r</span></code> 比特模式。我们将在下文讨论中使用该代数表示法来描述 <a class="reference internal" href="#figure-6-6"><span class="std std-ref">图 6.6</span></a> 中的 <code class="docutils literal notranslate"><span class="pre">d+r</span></code> 比特模式。</p>
<figure class="align-center" id="figure-6-6">
<img alt="../_images/505-0.png" src="../_images/505-0.png" />
</figure>
<p><strong>图 6.6 CRC</strong></p>
<p>现在让我们讨论发送方如何计算 R。我们希望找到 R，使得存在一个 n 满足：</p>
<p><span class="math notranslate nohighlight">\(D⋅2^r \space \text{XOR} \space R = nG\)</span></p>
<p>即我们希望选择 <code class="docutils literal notranslate"><span class="pre">R</span></code>，使得 <code class="docutils literal notranslate"><span class="pre">G</span></code> 能整除 <span class="math notranslate nohighlight">\(D⋅2^r \space \text{XOR} \space R\)</span> 而无余数。如果我们对上述等式两边进行异或操作（即模2加法），我们得到：</p>
<p><span class="math notranslate nohighlight">\(D⋅2^r \space = \space nG \space \text{XOR} \space R\)</span></p>
<p>该等式表明，如果我们将 <span class="math notranslate nohighlight">\(D⋅2^r\)</span> 除以 <code class="docutils literal notranslate"><span class="pre">G</span></code>，所得余数正是 <code class="docutils literal notranslate"><span class="pre">R</span></code>。换句话说， <code class="docutils literal notranslate"><span class="pre">R</span></code> 可以计算为：</p>
<p><span class="math notranslate nohighlight">\(R = \text{remainder}\frac{D⋅2^r}{G}\)</span></p>
<p><a class="reference internal" href="#figure-6-7"><span class="std std-ref">图 6.7</span></a> 展示了一个计算示例，其中 <code class="docutils literal notranslate"><span class="pre">D=101110</span></code>， <code class="docutils literal notranslate"><span class="pre">d=6</span></code>， <code class="docutils literal notranslate"><span class="pre">G=1001</span></code>， <code class="docutils literal notranslate"><span class="pre">r=3</span></code>。在该示例中发送的 <code class="docutils literal notranslate"><span class="pre">9</span></code> 位为 <code class="docutils literal notranslate"><span class="pre">101110011</span></code>。你可以自己验证这个计算，并检查是否确实有 <span class="math notranslate nohighlight">\(D⋅2^r = 101011⋅G \space \text{XOR} \space  R\)</span>。</p>
<figure class="align-center" id="figure-6-7">
<img alt="../_images/506-0.png" src="../_images/506-0.png" />
</figure>
<p><strong>图 6.7 CRC 示例计算</strong></p>
<p>目前已为 8 位、12 位、16 位和 32 位的生成多项式 <code class="docutils literal notranslate"><span class="pre">G</span></code> 定义了国际标准。 <code class="docutils literal notranslate"><span class="pre">CRC-32</span></code> 是一个 32 位标准，被多个链路层 IEEE 协议采纳，其生成多项式为：</p>
<p><code class="docutils literal notranslate"><span class="pre">GCRC-32</span> <span class="pre">=</span> <span class="pre">100000100110000010001110110110111</span></code></p>
<p>每个 CRC 标准都能检测长度小于 <code class="docutils literal notranslate"><span class="pre">r+1</span></code> 的突发错误。（即所有连续 r 位或更少位的错误都会被检测到）。此外，在合适的假设条件下，长度大于 <code class="docutils literal notranslate"><span class="pre">r+1</span></code> 的突发错误将以概率 <span class="math notranslate nohighlight">\(1-0.5^r\)</span> 被检测到。此外，每个 CRC 标准都能检测任意奇数个比特错误。关于 CRC 校验的实现讨论，详见 <span class="xref std std-ref">[Williams 1993]</span>。CRC 码及更强大的编码方案背后的理论超出了本书的范围，参考文献 <a class="reference internal" href="../references.html#schwartz-1980"><span class="std std-ref">[Schwartz 1980]</span></a> 为该主题提供了优秀的入门介绍。</p>
<div class="toggle docutils container">
<p>An error-detection technique used widely in today’s computer networks is based on <strong>cyclic redundancy check (CRC) codes</strong>. CRC codes are also known as <strong>polynomial codes</strong>, since it is possible to view the bit string to be sent as a polynomial whose coefficients are the 0 and 1 values in the bit string, with operations on the bit string interpreted as polynomial arithmetic.</p>
<p>CRC codes operate as follows. Consider the d-bit piece of data, D, that the sending node wants to send to the receiving node. The sender and receiver must first agree on an r+1 bit pattern, known as a <strong>generator</strong>, which we will denote as G. We will require that the most significant (leftmost) bit of G be a 1. The key idea behind CRC codes is shown in <a class="reference internal" href="#figure-6-6"><span class="std std-ref">Figure 6.6</span></a>. For a given piece of data, D, the sender will choose r additional bits, R, and append them to D such that the resulting d+r bit pattern (interpreted as a binary number) is exactly divisible by G (i.e., has no remainder) using modulo-2 arithmetic. The process of error checking with CRCs is thus simple: The receiver divides the d+r received bits by G. If the remainder is nonzero, the receiver knows that an error has occurred; otherwise the data is accepted as being correct.</p>
<p>All CRC calculations are done in modulo-2 arithmetic without carries in addition or borrows in subtraction. This means that addition and subtraction are identical, and both are equivalent to the bitwise exclusive-or (XOR) of the operands. Thus, for example,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1011 XOR 0101 = 1110
1001 XOR 1101 = 0100
</pre></div>
</div>
<p>Also, we similarly have</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1011 - 0101 = 1110
1001 - 1101 = 0100
</pre></div>
</div>
<p>Multiplication and division are the same as in base-2 arithmetic, except that any required addition or subtraction is done without carries or borrows. As in regular binary arithmetic, multiplication by <span class="math notranslate nohighlight">\(2^k\)</span> left shifts a bit pattern by k places. Thus, given D and R, the quantity D⋅2rXOR R yields the d+r bit pattern shown in <a class="reference internal" href="#figure-6-6"><span class="std std-ref">Figure 6.6</span></a>. We’ll use this algebraic characterization of the d+r bit pattern from <a class="reference internal" href="#figure-6-6"><span class="std std-ref">Figure 6.6</span></a> in our discussion below.</p>
<figure class="align-center">
<img alt="../_images/505-0.png" src="../_images/505-0.png" />
</figure>
<p><strong>Figure 6.6 CRC</strong></p>
<p>Let us now turn to the crucial question of how the sender computes R. Recall that we want to find R such that there is an n such that</p>
<p><code class="docutils literal notranslate"><span class="pre">D⋅2rXOR</span> <span class="pre">R=nG</span></code></p>
<p>That is, we want to choose R such that G divides into D⋅2rXOR R without remainder. If we XOR (that is, add modulo-2, without carry) R to both sides of the above equation, we get</p>
<p><code class="docutils literal notranslate"><span class="pre">D⋅2r=nG</span> <span class="pre">XOR</span> <span class="pre">R</span></code></p>
<p>This equation tells us that if we divide D⋅2r by G, the value of the remainder is precisely R. In other words, we can calculate R as</p>
<p><code class="docutils literal notranslate"><span class="pre">R=remainderD⋅2rG</span></code></p>
<p><a class="reference internal" href="#figure-6-7"><span class="std std-ref">Figure 6.7</span></a> illustrates this calculation for the case of D=101110, d=6, G=1001, and r=3. The 9 bits transmitted in this case are 101 110  011. You should check these calculations for yourself and also check that indeed D⋅2r=101011⋅G XOR R.</p>
<figure class="align-center">
<img alt="../_images/506-0.png" src="../_images/506-0.png" />
</figure>
<p><strong>Figure 6.7 A sample CRC calculation</strong></p>
<p>International standards have been defined for 8-, 12-, 16-, and 32-bit generators, G. The CRC-32 32-bit standard, which has been adopted in a number of link-level IEEE protocols, uses a generator of</p>
<p><code class="docutils literal notranslate"><span class="pre">GCRC-32=100000100110000010001110110110111</span></code></p>
<p>Each of the CRC standards can detect burst errors of fewer than r+1 bits. (This means that all consecutive bit errors of r bits or fewer will be detected.) Furthermore, under appropriate assumptions, a burst of length greater than r+1 bits is detected with probability 1−0.5r. Also, each of the CRC standards can detect any odd number of bit errors. See <span class="xref std std-ref">[Williams 1993]</span> for a discussion of implementing CRC checks. The theory behind CRC codes and even more powerful codes is beyond the scope of this text. The text <a class="reference internal" href="../references.html#schwartz-1980"><span class="std std-ref">[Schwartz 1980]</span></a> provides an excellent introduction to this topic.</p>
</div>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="s1.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">6.1 链路层简介</p>
      </div>
    </a>
    <a class="right-next"
       href="s3.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">6.3 多路访问链路与协议</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c6-2-1">6.2.1 奇偶校验</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c6-2-2">6.2.2 校验和方法</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#crc">6.2.3 循环冗余校验（CRC）</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>