

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>4.1 网络层概述 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c4/s1';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="4.2 路由器的内部结构" href="s2.html" />
    <link rel="prev" title="第 4 章 网络层：数据平面" href="index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c2/index.html">第 2 章 应用层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c2/s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s3.html">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s4.html">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s5.html">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 4 章 网络层：数据平面</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c6/index.html">第 6 章 链路层与局域网（LANs）</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c6/s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s2.html">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c8/index.html">第 8 章 计算机网络中的安全</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c8/s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s2.html">8.2 密码学原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s3.html">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c9/index.html">第 9 章 多媒体网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c9/s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s2.html">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c4/s1.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>4.1 网络层概述</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c4-1-1">4.1.1 转发与路由：网络数据与控制平面</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">控制平面：传统方法</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sdn">控制平面：SDN 方法</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c4-1-2">4.1.2 网络服务模型</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">第 4 章概览</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="c4-1">
<span id="id1"></span><h1>4.1 网络层概述<a class="headerlink" href="#c4-1" title="此标题的永久链接">#</a></h1>
<p>4.1 Overview of Network Layer</p>
<p><a class="reference internal" href="#figure-4-1"><span class="std std-ref">图 4.1</span></a> 展示了一个包含两台主机 H1 和 H2 以及若干路由器的简单网络。假设 H1 正在向 H2 发送信息，我们来看网络层在这两台主机及其间路由器中的作用。H1 中的网络层从其传输层获取报文段，将每个报文段封装进数据报中，然后将这些数据报发送到其附近的路由器 R1。在接收端 H2，网络层从其附近的路由器 R2 接收数据报，提取出传输层的报文段，并将这些报文段上交至 H2 的传输层。每台路由器在数据平面中的主要角色是将数据报从其输入链路转发到相应的输出链路；而网络控制平面的主要角色是协调这些每个路由器本地的转发行为，以便数据报最终能在源主机和目的主机之间通过路由器路径端到端传输。请注意，<a class="reference internal" href="#figure-4-1"><span class="std std-ref">图 4.1</span></a> 中的路由器仅展示了截断的协议栈，也就是说，其网络层之上没有应用层或传输层协议，因为路由器不运行我们在 <a class="reference internal" href="../c2/index.html#c2"><span class="std std-ref">第 2 章</span></a> 和 <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">第 3 章</span></a> 中讨论的应用层和传输层协议。</p>
<div class="toggle docutils container">
<p><a class="reference internal" href="#figure-4-1"><span class="std std-ref">Figure 4.1</span></a> shows a simple network with two hosts, H1 and H2, and several routers on the path between
H1 and H2. Let’s suppose that H1 is sending information to H2, and consider the role of the network
layer in these hosts and in the intervening routers. The network layer in H1 takes segments from the
transport layer in H1, encapsulates each segment into a datagram, and then sends the datagrams to its
nearby router, R1. At the receiving host, H2, the network layer receives the datagrams from its nearby
router R2, extracts the transport-layer segments, and delivers the segments up to the transport layer at
H2. The primary data-plane role of each router is to forward datagrams from its input links to its output
links; the primary role of the network control plane is to coordinate these local, per-router forwarding
actions so that datagrams are ultimately transferred end-to-end, along paths of routers between source
and destination hosts. Note that the routers in <span class="xref std std-ref">Figure 4.1</span> are shown with a truncated protocol stack, that
is, with no upper layers above the network layer, because routers do not run application- and transport-
layer protocols such as those we examined in <a class="reference internal" href="../c2/index.html#c2"><span class="std std-ref">Chapters 2</span></a> and <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">3</span></a>.</p>
</div>
<section id="c4-1-1">
<span id="id2"></span><h2>4.1.1 转发与路由：网络数据与控制平面<a class="headerlink" href="#c4-1-1" title="此标题的永久链接">#</a></h2>
<p>4.1.1 Forwarding and Routing: The Network Data and Control Planes</p>
<p>网络层的主要角色看似简单——将分组从发送主机传送至接收主机。为了实现这一目标，可以识别出两个重要的网络层功能：</p>
<ul>
<li><p><strong>转发</strong>。当一个分组到达路由器的输入链路时，路由器必须将该分组移交至合适的输出链路。例如，<a class="reference internal" href="#figure-4-1"><span class="std std-ref">图 4.1</span></a> 中从主机 H1 到达路由器 R1 的分组必须被转发至通往 H2 的下一跳路由器。正如我们将看到的，转发只是数据平面中实现的一个功能（虽然是最常见、最重要的一个功能！）。在更一般的情况下（我们将在 <a class="reference internal" href="s4.html#c4-4"><span class="std std-ref">第 4.4 节</span></a> 中讨论），分组也可能被阻止从路由器中输出（例如，若该分组来自一个已知的恶意主机，或其目标地址为被禁止的目的主机），或者被复制并通过多个输出链路发送。</p>
<figure class="align-center" id="figure-4-1">
<img alt="../_images/351-0.png" src="../_images/351-0.png" />
</figure>
<p><strong>图 4.1 网络层</strong></p>
</li>
<li><p><strong>路由</strong>。网络层必须确定分组从发送方到接收方所经过的路径。用于计算这些路径的算法称为 <strong>路由算法</strong>。例如，路由算法将确定 <a class="reference internal" href="#figure-4-1"><span class="std std-ref">图 4.1</span></a> 中从 H1 到 H2 的分组所经过的路径。路由功能在网络层的控制平面中实现。</p></li>
</ul>
<p>在许多讨论网络层的文献中，“转发”和“路由”两个术语经常被互换使用。但在本书中我们会更为精确地使用这些术语。 <strong>转发</strong> 是指路由器本地的动作，即将一个分组从输入链路接口转交至相应的输出链路接口。转发发生在非常短的时间尺度（通常为数纳秒），因此通常通过硬件实现。 <strong>路由</strong> 是指一个网络范围内的过程，用于决定分组从源主机到目的主机所经过的端到端路径。路由发生在较长的时间尺度（通常为数秒），并且通常通过软件实现。借用我们在 <a class="reference internal" href="../c1/s3.html#c1-3-1"><span class="std std-ref">第 1.3.1 节</span></a> 中的驾驶类比，考虑一位旅行者从宾夕法尼亚州出发开车前往佛罗里达州。在旅途中，驾驶者会经过多个高速公路交汇点。我们可以将“转发”类比为通过一个单独交汇点的过程：汽车从一条道路驶入交汇点，并决定从哪条路驶出。而“路由”则相当于从宾夕法尼亚到佛罗里达的行程规划：出发前驾驶者查阅地图，从多个可能路径中选择一条，其中每条路径由一系列通过交汇点相连的路段组成。</p>
<p>每台网络路由器中的关键组成部分是其 <strong>转发表</strong>。路由器通过检查到达分组首部中的一个或多个字段，并使用这些字段的值在其转发表中索引，从而完成分组转发。该转发表项中存储的值指示该分组应被转发到哪个输出链路接口。例如，<a class="reference internal" href="#figure-4-2"><span class="std std-ref">图 4.2</span></a> 中，一个首部字段值为 <code class="docutils literal notranslate"><span class="pre">0110</span></code> 的分组到达路由器，路由器使用该值索引其转发表，得出该分组应转发到接口 2。路由器随后将分组在内部转发到接口 2。我们将在 <a class="reference internal" href="s2.html#c4-2"><span class="std std-ref">第 4.2 节</span></a> 中深入探讨路由器内部的转发功能。转发是网络层数据平面执行的核心功能。</p>
<div class="toggle docutils container">
<p>The primary role of the network layer is deceptively simple—to move packets from a sending host to a receiving host. To do so, two important network-layer functions can be identified:</p>
<ul>
<li><p><strong>Forwarding</strong>. When a packet arrives at a router’s input link, the router must move the packet to the appropriate output link. For example, a packet arriving from Host H1 to Router R1 in <a class="reference internal" href="#figure-4-1"><span class="std std-ref">Figure 4.1</span></a> must be forwarded to the next router on a path to H2. As we will see, forwarding is but one function (albeit the most common and important one!) implemented in the data plane. In the more general case, which we’ll cover in <a class="reference internal" href="s4.html#c4-4"><span class="std std-ref">Section 4.4</span></a>, a packet might also be blocked from exiting a router (e.g., if the packet originated at a known malicious sending host, or if the packet were destined to a forbidden destination host), or might be duplicated and sent over multiple outgoing links.</p>
<figure class="align-center">
<img alt="../_images/351-0.png" src="../_images/351-0.png" />
</figure>
<p><strong>Figure 4.1 The network layer</strong></p>
</li>
<li><p><strong>Routing</strong>. The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as <strong>routing algorithms</strong>. A routing algorithm would determine, for example, the path along which packets flowfrom H1 to H2 in <a class="reference internal" href="#figure-4-1"><span class="std std-ref">Figure 4.1</span></a>. Routing is implemented in the control plane of the network layer.</p></li>
</ul>
<p>The terms forwarding and routing are often used interchangeably by authors discussing the network
layer. We’ll use these terms much more precisely in this book. <strong>Forwarding</strong> refers to the router-local
action of transferring a packet from an input link interface to the appropriate output link interface.
Forwarding takes place at very short timescales (typically a few nanoseconds), and thus is typically
implemented in hardware. <strong>Routing</strong> refers to the network-wide process that determines the end-to-end
paths that packets take from source to destination. Routing takes place on much longer timescales
(typically seconds), and as we will see is often implemented in software. Using our driving analogy,
consider the trip from Pennsylvania to Florida undertaken by our traveler back in <a class="reference internal" href="../c1/s3.html#c1-3-1"><span class="std std-ref">Section 1.3.1</span></a>. During
this trip, our driver passes through many interchanges en route to Florida. We can think of forwarding as
the process of getting through a single interchange: A car enters the interchange from one road and
determines which road it should take to leave the interchange. We can think of routing as the process of
planning the trip from Pennsylvania to Florida: Before embarking on the trip, the driver has consulted a
map and chosen one of many paths possible, with each path consisting of a series of road segments
connected at interchanges.</p>
<p>A key element in every network router is its <strong>forwarding table</strong>. A router forwards a packet by examining
the value of one or more fields in the arriving packet’s header, and then using these header values to
index into its forwarding table. The value stored in the forwarding table entry for those values indicates
the outgoing link interface at that router to which that packet is to be forwarded. For example, in <a class="reference internal" href="#figure-4-2"><span class="std std-ref">Figure 4.2</span></a>, a packet with header field value of <code class="docutils literal notranslate"><span class="pre">0110</span></code> arrives to a router. The router indexes into its forwarding
table and determines that the output link interface for this packet is interface 2. The router then internally
forwards the packet to interface 2. In <a class="reference internal" href="s2.html#c4-2"><span class="std std-ref">Section 4.2</span></a>, we’ll look inside a router and examine the forwarding
function in much greater detail. Forwarding is the key function performed by the data-plane functionality
of the network layer.</p>
</div>
<section id="id3">
<h3>控制平面：传统方法<a class="headerlink" href="#id3" title="此标题的永久链接">#</a></h3>
<p>Control Plane: The Traditional Approach</p>
<p>你可能会好奇：一台路由器的转发表最初是如何配置的？这是一个关键问题，涉及到数据平面中的转发功能与控制平面中的路由功能之间的重要关系。如 <a class="reference internal" href="#figure-4-2"><span class="std std-ref">图 4.2</span></a> 所示，路由算法决定了路由器转发表的内容。在这个例子中，每台路由器上都运行一个路由算法，转发和路由功能都包含在路由器内部。正如我们将在 <a class="reference internal" href="../c5/s3.html#c5-3"><span class="std std-ref">第 5.3 节</span></a> 和 <a class="reference internal" href="../c5/s4.html#c5-4"><span class="std std-ref">第 5.4 节</span></a> 中看到的，一台路由器中的路由算法会与其它路由器中的路由算法通信，以计算其转发表的值。这种通信是如何完成的呢？通过按照某种路由协议交换包含路由信息的路由消息！我们将在 <a class="reference internal" href="../c5/s2.html#c5-2"><span class="std std-ref">第 5.2 节</span></a> 至 <a class="reference internal" href="../c5/s4.html#c5-4"><span class="std std-ref">第 5.4 节</span></a> 中介绍路由算法与协议。</p>
<figure class="align-center" id="figure-4-2">
<img alt="../_images/353-0.png" src="../_images/353-0.png" />
</figure>
<p><strong>图 4.2 路由算法决定转发表中的值</strong></p>
<p>通过考虑一种假设性的（虽然不现实但在技术上可行的）网络情景，我们可以进一步说明转发与路由功能在目的上的区别：在这个网络中，所有转发表都由物理存在于路由器旁的人类网络操作员直接配置。在这种情况下，不需要任何路由协议！当然，人类操作员之间需要互相沟通，以确保他们配置的转发表能够使分组被正确传送到目的地。但这种手动配置方式更容易出错，且对网络拓扑变化的响应速度远不如路由协议。因此，我们应庆幸所有网络都具备转发和路由这两个功能！</p>
<div class="toggle docutils container">
<p>But now you are undoubtedly wondering how a router’s forwarding tables are configured in the first
place. This is a crucial issue, one that exposes the important interplay between forwarding (in data
plane) and routing (in control plane). As shown in <a class="reference internal" href="#figure-4-2"><span class="std std-ref">Figure 4.2</span></a>, the routing algorithm determines the contents of the routers’ forwarding tables. In this
example, a routing algorithm runs in each and every router and both forwarding and routing functions
are contained within a router. As we’ll see in <a class="reference internal" href="../c5/s3.html#c5-3"><span class="std std-ref">Sections 5.3</span></a> and <a class="reference internal" href="../c5/s4.html#c5-4"><span class="std std-ref">5.4</span></a>, the routing algorithm function in one
router communicates with the routing algorithm function in other routers to compute the values for its
forwarding table. How is this communication performed? By exchanging routing messages containing
routing information according to a routing protocol! We’ll cover routing algorithms and protocols in
<a class="reference internal" href="../c5/s2.html#c5-2"><span class="std std-ref">Sections 5.2</span></a> through <a class="reference internal" href="../c5/s4.html#c5-4"><span class="std std-ref">5.4</span></a>.</p>
<figure class="align-center">
<img alt="../_images/353-0.png" src="../_images/353-0.png" />
</figure>
<p><strong>Figure 4.2 Routing algorithms determine values in forward tables</strong></p>
<p>The distinct and different purposes of the forwarding and routing functions can be further illustrated by
considering the hypothetical (and unrealistic, but technically feasible) case of a network in which all
forwarding tables are configured directly by human network operators physically present at the routers.
In this case, no routing protocols would be required! Of course, the human operators would need to
interact with each other to ensure that the forwarding tables were configured in such a way that packets
reached their intended destinations. It’s also likely that human configuration would be more error-prone
and much slower to respond to changes in the network topology than a routing protocol. We’re thus
fortunate that all networks have both a forwarding and a routing function!</p>
</div>
</section>
<section id="sdn">
<h3>控制平面：SDN 方法<a class="headerlink" href="#sdn" title="此标题的永久链接">#</a></h3>
<p>Control Plane: The SDN Approach</p>
<p><a class="reference internal" href="#figure-4-2"><span class="std std-ref">图 4.2</span></a> 所示的路由实现方式——每个路由器包含一个可与其他路由器中的路由组件通信的路由组件——是长期以来路由设备供应商产品中采用的传统方法。然而，我们前面关于人类可以手动配置转发表的观察，也暗示控制平面可能还有其他方式决定数据平面中转发表的内容。</p>
<p><a class="reference internal" href="#figure-4-3"><span class="std std-ref">图 4.3</span></a> 展示了另一种方法：一个物理上独立（与路由器分离）的远程控制器计算并下发每个路由器所使用的转发表。请注意，<a class="reference internal" href="#figure-4-2"><span class="std std-ref">图 4.2</span></a> 和 <a class="reference internal" href="#figure-4-3"><span class="std std-ref">图 4.3</span></a> 中的数据平面组件是相同的。然而在 <a class="reference internal" href="#figure-4-3"><span class="std std-ref">图 4.3</span></a> 中，控制平面路由功能被从物理路由器中分离出来——路由设备只负责转发，而远程控制器负责计算并分发转发表。该远程控制器可能部署于一个高可靠性、具备冗余机制的远程数据中心，并由 ISP 或第三方管理。路由器与远程控制器之间如何通信？通过交换包含转发表和其他路由信息的消息。<a class="reference internal" href="#figure-4-3"><span class="std std-ref">图 4.3</span></a> 所示的控制平面方法正是 <strong>软件定义网络（SDN）</strong> 的核心，其“软件定义”体现在用于计算转发表并与路由器交互的控制器是由软件实现的。这些软件实现正越来越开放，即代码公开，类似于 Linux 操作系统代码，使 ISP（以及网络研究人员和学生！）能够进行创新并提出对控制网络层功能的软件的改进建议。我们将在 <a class="reference internal" href="../c5/s5.html#c5-5"><span class="std std-ref">第 5.5 节</span></a> 中介绍 SDN 控制平面。</p>
<figure class="align-center" id="figure-4-3">
<img alt="../_images/354-0.png" src="../_images/354-0.png" />
</figure>
<p><strong>图 4.3 远程控制器决定并下发转发表中的值</strong></p>
<div class="toggle docutils container">
<p>The approach to implementing routing functionality shown in <a class="reference internal" href="#figure-4-2"><span class="std std-ref">Figure 4.2</span></a>—with each router having a
routing component that communicates with the routing component of other routers—has been thetraditional approach adopted by routing vendors in their products, at least until recently. Our observation
that humans could manually configure forwarding tables does suggest, however, that there may be
other ways for control-plane functionality to determine the contents of the data-plane forwarding tables.</p>
<p><a class="reference internal" href="#figure-4-3"><span class="std std-ref">Figure 4.3</span></a> shows an alternate approach in which a physically separate (from the routers), remote
controller computes and distributes the forwarding tables to be used by each and every router. Note that
the data plane components of <a class="reference internal" href="#figure-4-2"><span class="std std-ref">Figures 4.2</span></a> and <a class="reference internal" href="#figure-4-3"><span class="std std-ref">4.3</span></a> are identical. In <a class="reference internal" href="#figure-4-3"><span class="std std-ref">Figure 4.3</span></a>, however, control-plane routing functionality is separated from the physical router—the routing device performs forwarding only, while the remote controller
computes and distributes forwarding tables. The remote controller might be implemented in a remote
data center with high reliability and redundancy, and might be managed by the ISP or some third party.
How might the routers and the remote controller communicate? By exchanging messages containing
forwarding tables and other pieces of routing information. The control-plane approach shown in <a class="reference internal" href="#figure-4-3"><span class="std std-ref">Figure 4.3</span></a> is at the heart of <strong>software-defined networking (SDN)</strong>, where the network is “software-defined”
because the controller that computes forwarding tables and interacts with routers is implemented in
software. Increasingly, these software implementations are also open, i.e., similar to Linux OS code, thecode is publically available, allowing ISPs (and networking researchers and students!) to innovate and
propose changes to the software that controls network-layer functionality. We will cover the SDN control
plane in <a class="reference internal" href="../c5/s5.html#c5-5"><span class="std std-ref">Section 5.5</span></a>.</p>
<figure class="align-center">
<img alt="../_images/354-0.png" src="../_images/354-0.png" />
</figure>
<p><strong>Figure 4.3 A remote controller determines and distributes values in ­forwarding tables</strong></p>
</div>
</section>
</section>
<section id="c4-1-2">
<span id="id4"></span><h2>4.1.2 网络服务模型<a class="headerlink" href="#c4-1-2" title="此标题的永久链接">#</a></h2>
<p>4.1.2 Network Service Models</p>
<p>在深入探讨网络层的数据平面之前，让我们从更广的视角结束这一部分的介绍，考虑网络层可能提供的不同类型的服务。当发送主机的传输层将一个分组发送进网络（也就是将其传递给发送主机的网络层）时，传输层能否依赖网络层将该分组送达目的地？当发送多个分组时，它们是否会按照发送顺序在接收主机的传输层被接收？两个连续分组的发送时间间隔是否等于它们的接收时间间隔？网络是否会提供任何关于网络中拥塞的反馈？这些问题的答案（以及其它问题）都由网络层所提供的服务模型决定。 <strong>网络服务模型</strong> 定义了发送主机与接收主机之间分组端到端传送的特性。</p>
<p>现在让我们来考虑网络层可能提供的一些服务。这些服务可能包括：</p>
<ul class="simple">
<li><p><strong>保证交付</strong>。该服务保证源主机发送的分组最终将抵达目的主机。</p></li>
<li><p><strong>带有时延界限的保证交付</strong>。该服务不仅保证分组交付，而且保证在主机到主机之间指定的时延上限内完成交付（例如，100 毫秒以内）。</p></li>
<li><p><strong>顺序分组交付</strong>。该服务保证分组按发送顺序到达目的地。</p></li>
<li><p><strong>保证最小带宽</strong>。该网络层服务模拟一个具有指定比特率（例如 1 Mbps）的传输链路的行为，在发送主机和接收主机之间。如果发送主机以低于该指定比特率的速率发送比特（作为分组的一部分），那么所有分组最终都将送达目的主机。</p></li>
<li><p><strong>安全性</strong>。网络层可以在源端对所有数据报进行加密，在目的端进行解密，从而为所有传输层报文段提供保密性。</p></li>
</ul>
<p>这只是网络层可能提供的服务的一部分——还有无数种可能的变体。</p>
<p>互联网的网络层只提供一种服务，称为 <strong>尽力而为服务</strong>。在尽力而为服务中，分组既不能保证按发送顺序被接收，也不能保证最终一定会被送达。它不对端到端时延做出任何保证，也不保证最小带宽。乍看之下，尽力而为服务似乎就是“根本没有服务”的委婉说法——一个将所有分组都丢弃、不送达目的主机的网络也能满足尽力而为服务的定义！其它网络体系结构定义并实现了超越互联网尽力而为服务的服务模型。例如，ATM 网络体系结构 [<span class="xref std std-ref">MFA Forum 2016</span>，<a class="reference internal" href="../references.html#black-1995"><span class="std std-ref">Black 1995</span></a>] 提供顺序交付、带界限的时延、以及保证的最小带宽。也有一些对互联网架构的服务模型扩展方案，例如 Intserv 架构 <a class="reference internal" href="../references.html#rfc-1633"><span class="std std-ref">[RFC 1633]</span></a>，旨在提供端到端的时延保证和无拥塞通信。有趣的是，尽管有这些成熟的替代方案，互联网基础的尽力而为服务模型结合充分的带宽配置，已经被证明足以支持丰富多样的应用，包括 Netflix 这类流媒体视频服务、VoIP 语音和视频通信，以及如 Skype 和 Facetime 的实时会议应用。</p>
<div class="toggle docutils container">
<p>Before delving into the network layer’s data plane, let’s wrap up our introduction by taking the broader
view and consider the different types of service that might be offered by the network layer. When the
transport layer at a sending host transmits a packet into the network (that is, passes it down to the
network layer at the sending host), can the transport layer rely on the network layer to deliver the packet
to the destination? When multiple packets are sent, will they be delivered to the transport layer in the
receiving host in the order in which they were sent? Will the amount of time between the sending of two
sequential packet transmissions be the same as the amount of time between their reception? Will the
network provide any feedback about congestion in the network? The answers to these questions and
others are determined by the service model provided by the network layer. The <strong>network service model</strong>
defines the characteristics of end-to-end delivery of packets between sending and receiving hosts.</p>
<p>Let’s now consider some possible services that the network layer could provide. These services could include:</p>
<ul class="simple">
<li><p><strong>Guaranteed delivery</strong>. This service guarantees that a packet sent by a source host will eventually arrive at the destination host.</p></li>
<li><p><strong>Guaranteed delivery with bounded delay</strong>. This service not only guarantees delivery of the packet, but delivery within a specified host-to-host delay bound (for example, within 100 msec).</p></li>
<li><p><strong>In-order packet delivery</strong>. This service guarantees that packets arrive at the destination in the order</p></li>
</ul>
<p>that they were sent.
- <strong>Guaranteed minimal bandwidth</strong>. This network-layer service emulates the behavior of a
transmission link of a specified bit rate (for example, 1 Mbps) between sending and receiving hosts.
As long as the sending host transmits bits (as part of packets) at a rate below the specified bit rate,
then all packets are eventually delivered to the destination host.
- <strong>Security</strong>. The network layer could encrypt all datagrams at the source and decrypt them at the
destination, thereby providing confidentiality to all transport-layer segments.</p>
<p>This is only a partial list of services that a network layer could provide—there are countless variations
possible.</p>
<p>The Internet’s network layer provides a single service, known as <strong>best-effort service</strong>. With best-effort
service, packets are neither guaranteed to be received in the order in which they were sent, nor is their
eventual delivery even guaranteed. There is no guarantee on the end-to-end delay nor is there aminimal bandwidth guarantee. It might appear that best-effort service is a euphemism for no service at
all—a network that delivered no packets to the destination would satisfy the definition of best-effort
delivery service! Other network architectures have defined and implemented service models that go
beyond the Internet’s best-effort service. For example, the ATM network architecture [<span class="xref std std-ref">MFA Forum 2016</span>, <a class="reference internal" href="../references.html#black-1995"><span class="std std-ref">Black 1995</span></a>] provides for guaranteed in-order delay, bounded delay, and guaranteed minimal
bandwidth. There have also been proposed service model extensions to the Internet architecture; for
example, the Intserv architecture <a class="reference internal" href="../references.html#rfc-1633"><span class="std std-ref">[RFC 1633]</span></a> aims to provide end-end delay guarantees and
congestion-free communication. Interestingly, in spite of these well-developed alternatives, the Internet’s
basic best-effort service model combined with adequate bandwidth provisioning have arguably proven to
be more than “good enough” to enable an amazing range of applications, including streaming video
services such as Netflix and voice-and-video-over-IP, real-time conferencing applications such as Skype
and Facetime.</p>
</div>
<section id="id5">
<h3>第 4 章概览<a class="headerlink" href="#id5" title="此标题的永久链接">#</a></h3>
<p>An Overview of Chapter 4</p>
<p>我们已经概述了网络层的总体情况，接下来我们将在本章的后续部分中介绍网络层的数据平面组件。在 <a class="reference internal" href="s2.html#c4-2"><span class="std std-ref">第 4.2 节</span></a> 中，我们将深入探讨路由器的内部硬件操作，包括输入和输出分组处理、路由器的内部交换机制，以及分组排队与调度机制。在 <a class="reference internal" href="s3.html#c4-3"><span class="std std-ref">第 4.3 节</span></a> 中，我们将介绍传统的 IP 转发机制，即根据分组的目的 IP 地址将其转发到输出端口。我们还将讨论 IP 地址、广为人知的 IPv4 和 IPv6 协议等内容。在 <a class="reference internal" href="s4.html#c4-4"><span class="std std-ref">第 4.4 节</span></a> 中，我们将介绍更通用的转发机制，其中分组可以基于大量首部字段的值（而不仅仅是目的 IP 地址）被转发至输出端口。分组还可能在路由器处被阻止或复制，或具有某些首部字段被改写——所有这些都由软件控制。这种更通用的分组转发形式是现代网络数据平面的关键组成部分，包括软件定义网络（SDN）中的数据平面。</p>
<p>顺便提一句，“转发”（ <em>forwarding</em> ）和“交换”（ <em>switching</em> ）这两个术语在计算机网络研究者和工程师中经常可以互换使用；在本书中我们也将这两个术语视为同义词。同时在术语方面还值得一提的是另两个经常被互换使用，但我们将在本书中更加严格区分的术语。我们将“分组交换机”（<em>packet switch</em>）一词专指一种通用的分组交换设备，它根据分组首部字段中的值，将分组从输入链路接口转发至输出链路接口。有些分组交换设备被称为 <strong>链路层交换机</strong> （在 <a class="reference internal" href="../c6/index.html#c6"><span class="std std-ref">第 6 章</span></a> 中讨论），它们基于链路层帧字段的值做出转发决策，因此被称为链路层（第 2 层）设备。而其他分组交换设备称为 <strong>路由器</strong>，它们根据网络层数据报首部字段的值进行转发决策，因此是网络层（第 3 层）设备。（为了更好地理解这一重要区别，读者可以回顾 <a class="reference internal" href="../c1/s5.html#c1-5-2"><span class="std std-ref">第 1.5.2 节</span></a>，其中我们讨论了网络层数据报与链路层帧及其关系。）由于本章的重点是网络层，我们将主要使用“路由器”这一术语来代替“分组交换机”。</p>
<div class="toggle docutils container">
<p>Having now provided an overview of the network layer, we’ll cover the data-plane component of the
network layer in the following sections in this chapter. In <a class="reference internal" href="s2.html#c4-2"><span class="std std-ref">Section 4.2</span></a>, we’ll dive down into the internal
hardware operations of a router, including input and output packet processing, the router’s internal
switching mechanism, and packet queueing and scheduling. In <a class="reference internal" href="s3.html#c4-3"><span class="std std-ref">Section 4.3</span></a>, we’ll take a look at
traditional IP forwarding, in which packets are forwarded to output ports based on their destination IP
addresses. We’ll encounter IP addressing, the celebrated IPv4 and IPv6 protocols and more. In <a class="reference internal" href="s4.html#c4-4"><span class="std std-ref">Section 4.4</span></a>, we’ll cover more generalized forwarding, where packets may be forwarded to output ports based on
a large number of header values (i.e., not only based on destination IP address). Packets may be
blocked or duplicated at the router, or may have certain header field values rewritten—all under software
control. This more generalized form of packet forwarding is a key component of a modern network data
plane, including the data plane in software-defined networks (SDN).</p>
<p>We mention here in passing that the terms <em>forwarding</em> and <em>switching</em> are often used interchangeably by
computer-networking researchers and practitioners; we’ll use both terms interchangeably in this
textbook as well. While we’re on the topic of terminology, it’s also worth mentioning two other terms that
are often used interchangeably, but that we will use more carefully. We’ll reserve the term packet switch
to mean a general packet-switching device that transfers a packet from input link interface to output link
interface, according to values in a packet’s header fields. Some packet switches, called <strong>link-layer switches</strong> (examined in <a class="reference internal" href="../c6/index.html#c6"><span class="std std-ref">Chapter 6</span></a>), base their forwarding decision on values in the fields of the link-layer frame; switches are thus referred to as link-layer (layer 2) devices. Other packet switches, called
<strong>routers</strong>, base their forwarding decision on header field values in the network-layer datagram. Routers
are thus network-layer (layer 3) devices. (To fully appreciate this important distinction, you might want to
review <a class="reference internal" href="../c1/s5.html#c1-5-2"><span class="std std-ref">Section 1.5.2</span></a>, where we discuss network-layer datagrams and link-layer frames and their
relationship.) Since our focus in this chapter is on the network layer, we’ll mostly use the term <em>router</em> in
place of <em>packet switch</em>.</p>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">第 4 章 网络层：数据平面</p>
      </div>
    </a>
    <a class="right-next"
       href="s2.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">4.2 路由器的内部结构</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c4-1-1">4.1.1 转发与路由：网络数据与控制平面</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">控制平面：传统方法</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sdn">控制平面：SDN 方法</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c4-1-2">4.1.2 网络服务模型</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">第 4 章概览</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>