

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>8.2 密码学原理 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c8/s2';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="8.3 消息完整性和数字签名" href="s3.html" />
    <link rel="prev" title="8.1 什么是网络安全？" href="s1.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c2/index.html">第 2 章 应用层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c2/s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s3.html">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s4.html">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s5.html">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c4/index.html">第 4 章 网络层：数据平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c4/s1.html">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c6/index.html">第 6 章 链路层与局域网（LANs）</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c6/s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s2.html">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 8 章 计算机网络中的安全</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.2 密码学原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="s3.html">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c9/index.html">第 9 章 多媒体网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c9/s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s2.html">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c8/s2.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>8.2 密码学原理</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-2-1">8.2.1 对称密钥密码学</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">块加密</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cbc">密码块链接（CBC）</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-2-2">8.2.2 公钥加密 6048.3 消息完整性与数字签名</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rsa">RSA</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">会话密钥</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">RSA 为何有效？</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="c8-2">
<span id="id1"></span><h1>8.2 密码学原理<a class="headerlink" href="#c8-2" title="此标题的永久链接">#</a></h1>
<p>8.2 Principles of Cryptography</p>
<p>尽管密码学的历史可以追溯到至少凯撒大帝时代，但现代密码技术（包括许多用于互联网的技术）是基于过去三十年取得的进展。Kahn 的著作《The Codebreakers》 <a class="reference internal" href="../references.html#kahn-1967"><span class="std std-ref">[Kahn 1967]</span></a> 和 Singh 的《The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography》 <a class="reference internal" href="../references.html#singh-1999"><span class="std std-ref">[Singh 1999]</span></a> 提供了对密码学悠久历史的精彩回顾。要全面讨论密码学本身需要一本完整的书 [<a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">Kaufman 1995</span></a>; <a class="reference internal" href="../references.html#schneier-1995"><span class="std std-ref">Schneier 1995</span></a>]，因此我们这里只涉及密码学的基本方面，特别是它在互联网上的实际应用。我们还指出，尽管本节的重点是密码学在保密性方面的应用，但很快我们将看到密码技术也与身份验证、消息完整性、不可否认性等密不可分。</p>
<figure class="align-center" id="figure-8-2">
<img alt="../_images/660-0.png" src="../_images/660-0.png" />
</figure>
<p><strong>图 8.2 密码学组成部分</strong></p>
<p>密码技术允许发送方对数据进行伪装，使得入侵者无法从被截获的数据中获取任何信息。当然，接收方必须能够从伪装后的数据中恢复原始数据。<a class="reference internal" href="#figure-8-2"><span class="std std-ref">图 8.2</span></a> 展示了一些重要术语。</p>
<p>现在假设 Alice 想向 Bob 发送一条消息。Alice 的消息以原始形式存在（例如，“Bob，我爱你。Alice”），称为 <strong>明文（plaintext）</strong> 或 <strong>清文（cleartext）</strong>。Alice 使用一种 <strong>加密算法（encryption algorithm）</strong> 对她的明文消息进行加密，使得加密后的消息（称为 <strong>密文（ciphertext）</strong>）对于任何入侵者来说都是不可读的。有趣的是，在许多现代密码系统中，包括那些在互联网上使用的系统，加密技术本身是公开的——发布、标准化并对所有人开放（例如 [<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>; <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3447.html"><strong>RFC 3447</strong></a>; <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2420.html"><strong>RFC 2420</strong></a>; <a class="reference internal" href="../references.html#nist-2001"><span class="std std-ref">NIST 2001</span></a>]），甚至包括潜在的入侵者！显然，如果每个人都知道数据的编码方法，那么一定存在某些秘密信息可以防止入侵者解密传输的数据。这正是 <strong>密钥（key）</strong> 发挥作用的地方。</p>
<p>在 <a class="reference internal" href="#figure-8-2"><span class="std std-ref">图 8.2</span></a> 中，Alice 提供了一个密钥 KA，这是一串数字或字符，作为加密算法的输入。加密算法以密钥和明文消息 m 为输入，输出密文。记号 KA(m) 表示使用密钥 KA 加密后的明文消息 m 的密文形式。使用密钥 KA 的实际 <strong>加密算法</strong> 将由上下文确定。同样，Bob 将提供一个密钥 KB 给 <strong>解密算法（decryption algorithm）</strong>，该算法以密文和 Bob 的密钥为输入，输出原始明文。也就是说，如果 Bob 收到一条加密消息 KA(m)，他通过计算 KB(KA(m)) = m 来解密。</p>
<p>在 <strong>对称密钥系统（symmetric key systems）</strong> 中，Alice 和 Bob 的密钥是相同的，并且是保密的。而在 <strong>公钥系统（public key systems）</strong> 中，使用一对密钥。其中一个密钥对 Bob 和 Alice 都是已知的（实际上是向全世界公开的）。另一个密钥仅为 Bob 或 Alice 所知（但不是两者）。在接下来的两个小节中，我们将更详细地探讨对称密钥系统和公钥系统。</p>
<div class="toggle docutils container">
<p>Although cryptography has a long history dating back at least as far as Julius Caesar, modern cryptographic techniques, including many of those used in the Internet, are based on advances made in the past 30 years. Kahn’s book, The Codebreakers <a class="reference internal" href="../references.html#kahn-1967"><span class="std std-ref">[Kahn 1967]</span></a>, and Singh’s book, The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography <a class="reference internal" href="../references.html#singh-1999"><span class="std std-ref">[Singh 1999]</span></a>, provide a fascinating look at the long history of cryptography. A complete discussion of cryptography itself requires a complete book [<a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">Kaufman 1995</span></a>; <a class="reference internal" href="../references.html#schneier-1995"><span class="std std-ref">Schneier 1995</span></a>] and so we only touch on the essential aspects of cryptography, particularly as they are practiced on the Internet. We also note that while our focus in this section will be on the use of cryptography for confidentiality, we’ll see shortly that cryptographic techniques are inextricably woven into authentication, message integrity, nonrepudiation, and more.</p>
<figure class="align-center">
<img alt="../_images/660-0.png" src="../_images/660-0.png" />
</figure>
<p><strong>Figure 8.2 Cryptographic components</strong></p>
<p>Cryptographic techniques allow a sender to disguise data so that an intruder can gain no information from the intercepted data. The receiver, of course, must be able to recover the original data from the disguised data. <a class="reference internal" href="#figure-8-2"><span class="std std-ref">Figure 8.2</span></a> illustrates some of the important terminology.</p>
<p>Suppose now that Alice wants to send a message to Bob. Alice’s message in its original form (for example, “Bob, I love you. Alice”) is known as p­ <strong>laintext</strong>, or <strong>cleartext</strong>. Alice encrypts her plaintext message using an <strong>encryption algorithm</strong> so that the encrypted message, known as <strong>ciphertext</strong>, looks unintelligible to any intruder. Interestingly, in many modern cryptographic systems, including those used in the Internet, the encryption technique itself is known—published, standardized, and available to everyone (for example, [<span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>; <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3447.html"><strong>RFC 3447</strong></a>; <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2420.html"><strong>RFC 2420</strong></a>; <a class="reference internal" href="../references.html#nist-2001"><span class="std std-ref">NIST 2001</span></a>]), even a potential intruder! Clearly, if everyone knows the method for encoding data, then there must be some secret information that prevents an intruder from decrypting the transmitted data. This is where keys come in.</p>
<p>In <a class="reference internal" href="#figure-8-2"><span class="std std-ref">Figure 8.2</span></a>, Alice provides a <strong>key</strong>, KA, a string of numbers or characters, as input to the encryption algorithm. The encryption algorithm takes the key and the plaintext message, m, as input and produces ciphertext as output. The notation KA(m) refers to the ciphertext form (encrypted using the key KA) of the plaintext message, m. The actual <strong>encryption algorithm</strong> that uses key KA will be evident from the context. Similarly, Bob will provide a key, KB, to the <strong>decryption algorithm</strong> that takes the ciphertext and Bob’s key as input and produces the original plaintext as output. That is, if Bob receives an encrypted message KA(m), he decrypts it by computing KB(KA(m))=m. In <strong>symmetric key systems</strong>, Alice’s and Bob’s keys are identical and are secret. In <strong>public key systems</strong>, a pair of keys is used. One of the keys is known to both Bob and Alice (indeed, it is known to the whole world). The other key is known only by either Bob or Alice (but not both). In the following two subsections, we consider symmetric key and public key systems in more detail.</p>
</div>
<section id="c8-2-1">
<span id="id2"></span><h2>8.2.1 对称密钥密码学<a class="headerlink" href="#c8-2-1" title="此标题的永久链接">#</a></h2>
<p>8.2.1 Symmetric Key Cryptography</p>
<p>所有的密码算法都涉及将一种东西替换为另一种，例如将一段明文转换并替换为相应的密文以创建加密消息。在学习现代基于密钥的密码系统之前，我们先通过研究一种非常古老、非常简单的对称密钥算法来入门，这种算法归功于尤利乌斯·凯撒，称为 <strong>凯撒密码（Caesar cipher）</strong> （cipher 是加密数据的方法）。</p>
<p>对于英文文本，凯撒密码通过将明文消息中的每个字母替换为字母表中向后数第 <code class="docutils literal notranslate"><span class="pre">k</span></code> 个字母（允许环绕，即 <code class="docutils literal notranslate"><span class="pre">z</span></code> 后面是 <code class="docutils literal notranslate"><span class="pre">a</span></code>）来实现加密。例如，如果 <code class="docutils literal notranslate"><span class="pre">k=3</span></code>，那么明文中的字母 <code class="docutils literal notranslate"><span class="pre">a</span></code> 在密文中变为 <code class="docutils literal notranslate"><span class="pre">d</span></code>； <code class="docutils literal notranslate"><span class="pre">b</span></code> 变为 <code class="docutils literal notranslate"><span class="pre">e</span></code>，依此类推。此处， <code class="docutils literal notranslate"><span class="pre">k</span></code> 的值即为密钥。例如，明文消息 “bob, i love you. Alice” 在密文中变为 “ere, l oryh brx. dolfh”。虽然密文看起来确实像乱码，但如果知道使用了凯撒密码，那么破解这个代码不会花太久时间，因为只存在 <code class="docutils literal notranslate"><span class="pre">25</span></code> 种可能的密钥值。</p>
<p>凯撒密码的一种改进是 <strong>单表代换密码（monoalphabetic cipher）</strong>，它同样用另一个字母替代字母表中的一个字母。然而，它不是使用固定的偏移模式（例如所有字母偏移 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位）来替换，而是任意字母都可以替换为另一个字母，只要每个字母有唯一的替代字母，且彼此之间是唯一对应的。<a class="reference internal" href="#figure-8-3"><span class="std std-ref">图 8.3</span></a> 中的替换规则展示了一种可能的明文编码规则。</p>
<p>明文消息 “bob, i love you. Alice” 变为 “nkn, s gktc wky. Mgsbc.” 因此，与凯撒密码一样，这看起来像乱码。单表代换密码看起来比凯撒密码更安全，因为它存在 <a href="#id3"><span class="problematic" id="id4">``</span></a>26!``（约等于 10 的 26 次方）种字母配对方式，而非仅有的 25 种。但用穷举法尝试所有 <span class="math notranslate nohighlight">\(10^26\)</span> 种配对</p>
<figure class="align-center" id="figure-8-3">
<img alt="../_images/662-0.png" src="../_images/662-0.png" />
</figure>
<p><strong>图 8.3 单表代换密码</strong></p>
<p>需要的工作量太大，不可能成为破解算法和解码消息的可行方式。然而，通过对明文语言的统计分析，例如知道英文字母 <code class="docutils literal notranslate"><span class="pre">e</span></code> 和 <code class="docutils literal notranslate"><span class="pre">t</span></code> 是最常出现的字母（分别占字母出现频率的 13% 和 9%），并知道某些二字母或三字母组合经常一起出现（如 “in”、“it”、“the”、“ion”、“ing” 等），就能相对容易地破解这种代码。如果入侵者对消息内容有所了解，那么破解就更容易了。例如，如果入侵者 Trudy 是 Bob 的妻子，并怀疑 Bob 与 Alice 有染，那么她可能会怀疑消息中出现了 “bob” 和 “alice”。如果 Trudy 确定这两个名字出现在密文中，并拿到上面的密文实例，她就可以立即确定 26 个字母配对中的 7 个，从而使穷举法减少 <span class="math notranslate nohighlight">\(10^9\)</span> 种组合。事实上，如果 Trudy 怀疑 Bob 有外遇，她很可能还会在消息中寻找其他敏感词。</p>
<p>在考虑 Trudy 破解 Bob 与 Alice 加密方案的难易程度时，可以根据入侵者掌握的信息区分三种不同的攻击场景：</p>
<ul class="simple">
<li><p><strong>仅密文攻击（Ciphertext-only attack）</strong>。在某些情况下，入侵者只能访问截获的密文，而对明文内容毫无把握。我们已经看到统计分析如何在 <strong>仅密文攻击</strong> 中帮助破解加密方案。</p></li>
<li><p><strong>已知明文攻击（Known-plaintext attack）</strong>。我们在上面看到，如果 Trudy 知道 “bob” 和 “alice” 出现在密文中，那么她就可以确定字母 a、l、i、c、e、b 和 o 的（明文，密文）配对。Trudy 还可能运气好地记录了所有密文传输内容，并在某张纸上找到了 Bob 写下的一次解密版本。当入侵者已知一些（明文，密文）配对时，我们称这种攻击为 <strong>已知明文攻击</strong>。</p></li>
<li><p><strong>选择明文攻击（Chosen-plaintext attack）</strong>。在 <strong>选择明文攻击</strong> 中，入侵者能够选择明文消息，并获得其对应的密文形式。对于我们目前看到的这些简单加密算法来说，如果 Trudy 能让 Alice 发送消息 “The quick brown fox jumps over the lazy dog”，她就能完全破解该加密方案。我们很快会看到，对于更复杂的加密技术，选择明文攻击并不一定意味着该加密技术能够被破解。</p></li>
</ul>
<p>大约五百年前，出现了一种对单表代换加密进行改进的技术，称为 <strong>多表代换加密（polyalphabetic encryption）</strong>。多表加密的思想是使用多个单表代换密码，并针对明文消息中某个特定位置的字母使用特定的单表代换密码进行编码。因此，相同的字母在明文消息中出现在不同位置时，其编码可能不同。<span class="xref std std-ref">图 8.4</span> 展示了一个多表加密方案的例子。它使用了两个凯撒密码（ <code class="docutils literal notranslate"><span class="pre">k=5</span></code> 和 <code class="docutils literal notranslate"><span class="pre">k=19</span></code>），分别显示为两行。我们可以选择按重复模式 <code class="docutils literal notranslate"><span class="pre">C1</span></code>、 <code class="docutils literal notranslate"><span class="pre">C2</span></code>、 <code class="docutils literal notranslate"><span class="pre">C2</span></code>、 <code class="docutils literal notranslate"><span class="pre">C1</span></code>、<code class="docutils literal notranslate"><span class="pre">C2</span></code> 使用这两个凯撒密码 <code class="docutils literal notranslate"><span class="pre">C1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">C2</span></code>。即，第一位明文字母使用 <code class="docutils literal notranslate"><span class="pre">C1</span></code> 编码，第二和第三位使用 <code class="docutils literal notranslate"><span class="pre">C2</span></code>，第四位使用 <code class="docutils literal notranslate"><span class="pre">C1</span></code>，第五位使用 <code class="docutils literal notranslate"><span class="pre">C2</span></code>，接下来重复此模式，第六位使用 <code class="docutils literal notranslate"><span class="pre">C1</span></code>，第七位使用 <code class="docutils literal notranslate"><span class="pre">C2</span></code>，以此类推。明文消息 “bob, i love you.” 加密后变为 “ghu, n etox dhz.” 注意，明文中第一个 <code class="docutils literal notranslate"><span class="pre">b</span></code> 使用 <code class="docutils literal notranslate"><span class="pre">C1</span></code> 加密，而第二个 <code class="docutils literal notranslate"><span class="pre">b</span></code> 使用 <code class="docutils literal notranslate"><span class="pre">C2</span></code> 加密。在本例中，加密和解密的“密钥”就是两个凯撒密钥（ <code class="docutils literal notranslate"><span class="pre">k=5</span></code>， <code class="docutils literal notranslate"><span class="pre">k=19</span></code>）和模式 <code class="docutils literal notranslate"><span class="pre">C1</span></code>、 <code class="docutils literal notranslate"><span class="pre">C2</span></code>、 <code class="docutils literal notranslate"><span class="pre">C2</span></code>、 <code class="docutils literal notranslate"><span class="pre">C1</span></code>、 <code class="docutils literal notranslate"><span class="pre">C2</span></code> 的知识。</p>
<div class="toggle docutils container">
<p>All cryptographic algorithms involve substituting one thing for another, for example, taking a piece of plaintext and then computing and substituting the appropriate ciphertext to create the encrypted message. Before studying a modern key-based cryptographic system, let us first get our feet wet by studying a very old, very simple symmetric key algorithm attributed to Julius Caesar, known as the <strong>Caesar cipher</strong> (a cipher is a method for encrypting data).</p>
<p>For English text, the Caesar cipher would work by taking each letter in the plaintext message and substituting the letter that is k letters later (allowing wraparound; that is, having the letter z followed by the letter a) in the alphabet. For example if k=3, then the letter a in plaintext becomes d in ciphertext; b in plaintext becomes e in ciphertext, and so on. Here, the value of k serves as the key. As an example, the plaintext message “bob, i love you. Alice” becomes “ere, l oryh brx. dolfh” in ciphertext. While the ciphertext does indeed look like gibberish, it wouldn’t take long to break the code if you knew that the Caesar cipher was being used, as there are only 25 possible key values.</p>
<p>An improvement on the Caesar cipher is the <strong>monoalphabetic cipher</strong>, which also substitutes one letter of the alphabet with another letter of the alphabet. ­However, rather than substituting according to a regular pattern (for example, substitution with an offset of k for all letters), any letter can be substituted for any other letter, as long as each letter has a unique substitute letter, and vice versa. The substitution rule in <a class="reference internal" href="#figure-8-3"><span class="std std-ref">Figure 8.3</span></a> shows one possible rule for encoding plaintext.</p>
<p>The plaintext message “bob, i love you. Alice” becomes “nkn, s gktc wky. Mgsbc.” Thus, as in the case of the Caesar cipher, this looks like gibberish. A monoalphabetic cipher would also appear to be better than the Caesar cipher in that there are 26! (on the order of 1026) possible pairings of letters rather than 25 possible pairings. A brute-force approach of trying all 1026 possible pairings</p>
<figure class="align-center">
<img alt="../_images/662-0.png" src="../_images/662-0.png" />
</figure>
<p><strong>Figure 8.3 A monoalphabetic cipher</strong></p>
<p>would require far too much work to be a feasible way of breaking the encryption algorithm and decoding the message. However, by statistical analysis of the plaintext language, for example, knowing that the letters e and t are the most frequently occurring letters in typical English text (accounting for 13 percent and 9 percent of letter occurrences), and knowing that particular two-and three-letter occurrences of letters appear quite often together (for example, “in,” “it,” “the,” “ion,” “ing,” and so forth) make it relatively easy to break this code. If the intruder has some knowledge about the possible contents of the message, then it is even easier to break the code. For example, if Trudy the intruder is Bob’s wife and suspects Bob of having an affair with Alice, then she might suspect that the names “bob” and “alice” appear in the text. If Trudy knew for certain that those two names appeared in the ciphertext and had a copy of the example ciphertext message above, then she could immediately determine seven of the 26 letter pairings, requiring 109 fewer possibilities to be checked by a brute-force method. Indeed, if Trudy suspected Bob of having an affair, she might well expect to find some other choice words in the message as well.</p>
<p>When considering how easy it might be for Trudy to break Bob and Alice’s encryption scheme, one can distinguish three different scenarios, depending on what information the intruder has.</p>
<ul class="simple">
<li><p><strong>Ciphertext-only attack</strong>. In some cases, the intruder may have access only to the intercepted ciphertext, with no certain information about the contents of the plaintext message. We have seen how statistical analysis can help in a <strong>ciphertext-only attack</strong> on an encryption scheme.</p></li>
<li><p><strong>Known-plaintext attack</strong>. We saw above that if Trudy somehow knew for sure that “bob” and “alice” appeared in the ciphertext message, then she could have determined the (plaintext, ciphertext) pairings for the letters a, l, i, c, e, b, and o. Trudy might also have been fortunate enough to have recorded all of the ciphertext transmissions and then found Bob’s own decrypted version of one of the transmissions scribbled on a piece of paper. When an intruder knows some of the (plaintext, ciphertext) pairings, we refer to this as a <strong>known-plaintext attack</strong> on the encryption scheme.</p></li>
<li><p><strong>Chosen-plaintext attack</strong>. In a <strong>chosen-plaintext attack</strong>, the intruder is able to choose the plaintext message and obtain its corresponding ciphertext form. For the simple encryption algorithms we’ve seen so far, if Trudy could get Alice to send the message, “The quick brown fox jumps over the lazy dog,” she could completely break the encryption scheme. We’ll see shortly that for more sophisticated encryption techniques, a chosen-plaintext attack does not necessarily mean that the encryption technique can be broken.</p></li>
</ul>
<p>Five hundred years ago, techniques improving on monoalphabetic encryption, known as <strong>polyalphabetic encryption</strong>, were invented. The idea behind polyalphabetic encryption is to use multiple monoalphabetic ciphers, with a specific</p>
<figure class="align-center">
<img alt="../_images/663-0.png" src="../_images/663-0.png" />
</figure>
<p><strong>Figure 8.4 A monoalphabetic cipher</strong></p>
<p>monoalphabetic cipher to encode a letter in a specific position in the plaintext message. Thus, the same letter, appearing in different positions in the plaintext message, might be encoded differently. An example of a polyalphabetic encryption scheme is shown in <span class="xref std std-ref">Figure 8.4</span>. It has two Caesar ciphers (with k=5 and k=19), shown as rows. We might choose to use these two Caesar ciphers, C1 and C2, in the repeating pattern C1, C2, C2, C1, C2. That is, the first letter of plaintext is to be encoded using C1, the second and third using C2, the fourth using C1, and the fifth using C2. The pattern then repeats, with the sixth letter being encoded using C1, the seventh with C2, and so on. The plaintext message “bob, i love you.” is thus encrypted “ghu, n etox dhz.” Note that the first b in the plaintext message is encrypted using C1, while the second b is encrypted using C2. In this example, the encryption and decryption “key” is the knowledge of the two Caesar keys (k=5, k=19) and the pattern C1, C2, C2, C1, C2.</p>
</div>
<section id="id5">
<h3>块加密<a class="headerlink" href="#id5" title="此标题的永久链接">#</a></h3>
<p>Block Ciphers</p>
<p>现在我们进入现代，看看当前对称密钥加密是如何进行的。对称加密技术大致可分为两类： <strong>流密码（stream ciphers）</strong> 和 <strong>块密码（block ciphers）</strong>。我们将在 <a class="reference internal" href="s7.html#c8-7"><span class="std std-ref">第 8.7 节</span></a> 简要介绍流密码，在研究无线局域网的安全性时使用它们。本节我们专注于块密码，它被用于许多安全的 Internet 协议中，包括 PGP（用于安全电子邮件）、SSL（用于保护 TCP 连接）和 IPsec（用于保护网络层传输）。</p>
<p>在块密码中，要加密的消息以 k 位为单位的块进行处理。例如，如果 <code class="docutils literal notranslate"><span class="pre">k=64</span></code>，则消息被划分为若干 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位块，每个块被单独加密。为了对一个块编码，密码算法使用一对一映射将 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位明文块映射到 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位密文块。我们来看一个例子。假设 <code class="docutils literal notranslate"><span class="pre">k=3</span></code>，则该块密码将 <code class="docutils literal notranslate"><span class="pre">3</span></code> 位输入（明文）映射为 <code class="docutils literal notranslate"><span class="pre">3</span></code> 位输出（密文）。<a class="reference internal" href="#table-8-1"><span class="std std-ref">表 8.1</span></a> 给出了一个可能的映射。请注意，这是一种一对一映射；即每个输入都有不同的输出。该块密码将消息分解为 <code class="docutils literal notranslate"><span class="pre">3</span></code> 位块，并根据上述映射加密每个块。你应该验证消息 <code class="docutils literal notranslate"><span class="pre">010110001111</span></code> 被加密为 <code class="docutils literal notranslate"><span class="pre">101000111001</span></code>。</p>
<p>继续这个 <code class="docutils literal notranslate"><span class="pre">3</span></code> 位块的例子，注意 <a class="reference internal" href="#table-8-1"><span class="std std-ref">表 8.1</span></a> 中的映射只是众多可能映射中的一种。那么，有多少种可能的映射呢？为了回答这个问题，观察到映射不过是所有可能输入的排列。共有 <code class="docutils literal notranslate"><span class="pre">2^3(=8)</span></code> 个可能输入（列于输入列下方）。这八个输入可以以 <code class="docutils literal notranslate"><span class="pre">8!</span> <span class="pre">=</span> <span class="pre">40,320</span></code> 种不同方式排列。由于每种排列定义一个映射，因此存在 <code class="docutils literal notranslate"><span class="pre">40,320</span></code> 个可能的映射。我们可以将每个映射看作一个密钥——如果 Alice 和 Bob 都知道该映射（即密钥），他们就能对彼此间发送的消息进行加密和解密。</p>
<p id="table-8-1"><strong>表 8.1 一个具体的 3 位块密码</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>输入</p></td>
<td><p>输出</p></td>
<td><p>输入</p></td>
<td><p>输出</p></td>
</tr>
<tr class="row-even"><td><p>000</p></td>
<td><p>110</p></td>
<td><p>100</p></td>
<td><p>011</p></td>
</tr>
<tr class="row-odd"><td><p>001</p></td>
<td><p>111</p></td>
<td><p>101</p></td>
<td><p>010</p></td>
</tr>
<tr class="row-even"><td><p>010</p></td>
<td><p>101</p></td>
<td><p>110</p></td>
<td><p>000</p></td>
</tr>
<tr class="row-odd"><td><p>011</p></td>
<td><p>100</p></td>
<td><p>111</p></td>
<td><p>001</p></td>
</tr>
</tbody>
</table>
</div>
<p>这种密码的暴力破解方法是尝试所有映射来解密密文。仅有 <code class="docutils literal notranslate"><span class="pre">40,320</span></code> 个映射（当 <code class="docutils literal notranslate"><span class="pre">k=3</span></code>）时，可以在一台台式机上快速完成。为防止暴力攻击，块密码通常使用更大的块，例如 <code class="docutils literal notranslate"><span class="pre">k=64</span></code> 位或更大。注意，一般 <code class="docutils literal notranslate"><span class="pre">k</span></code> 块密码的可能映射数量是 <code class="docutils literal notranslate"><span class="pre">2^k</span></code>!，即使是中等大小的 <cite>k`（如 ``k=64`</cite>），其值也大得惊人。</p>
<p>虽然上述具有中等 <code class="docutils literal notranslate"><span class="pre">k</span></code> 值的全表块密码可以提供强大的对称密钥加密方案，但它们不易实现。对于 <code class="docutils literal notranslate"><span class="pre">k=64</span></code> 和某个给定映射，Alice 和 Bob 需要维护一个包含 <code class="docutils literal notranslate"><span class="pre">2^64</span></code> 个输入值的表，这是不可行的任务。而且，如果 Alice 和 Bob 改变密钥，他们必须重新生成该表。因此，提供所有输入和输出之间预定义映射的全表块密码（如上例）是不现实的。</p>
<p>相反，块密码通常使用函数来模拟随机排列的表。<a class="reference internal" href="#figure-8-5"><span class="std std-ref">图 8.5</span></a> 展示了一个这种函数的例子（改编自 <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a>），用于 <code class="docutils literal notranslate"><span class="pre">k=64</span></code> 位。该函数首先将一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位块分解为 <code class="docutils literal notranslate"><span class="pre">8</span></code> 个 <code class="docutils literal notranslate"><span class="pre">8</span></code> 位小块。每个 <code class="docutils literal notranslate"><span class="pre">8</span></code> 位小块通过一个 <code class="docutils literal notranslate"><span class="pre">8</span></code> 位到 <code class="docutils literal notranslate"><span class="pre">8</span></code> 位的表处理，该表尺寸是可管理的。例如，第一个小块由表 <code class="docutils literal notranslate"><span class="pre">T1</span></code> 处理。然后，将这 <code class="docutils literal notranslate"><span class="pre">8</span></code> 个输出小块重新组装为一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位块。接着对该块中的 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位进行扰乱（排列），以生成一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位输出。该输出再反馈到 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位输入中，开始另一个循环。经过 <code class="docutils literal notranslate"><span class="pre">n</span></code> 次循环后，该函数生成一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位的密文块。多个轮次的目的是让每个输入位影响大多数（甚至全部）输出位。（如果仅使用一轮，某个输入位只会影响 <code class="docutils literal notranslate"><span class="pre">64</span></code> 个输出位中的 <code class="docutils literal notranslate"><span class="pre">8</span></code> 个。）此块密码算法的密钥为这八个置换表（假设扰乱函数是公开的）。</p>
<figure class="align-center" id="figure-8-5">
<img alt="img/685-0.png" src="img/685-0.png" />
</figure>
<p><strong>图 8.5 块密码示例</strong></p>
<p>目前存在多个流行的块密码标准，包括 DES（数据加密标准）、3DES 和 AES（高级加密标准）。这些标准都使用类似于 <a class="reference internal" href="#figure-8-5"><span class="std std-ref">图 8.5</span></a> 中的函数（虽然更复杂、且每种密码具体不同），而不是预定义的表。它们也都使用一串比特作为密钥。例如，DES 使用 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位块和 <code class="docutils literal notranslate"><span class="pre">56</span></code> 位密钥。AES 使用 <code class="docutils literal notranslate"><span class="pre">128</span></code> 位块，密钥长度可以是 <code class="docutils literal notranslate"><span class="pre">128</span></code>、 <code class="docutils literal notranslate"><span class="pre">192</span></code> 或 <code class="docutils literal notranslate"><span class="pre">256</span></code> 位。一个算法的密钥决定了算法内部“微型表”的映射和置换。破解这些密码的暴力攻击方法是遍历所有可能的密钥，并使用每个密钥运行解密算法。注意，密钥长度为 <code class="docutils literal notranslate"><span class="pre">n</span></code> 时，存在 <code class="docutils literal notranslate"><span class="pre">2^n</span></code> 个可能密钥。 NIST <a class="reference internal" href="../references.html#nist-2001"><span class="std std-ref">[NIST 2001]</span></a> 估算：一台能在 1 秒内破解 56 位 DES（即尝试所有 <code class="docutils literal notranslate"><span class="pre">2^56</span></code> 个密钥）的机器，破解一个 <code class="docutils literal notranslate"><span class="pre">128</span></code> 位 AES 密钥大约需要 149 万亿年。</p>
<div class="toggle docutils container">
<p>Let us now move forward to modern times and examine how symmetric key encryption is done today. There are two broad classes of symmetric encryption techniques: <strong>stream ciphers</strong> and <strong>block ciphers</strong>. We’ll briefly examine stream ciphers in <a class="reference internal" href="s7.html#c8-7"><span class="std std-ref">­Section 8.7</span></a> when we investigate security for wireless LANs. In this section, we focus on block ciphers, which are used in many secure Internet protocols, including PGP (for secure e-mail), SSL (for securing TCP connections), and IPsec (for securing the network-layer transport).</p>
<p>In a block cipher, the message to be encrypted is processed in blocks of k bits. For example, if k=64, then the message is broken into 64-bit blocks, and each block is encrypted independently. To encode a block, the cipher uses a one-to-one mapping to map the k-bit block of cleartext to a k-bit block of ciphertext. Let’s look at an example. Suppose that k=3, so that the block cipher maps 3-bit inputs (cleartext) to 3-bit outputs (ciphertext). One possible mapping is given in <a class="reference internal" href="#table-8-1"><span class="std std-ref">Table 8.1</span></a>. Notice that this is a one-to-one mapping; that is, there is a different output for each input. This block cipher breaks the message up into 3-bit blocks and encrypts each block according to the above mapping. You should verify that the message 010110001111 gets encrypted into 101000111001.</p>
<p>Continuing with this 3-bit block example, note that the mapping in <a class="reference internal" href="#table-8-1"><span class="std std-ref">Table 8.1</span></a> is just one mapping of many possible mappings. How many possible mappings are there? To answer this question, observe that a mapping is nothing more than a permutation of all the possible inputs. There are 23(=8) possible inputs (listed under the input columns). These eight inputs can be permuted in 8!=40,320 different ways. Since each of these permutations specifies a mapping, there are 40,320 possible mappings. We can view each of these mappings as a key—if Alice and Bob both know the mapping (the key), they can encrypt and decrypt the messages sent between them.</p>
<p><strong>Table 8.1 A specific 3-bit block cipher</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>input</p></td>
<td><p>output</p></td>
<td><p>input</p></td>
<td><p>output</p></td>
</tr>
<tr class="row-even"><td><p>000</p></td>
<td><p>110</p></td>
<td><p>100</p></td>
<td><p>011</p></td>
</tr>
<tr class="row-odd"><td><p>001</p></td>
<td><p>111</p></td>
<td><p>101</p></td>
<td><p>010</p></td>
</tr>
<tr class="row-even"><td><p>010</p></td>
<td><p>101</p></td>
<td><p>110</p></td>
<td><p>000</p></td>
</tr>
<tr class="row-odd"><td><p>011</p></td>
<td><p>100</p></td>
<td><p>111</p></td>
<td><p>001</p></td>
</tr>
</tbody>
</table>
</div>
<p>The brute-force attack for this cipher is to try to decrypt ciphtertext by using all mappings. With only 40,320 mappings (when k=3), this can quickly be accomplished on a desktop PC. To thwart brute-force attacks, block ciphers typically use much larger blocks, consisting of k=64 bits or even larger. Note that the number of possible mappings for a general k-block cipher is 2k!, which is astronomical for even moderate values of k (such as k=64).</p>
<p>Although full-table block ciphers, as just described, with moderate values of k can produce robust symmetric key encryption schemes, they are unfortunately difficult to implement. For k=64 and for a given mapping, Alice and Bob would need to maintain a table with 264 input values, which is an infeasible task. Moreover, if Alice and Bob were to change keys, they would have to each regenerate the table. Thus, a full-table block cipher, providing predetermined mappings between all inputs and outputs (as in the example above), is simply out of the question.</p>
<p>Instead, block ciphers typically use functions that simulate randomly permuted tables. An example (adapted from <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a>) of such a function for k=64 bits is shown in <a class="reference internal" href="#figure-8-5"><span class="std std-ref">Figure 8.5</span></a>. The function first breaks a 64-bit block into 8 chunks, with each chunk consisting of 8 bits. Each 8-bit chunk is processed by an 8-bit to 8-bit table, which is of manageable size. For example, the first chunk is processed by the table denoted by T1. Next, the 8 output chunks are reassembled into a 64-bit block. The positions of the 64 bits in the block are then scrambled (permuted) to produce a 64-bit output. This output is fed back to the 64-bit input, where another cycle begins. After n such cycles, the function provides a 64-bit block of ciphertext. The purpose of the rounds is to make each input bit affect most (if not all) of the final output bits. (If only one round were used, a given input bit would affect only 8 of the 64 output bits.) The key for this block cipher algorithm would be the eight permutation tables (assuming the scramble function is publicly known).</p>
<figure class="align-center">
<img alt="img/685-0.png" src="img/685-0.png" />
</figure>
<p><strong>Figure 8.5 An example of a block cipher</strong></p>
<p>Today there are a number of popular block ciphers, including DES (standing for Data Encryption Standard), 3DES, and AES (standing for Advanced Encryption Standard). Each of these standards uses functions, rather than predetermined tables, along the lines of <a class="reference internal" href="#figure-8-5"><span class="std std-ref">Figure 8.5</span></a> (albeit more complicated and specific to each cipher). Each of these algorithms also uses a string of bits for a key. For example, DES uses 64-bit blocks with a 56-bit key. AES uses 128-bit blocks and can operate with keys that are 128, 192, and 256 bits long. An algorithm’s key determines the specific “mini-table” mappings and permutations within the algorithm’s internals. The brute-force attack for each of these ciphers is to cycle through all the keys, applying the decryption algorithm with each key. Observe that with a key length of n, there are 2n possible keys. NIST <a class="reference internal" href="../references.html#nist-2001"><span class="std std-ref">[NIST 2001]</span></a> estimates that a machine that could crack 56-bit DES in one second (that is, try all 256 keys in one second) would take approximately 149 trillion years to crack a 128-bit AES key.</p>
</div>
</section>
<section id="cbc">
<h3>密码块链接（CBC）<a class="headerlink" href="#cbc" title="此标题的永久链接">#</a></h3>
<p>Cipher-Block Chaining</p>
<p>在计算机网络应用中，我们通常需要加密长消息（或长数据流）。如果我们直接按上述方法将消息分割为 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位块并独立加密每个块，会出现一个微妙但重要的问题。注意，两个或多个明文块可能是相同的。例如，多个块的明文可能是 “HTTP/1.1”。对于这些相同的块，块密码当然会产生相同的密文。攻击者可能会在看到相同的密文块时猜测明文，并甚至通过识别相同的密文块并利用底层协议结构知识来解密整个消息 <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a>。</p>
<p>为了解决这个问题，我们可以在密文中引入一些随机性，使得相同的明文块生成不同的密文块。为解释这个想法，令 <code class="docutils literal notranslate"><span class="pre">m(i)</span></code> 表示第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 个明文块， <code class="docutils literal notranslate"><span class="pre">c(i)</span></code> 表示第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 个密文块， <code class="docutils literal notranslate"><span class="pre">a⊕b</span></code> 表示两个比特串 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的异或运算。（回忆： <code class="docutils literal notranslate"><span class="pre">0⊕0=1⊕1=0</span></code>， <code class="docutils literal notranslate"><span class="pre">0⊕1=1⊕0=1</span></code>，异或按位执行。例如， <code class="docutils literal notranslate"><span class="pre">10101010⊕11110000=01011010</span></code>。）还令密钥为 <code class="docutils literal notranslate"><span class="pre">S</span></code> 的块密码算法记为 <code class="docutils literal notranslate"><span class="pre">KS</span></code>。基本思想如下。发送方为第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 个块生成一个随机的 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位数 <code class="docutils literal notranslate"><span class="pre">r(i)</span></code>，然后计算 <code class="docutils literal notranslate"><span class="pre">c(i)=KS(m(i)⊕r(i))</span></code>。注意，每个块使用一个新的 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位随机数。然后发送方发送 <code class="docutils literal notranslate"><span class="pre">c(1)、r(1)、c(2)、r(2)、c(3)、r(3)</span></code>，依此类推。由于接收方接收到 <code class="docutils literal notranslate"><span class="pre">c(i)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r(i)</span></code>，它可以通过计算 <code class="docutils literal notranslate"><span class="pre">m(i)=KS(c(i))⊕r(i)</span></code> 来恢复每个明文块。重要的是，虽然 <code class="docutils literal notranslate"><span class="pre">r(i)</span></code> 是明文发送的，因此 Trudy 可以监听，但她无法获取明文 <code class="docutils literal notranslate"><span class="pre">m(i)</span></code>，因为她不知道密钥 <code class="docutils literal notranslate"><span class="pre">KS</span></code>。此外，若两个明文块 <code class="docutils literal notranslate"><span class="pre">m(i)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">m(j)</span></code> 相同，只要 <code class="docutils literal notranslate"><span class="pre">r(i)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r(j)</span></code> 不同（几乎总是如此），对应的密文块 <code class="docutils literal notranslate"><span class="pre">c(i)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">c(j)</span></code> 也将不同。</p>
<p>例如，考虑 <a class="reference internal" href="#table-8-1"><span class="std std-ref">表 8.1</span></a> 中的 <code class="docutils literal notranslate"><span class="pre">3</span></code> 位块密码。假设明文为 <code class="docutils literal notranslate"><span class="pre">010010010</span></code>。如果 Alice 直接加密而不引入随机性，密文为 <code class="docutils literal notranslate"><span class="pre">101101101</span></code>。如果 Trudy 监听此密文，由于三个密文块相同，她可以正确猜出三个明文块也相同。现在假设 Alice 生成随机块 <code class="docutils literal notranslate"><span class="pre">r(1)=001</span></code>、 <code class="docutils literal notranslate"><span class="pre">r(2)=111</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r(3)=100</span></code>，并使用上述技术生成密文 <code class="docutils literal notranslate"><span class="pre">c(1)=100</span></code>、 <code class="docutils literal notranslate"><span class="pre">c(2)=010</span></code> 和 <code class="docutils literal notranslate"><span class="pre">c(3)=000</span></code>。注意，尽管明文块相同，但三个密文块不同。然后 Alice 发送 <code class="docutils literal notranslate"><span class="pre">c(1)、r(1)、c(2)、r(2)</span></code>。你应验证 Bob 可使用共享密钥 <code class="docutils literal notranslate"><span class="pre">KS</span></code> 恢复原始明文。</p>
<p>敏锐的读者会注意到，引入随机性解决了一个问题却引入了另一个问题：即 Alice 现在必须传输两倍的数据。确实，每个密文比特都必须额外发送一个随机比特，从而带宽需求加倍。为了鱼与熊掌兼得，块密码通常使用一种称为 <strong>密码块链接（Cipher Block Chaining，CBC）</strong> 的技术。其基本思想是只在第一条消息中发送一个随机值，然后发送方与接收方使用计算出的密文块代替后续的随机数。具体而言，CBC 的操作如下：</p>
<ol class="arabic simple">
<li><p>在加密消息（或数据流）之前，发送方生成一个随机的 <code class="docutils literal notranslate"><span class="pre">k</span></code> 位字符串，称为初始化向量（Initialization Vector，IV）。记作 <code class="docutils literal notranslate"><span class="pre">c(0)</span></code>。发送方以明文形式将 <cite>IV</cite> 发送给接收方。</p></li>
<li><p>对于第一个块，发送方计算 <code class="docutils literal notranslate"><span class="pre">m(1)⊕c(0)</span></code>，即将明文第一块与 IV 做异或运算。然后将结果输入块加密算法，得到相应的密文块，即 <code class="docutils literal notranslate"><span class="pre">c(1)=KS(m(1)⊕c(0))</span></code>。发送方将加密后的块 <code class="docutils literal notranslate"><span class="pre">c(1)</span></code> 发送给接收方。</p></li>
<li><p>对于第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 个块，发送方使用 <code class="docutils literal notranslate"><span class="pre">c(i)=KS(m(i)⊕c(i-1))</span></code> 生成第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 个密文块。</p></li>
</ol>
<p>现在让我们来看看这种方法的一些后果。首先，接收方仍然能够恢复原始消息。确实，当接收方收到 <code class="docutils literal notranslate"><span class="pre">c(i)</span></code> 时，它使用 KS 解密，得到 <code class="docutils literal notranslate"><span class="pre">s(i)=m(i)⊕c(i-1)</span></code>；由于接收方也知道 <code class="docutils literal notranslate"><span class="pre">c(i-1)</span></code>，因此可以通过 <code class="docutils literal notranslate"><span class="pre">m(i)=s(i)⊕c(i-1)</span></code> 得到明文块。其次，即使两个明文块相同，对应的密文块几乎总是不同。第三，虽然发送方以明文发送 IV，入侵者仍然无法解密密文块，因为入侵者不知道密钥 <code class="docutils literal notranslate"><span class="pre">S</span></code>。最后，发送方只需发送一个附加块（即 IV），因此对于包含数百个块的长消息来说，带宽开销几乎可以忽略不计。</p>
<p>例如，让我们使用 <a class="reference internal" href="#table-8-1"><span class="std std-ref">表 8.1</span></a> 中的 <code class="docutils literal notranslate"><span class="pre">3</span></code> 位块密码，明文为 <code class="docutils literal notranslate"><span class="pre">010010010</span></code>， <code class="docutils literal notranslate"><span class="pre">IV=c(0)=001</span></code>，来确定密文。发送方首先使用 IV 计算 <code class="docutils literal notranslate"><span class="pre">c(1)=KS(m(1)⊕c(0))=100</span></code>。接着计算 <code class="docutils literal notranslate"><span class="pre">c(2)=KS(m(2)⊕c(1))=KS(010⊕100)=000</span></code>， <code class="docutils literal notranslate"><span class="pre">c(3)=KS(m(3)⊕c(2))=KS(010⊕000)=101</span></code>。读者应验证，接收方知道 IV 和 KS 后可以恢复原始明文。</p>
<p>CBC 在设计安全网络协议时具有一个重要含义：我们需要在协议中提供机制，将 IV 从发送方分发给接收方。我们将在本章后续部分看到几种协议是如何实现这一点的。</p>
<div class="toggle docutils container">
<p>In computer networking applications, we typically need to encrypt long messages (or long streams of data). If we apply a block cipher as described by simply chopping up the message into k-bit blocks and independently encrypting each block, a subtle but important problem occurs. To see this, observe that two or more of the cleartext blocks can be identical. For example, the cleartext in two or more blocks could be “HTTP/1.1”. For these identical blocks, a block cipher would, of course, produce the same ciphertext. An attacker could potentially guess the cleartext when it sees identical ciphertext blocks and may even be able to decrypt the entire message by identifying identical ciphtertext blocks and using knowledge about the underlying protocol structure <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a>.</p>
<p>To address this problem, we can mix some randomness into the ciphertext so that identical plaintext blocks produce different ciphertext blocks. To explain this idea, let m(i) denote the ith plaintext block, c(i) denote the ith ciphertext block, and a⊕b denote the exclusive-or (XOR) of two bit strings, a and b. (Recall that the 0⊕0=1⊕1=0 and 0⊕1=1⊕0=1, and the XOR of two bit strings is done on a bit-by-bit basis. So, for example, 10101010⊕11110000=01011010.) Also, denote the block-cipher encryption algorithm with key S as KS. The basic idea is as follows. The sender creates a random k-bit number r(i) for the ith block and calculates c(i)=KS(m(i)⊕r(i)). Note that a new k-bit random number is chosen for each block. The sender then sends c(1), r(1), c(2), r(2), c(3), r(3), and so on. Since the receiver receives c(i) and r(i), it can recover each block of the plaintext by computing m(i)=KS(c(i))⊕r(i). It is important to note that, although r(i) is sent in the clear and thus can be sniffed by Trudy, she cannot obtain the plaintext m(i), since she does not know the key KS. Also note that if two plaintext blocks m(i) and m(j) are the same, the corresponding ciphertext blocks c(i) and c(j) will be different (as long as the random numbers r(i) and r(j) are different, which occurs with very high probability).</p>
<p>As an example, consider the 3-bit block cipher in <a class="reference internal" href="#table-8-1"><span class="std std-ref">Table 8.1</span></a>. Suppose the plaintext is 010010010. If Alice encrypts this directly, without including the randomness, the resulting ciphertext becomes 101101101. If Trudy sniffs this ciphertext, because each of the three cipher blocks is the same, she can correctly surmise that each of the three plaintext blocks are the same. Now suppose instead Alice generates the random blocks r(1)=001, r(2)=111, and r(3)=100 and uses the above technique to generate the ciphertext c(1)=100, c(2)=010, and c(3)=000. Note that the three ciphertext blocks are different even though the plaintext blocks are the same. Alice then sends c(1), r(1), c(2), and r(2). You should verify that Bob can obtain the original plaintext using the shared key KS.</p>
<p>The astute reader will note that introducing randomness solves one problem but creates another: namely, Alice must transmit twice as many bits as before. Indeed, for each cipher bit, she must now also send a random bit, doubling the required bandwidth. In order to have our cake and eat it too, block ciphers typically use a technique called <strong>Cipher Block Chaining (CBC)</strong>. The basic idea is to send only one random value along with the very first message, and then have the sender and receiver use the computed coded blocks in place of the subsequent random number. Specifically, CBC operates as follows:</p>
<ol class="arabic simple">
<li><p>Before encrypting the message (or the stream of data), the sender generates a random k-bit string, called the Initialization Vector (IV). Denote this initialization vector by c(0). The sender sends the IV to the receiver in cleartext.</p></li>
<li><p>For the first block, the sender calculates m(1)⊕c(0), that is, calculates the exclusive-or of the first block of cleartext with the IV. It then runs the result through the block-cipher algorithm to get the corresponding ciphertext block; that is, c(1)=KS(m(1)⊕c(0)). The sender sends the encrypted block c(1) to the receiver.</p></li>
<li><p>For the ith block, the sender generates the ith ciphertext block from c(i)= KS(m(i)⊕c(i-1)).</p></li>
</ol>
<p>Let’s now examine some of the consequences of this approach. First, the receiver will still be able to
recover the original message. Indeed, when the receiver receives c(i), it decrypts it with KS to obtain s(i)=m(i)⊕c(i-1); since the receiver also knows c(i-1), it then obtains the cleartext block from m(i)=s(i)⊕c(i-1). Second, even if two cleartext blocks are identical, the corresponding ciphtertexts (almost always) will be different. Third, although the sender sends the IV in the clear, an intruder will still not be able to decrypt the ciphertext blocks, since the intruder does not know the secret key, S. Finally, the sender only sends one overhead block (the IV), thereby negligibly increasing the bandwidth usage for long messages (consisting of hundreds of blocks).</p>
<p>As an example, let’s now determine the ciphertext for the 3-bit block cipher in <a class="reference internal" href="#table-8-1"><span class="std std-ref">Table 8.1</span></a> with plaintext 010010010 and IV=c(0)=001. The sender first uses the IV to calculate c(1)=KS(m(1)⊕c(0))=100. The sender then calculates c(2)= KS(m(2)⊕c(1))=KS(010⊕100)=000, and C(3)=KS(m(3)⊕c(2))=KS(010⊕000)=101. The reader should verify that the receiver, knowing the IV and KS can recover the original plaintext.</p>
<p>CBC has an important consequence when designing secure network protocols: we’ll need to provide a mechanism within the protocol to distribute the IV from sender to receiver. We’ll see how this is done for several protocols later in this chapter.</p>
</div>
</section>
</section>
<section id="c8-2-2">
<span id="id6"></span><h2>8.2.2 公钥加密 6048.3 消息完整性与数字签名<a class="headerlink" href="#c8-2-2" title="此标题的永久链接">#</a></h2>
<p>8.2.2 Public Key Encryption 6048.3 Message Integrity and Digital Signatures</p>
<p>在长达两千多年的时间里（从凯撒密码时代直到 20 世纪 70 年代），加密通信都要求通信双方共享一个共同的秘密 —— 用于加密和解密的对称密钥。这种方法的一个难点是通信双方必须以某种方式达成对共享密钥的共识；但要做到这一点本身就需要（被认为是安全的）通信！或许双方可以先面对面会面达成密钥协议（例如，两个凯撒的百夫长可能在罗马浴场见面），此后再进行加密通信。然而，在网络化的世界中，通信双方可能永远不会见面，甚至无法通过除网络外的任何方式交流。那么，是否可能在没有事先已知共享密钥的情况下，仍能进行加密通信？1976 年，Diffie 和 Hellman <a class="reference internal" href="../references.html#diffie-1976"><span class="std std-ref">[Diffie 1976]</span></a> 提出了一种算法（现在称为 Diffie-Hellman 密钥交换）来实现这一目标 —— 这是一个完全不同且极其优雅的方法，开创了今天公钥密码系统的发展。不久后我们将看到，公钥密码系统还有几个极其出色的特性，使其不仅适用于加密，还适用于身份验证与数字签名。有趣的是，最近有资料显示，与 <a class="reference internal" href="../references.html#diffie-1976"><span class="std std-ref">[Diffie 1976]</span></a> 和 <a class="reference internal" href="../references.html#rsa-1978"><span class="std std-ref">[RSA 1978]</span></a> 中的思想相似的概念，早在 1970 年代初期，英国通信电子安全小组的研究人员就已经在一系列秘密报告中独立提出 [Ellis 1987]。正如常见的情况一样，伟大的想法往往会在不同地方独立诞生；幸运的是，公钥密码的突破不仅出现在私下，也得以在公众视野中发展。</p>
<figure class="align-center">
<img alt="../_images/668-0.png" src="../_images/668-0.png" />
</figure>
<p id="figure-8-6"><strong>图 8.6 公钥密码学</strong></p>
<p>公钥密码的使用在概念上相当简单。假设 Alice 想与 Bob 通信。如 <a class="reference internal" href="#figure-8-6"><span class="std std-ref">图 8.6</span></a> 所示，不同于对称密钥系统中 Bob 和 Alice 共享一个秘密密钥的方式，Bob（Alice 消息的接收者）拥有两个密钥 —— 一个 <strong>公钥</strong>，它对全世界都是公开的（包括入侵者 Trudy），以及一个仅 Bob 自己知道的 <strong>私钥</strong>。我们将分别用 <span class="math notranslate nohighlight">\(K_B^+\)</span> 和 <span class="math notranslate nohighlight">\(K_B^-\)</span> 表示 Bob 的公钥和私钥。为了与 Bob 通信，Alice 首先获取 Bob 的公钥。然后 Alice 使用 Bob 的公钥和一个已知的（例如标准化的）加密算法将消息 m 加密发送给 Bob；也就是说，Alice 计算 <span class="math notranslate nohighlight">\(K_B^+(m)\)</span>。Bob 收到 Alice 加密的消息后，使用他的私钥和一个已知的（例如标准化的）解密算法解密该加密消息。也就是说，Bob 计算 <span class="math notranslate nohighlight">\(K_B^-(K_B^+(m))\)</span>。我们将在下文看到，存在这样的加密/解密算法以及公私钥选择方法，使得 <span class="math notranslate nohighlight">\(K_B^-(K_B^+(m))=m\)</span> ；也就是说，对消息 m 应用 Bob 的公钥 <span class="math notranslate nohighlight">\(K_B^+\)</span> （得到 <span class="math notranslate nohighlight">\(K_B^+(m)\)</span> ），再应用 Bob 的私钥 <span class="math notranslate nohighlight">\(K_B^-\)</span> （即计算 <span class="math notranslate nohighlight">\(K_B^-(K_B^+(m)）\)</span> ）可以还原出 <code class="docutils literal notranslate"><span class="pre">m</span></code>。这是一个惊人的结果！通过这种方式，Alice 可以使用 Bob 公开可得的公钥向 Bob 发送秘密消息，而无需两人之间分发任何秘密密钥！我们很快将看到，可以交换公钥和私钥的加密操作，依然能得到同样惊人的结果 —— 即 <span class="math notranslate nohighlight">\(K_B^-(K_B^+(m)) = K_B^+(K_B^-(m)) = m\)</span> 。</p>
<p>因此，公钥加密在概念上是简单的。但人们也许会立刻想到两个问题。第一个担忧是，尽管入侵者拦截了 Alice 的加密消息只能看到乱码，但入侵者知道密钥（Bob 的公钥，对全世界公开）以及 Alice 用于加密的算法。Trudy 因此可以发动 <strong>选择明文攻击</strong> ，使用已知的标准加密算法和 Bob 的公钥来对任意她想选择的消息进行加密！例如，Trudy 可能尝试加密她怀疑 Alice 会发送的消息内容或部分内容。显然，如果公钥加密系统要发挥作用，密钥选择和加密/解密的实现必须确保入侵者无法（或几乎不可能）推断出 Bob 的私钥，或以其他方式解密或猜测 Alice 给 Bob 的消息。第二个担忧是，既然 Bob 的加密密钥是公开的，任何人都可以向 Bob 发送加密消息，包括 Alice 或伪装成 Alice 的人。在共享密钥方案中，发送者知道密钥本身就能隐含地确认其身份。而在公钥加密中，这种情况不复存在，因为任何人都可以使用 Bob 的公钥向他发送加密消息。我们将在 <a class="reference internal" href="s3.html#c8-3"><span class="std std-ref">第 8.3 节</span></a> 中研究一个主题 —— <strong>数字签名</strong>，它可用于将发送者与消息绑定起来。</p>
<div class="toggle docutils container">
<p>For more than 2,000 years (since the time of the Caesar cipher and up to the 1970s), encrypted communication required that the two communicating parties share a common secret—the symmetric key used for encryption and decryption. One difficulty with this approach is that the two parties must somehow agree on the shared key; but to do so requires (presumably secure) communication! Perhaps the parties could first meet and agree on the key in person (for example, two of Caesar’s centurions might meet at the Roman baths) and thereafter communicate with encryption. In a networked world, however, communicating parties may never meet and may never converse except over the network. Is it possible for two parties to communicate with encryption without having a shared secret key that is known in advance? In 1976, Diffie and Hellman <a class="reference internal" href="../references.html#diffie-1976"><span class="std std-ref">[Diffie 1976]</span></a> demonstrated an algorithm (known now as Diffie-Hellman Key Exchange) to do just that—a radically different and marvelously elegant approach toward secure communication that has led to the development of today’s public key cryptography systems. We’ll see shortly that public key cryptography systems also have several wonderful properties that make them useful not only for encryption, but for authentication and digital signatures as well. Interestingly, it has recently come to light that ideas similar to those in <a class="reference internal" href="../references.html#diffie-1976"><span class="std std-ref">[Diffie 1976]</span></a> and <a class="reference internal" href="../references.html#rsa-1978"><span class="std std-ref">[RSA 1978]</span></a> had been independently developed in the early 1970s in a series of secret reports by researchers at the Communications-Electronics Security Group in the United ­Kingdom [Ellis 1987]. As is often the case, great ideas can spring up independently in many places; fortunately, public key advances took place not only in private, but also in the public view, as well.</p>
<figure class="align-center">
<img alt="../_images/668-0.png" src="../_images/668-0.png" />
</figure>
<p><strong>Figure 8.6 Public key cryptography</strong></p>
<p>The use of public key cryptography is conceptually quite simple. Suppose Alice wants to communicate with Bob. As shown in <a class="reference internal" href="#figure-8-6"><span class="std std-ref">Figure 8.6</span></a>, rather than Bob and Alice sharing a single secret key (as in the case of symmetric key systems), Bob (the recipient of Alice’s messages) instead has two keys—a <strong>public key</strong> that is available to everyone in the world (including Trudy the intruder) and a <strong>private key</strong> that is known only to Bob. We will use the notation KB+ and KB- to refer to Bob’s public and private keys, respectively. In order to communicate with Bob, Alice first fetches Bob’s public key. Alice then encrypts her message, m, to Bob using Bob’s public key and a known (for example, standardized) encryption algorithm; that is, Alice computes KB-(m). Bob receives Alice’s encrypted message and uses his private key and a known (for example, standardized) decryption algorithm to decrypt Alice’s encrypted message. That is, Bob computes KB-(KB+(m)). We will see below that there are encryption/decryption algorithms and techniques for choosing public and private keys such that KB-(KB+(m))=m; that is, applying Bob’s public key, KB+, to a message, m (to get KB-(m)), and then applying Bob’s private key, KB-, to the encrypted version of m (that is, computing KB-(KB+(m))) gives back m. This is a remarkable result! In this manner, Alice can use Bob’s publicly available key to send a secret message to Bob without either of them having to distribute any secret keys! We will see shortly that we can interchange the public key and private key encryption and get the same remarkable result––that is, KB-(B+(m))=KB+(KB-(m))=m.</p>
<p>The use of public key cryptography is thus conceptually simple. But two immediate worries may spring to mind. A first concern is that although an intruder intercepting Alice’s encrypted message will see only gibberish, the intruder knows both the key (Bob’s public key, which is available for all the world to see) and the algorithm that Alice used for encryption. Trudy can thus mount a chosen-plaintext attack, using the known standardized encryption algorithm and Bob’s publicly available encryption key to encode any message she chooses! Trudy might well try, for example, to encode messages, or parts of messages, that she suspects that Alice might send. Clearly, if public key cryptography is to work, key selection and encryption/decryption must be done in such a way that it is impossible (or at least so hard as to be nearly impossible) for an intruder to either determine Bob’s private key or somehow otherwise decrypt or guess Alice’s message to Bob. A second concern is that since Bob’s encryption key is public, anyone can send an encrypted message to Bob, including Alice or someone claiming to be Alice. In the case of a single shared secret key, the fact that the sender knows the secret key implicitly identifies the sender to the receiver. In the case of public key cryptography, however, this is no longer the case since anyone can send an encrypted message to Bob using Bob’s publicly available key. A digital signature, a topic we will study in <a class="reference internal" href="s3.html#c8-3"><span class="std std-ref">Section 8.3</span></a>, is needed to bind a sender to a message.</p>
</div>
<section id="rsa">
<h3>RSA<a class="headerlink" href="#rsa" title="此标题的永久链接">#</a></h3>
<p>虽然有很多算法可以解决上述担忧，但 <strong>RSA 算法</strong> （以其创始人 Ron Rivest、Adi Shamir 和 Leonard Adleman 命名）几乎已经成为公钥密码学的代名词。我们先看看 RSA 是如何工作的，然后再探究它为何可行。</p>
<p>RSA 广泛使用模 <code class="docutils literal notranslate"><span class="pre">n</span></code> 算术运算。因此，我们先简要回顾一下模运算。回忆一下， <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">mod</span> <span class="pre">n</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">x</span></code> 除以 <code class="docutils literal notranslate"><span class="pre">n</span></code> 后的余数；例如， <code class="docutils literal notranslate"><span class="pre">19</span> <span class="pre">mod</span> <span class="pre">5=4</span></code>。在模运算中，可以进行加法、乘法和乘方等通常的运算。然而，每次运算的结果都被替换为其除以 <code class="docutils literal notranslate"><span class="pre">n</span></code> 后的整数余数。以下是一些有用的模运算规则，可以方便加法和乘法的运算：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[(a mod n)+(b mod n)] mod n = (a+b) mod n

[(a mod n)-(b mod n)] mod n = (a-b) mod n

[(a mod n)⋅(b mod n)] mod n = (a⋅b) mod n
</pre></div>
</div>
<p>由第三条可得 <span class="math notranslate nohighlight">\((a \space \text{mod} \space n)^d \space \text{mod} \space n = a^d \space \text{mod} \space n\)</span> ，这是我们即将频繁使用的恒等式。</p>
<p>现在假设 Alice 想给 Bob 发送一条 RSA 加密的消息，如 <a class="reference internal" href="#figure-8-6"><span class="std std-ref">图 8.6</span></a> 所示。在讨论 RSA 的过程中，请牢记消息不过是一个位模式，而每个位模式都可以唯一地用一个整数（以及位模式长度）表示。例如，假设消息是位模式 <code class="docutils literal notranslate"><span class="pre">1001</span></code>；它可以用十进制整数 <code class="docutils literal notranslate"><span class="pre">9</span></code> 表示。因此，在使用 RSA 加密消息时，等价于加密表示该消息的唯一整数。</p>
<p>RSA 包含两个相关的组成部分：</p>
<ul class="simple">
<li><p>公钥和私钥的选择</p></li>
<li><p>加密与解密算法</p></li>
</ul>
<p>为了生成 RSA 公钥和私钥，Bob 执行以下步骤：</p>
<ol class="arabic simple">
<li><p>选择两个大素数 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code>。 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code> 应该多大？值越大，破解 RSA 的难度越大，但编码和解码所需的时间也越长。RSA 实验室建议 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code> 的乘积应约为 <code class="docutils literal notranslate"><span class="pre">1024</span></code> 位。关于如何寻找大素数，参见 <a class="reference internal" href="../references.html#caldwell-2012"><span class="std std-ref">[Caldwell 2012]</span></a>。</p></li>
<li><p>计算 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">pq</span></code>， <code class="docutils literal notranslate"><span class="pre">z=(p-1)(q-1)</span></code>。</p></li>
<li><p>选择一个小于 <code class="docutils literal notranslate"><span class="pre">n</span></code> 的数 <code class="docutils literal notranslate"><span class="pre">e</span></code>，它与 <code class="docutils literal notranslate"><span class="pre">z</span></code> 没有公因数（除了 <code class="docutils literal notranslate"><span class="pre">1</span></code>）。在这种情况下， <code class="docutils literal notranslate"><span class="pre">e</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z</span></code> 被称为互素。字母 <code class="docutils literal notranslate"><span class="pre">e</span></code> 用来表示该值用于加密。</p></li>
<li><p>找到一个数 <code class="docutils literal notranslate"><span class="pre">d</span></code>，使得 <code class="docutils literal notranslate"><span class="pre">ed-1</span></code> 能被 <code class="docutils literal notranslate"><span class="pre">z</span></code> 整除（即无余数）。字母 <code class="docutils literal notranslate"><span class="pre">d</span></code> 用来表示该值用于解密。换句话说，给定 <code class="docutils literal notranslate"><span class="pre">e</span></code>，选择 <code class="docutils literal notranslate"><span class="pre">d</span></code> 使得 <code class="docutils literal notranslate"><span class="pre">ed</span> <span class="pre">mod</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">1</span></code>。</p></li>
<li><p>Bob 对外公开的公钥 <span class="math notranslate nohighlight">\(K_B^+\)</span> 是数对 <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">e)</span></code>；他的私钥 <span class="math notranslate nohighlight">\(K_B^-\)</span> 是数对 <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>。</p></li>
</ol>
<p>Alice 的加密与 Bob 的解密过程如下：</p>
<ul class="simple">
<li><p>假设 Alice 想要发送一个整数 <code class="docutils literal notranslate"><span class="pre">m（m</span> <span class="pre">&lt;</span> <span class="pre">n）</span></code> 所表示的位模式给 Bob。为编码该消息，Alice 计算 <code class="docutils literal notranslate"><span class="pre">m</span></code> 的 <code class="docutils literal notranslate"><span class="pre">e</span></code> 次幂，然后取该结果除以 <code class="docutils literal notranslate"><span class="pre">n</span></code> 的余数。换句话说，Alice 明文 <code class="docutils literal notranslate"><span class="pre">m</span></code> 的密文值 <code class="docutils literal notranslate"><span class="pre">c</span></code> 为： <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">m^e</span> <span class="pre">mod</span> <span class="pre">n</span></code>。对应于密文 <code class="docutils literal notranslate"><span class="pre">c</span></code> 的位模式被发送给 Bob。</p></li>
<li><p>为了解密收到的密文 <code class="docutils literal notranslate"><span class="pre">c</span></code>，Bob 计算： <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">c^d</span> <span class="pre">mod</span> <span class="pre">n</span></code></p></li>
</ul>
<p>该操作需要使用他的私钥 <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>。</p>
<p id="table-8-2"><strong>表 8.2 Alice 的 RSA 加密，e=5，n=35</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>明文字母</p></td>
<td><p>m: 数值表示</p></td>
<td><p><span class="math notranslate nohighlight">\(m^e\)</span></p></td>
<td><p>密文 c = m^e mod n</p></td>
</tr>
<tr class="row-even"><td><p>l</p></td>
<td><p>12</p></td>
<td><p>248832</p></td>
<td><p>17</p></td>
</tr>
<tr class="row-odd"><td><p>o</p></td>
<td><p>15</p></td>
<td><p>759375</p></td>
<td><p>15</p></td>
</tr>
<tr class="row-even"><td><p>v</p></td>
<td><p>22</p></td>
<td><p>5153632</p></td>
<td><p>22</p></td>
</tr>
<tr class="row-odd"><td><p>e</p></td>
<td><p>5</p></td>
<td><p>3125</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</div>
<p>作为一个简单的 RSA 示例，假设 Bob 选择 <code class="docutils literal notranslate"><span class="pre">p=5</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q=7</span></code> （诚然，这两个数过小，安全性极差）。则 <code class="docutils literal notranslate"><span class="pre">n=35</span></code>， <code class="docutils literal notranslate"><span class="pre">z=24</span></code>。Bob 选择 <code class="docutils literal notranslate"><span class="pre">e=5</span></code>，因为 <code class="docutils literal notranslate"><span class="pre">5</span></code> 与 <code class="docutils literal notranslate"><span class="pre">24</span></code> 没有公因数。最终，Bob 选择 <code class="docutils literal notranslate"><span class="pre">d=29</span></code>，因为 <code class="docutils literal notranslate"><span class="pre">5⋅29-1</span></code> （即 <code class="docutils literal notranslate"><span class="pre">ed-1</span></code>）能被 <code class="docutils literal notranslate"><span class="pre">24</span></code> 整除。Bob 对外公开 <code class="docutils literal notranslate"><span class="pre">n=35</span></code> 和 <code class="docutils literal notranslate"><span class="pre">e=5</span></code>，并将 <code class="docutils literal notranslate"><span class="pre">d=29</span></code> 保密。已知这两个公开值，假设 Alice 现在想向 Bob 发送字母 l、o、v 和 e。将每个字母解释为 1 到 26 之间的数字（a 为 1，z 为 26），Alice 和 Bob 执行如 <a class="reference internal" href="#table-8-2"><span class="std std-ref">表 8.2</span></a> 和 <a class="reference internal" href="#table-8-3"><span class="std std-ref">表 8.3</span></a> 所示的加密和解密操作。注意，在这个示例中，我们将这四个字母各自作为独立的消息。一个更真实的示例会将这四个字母转换为其 8 位 ASCII 表示，再加密对应的 32 位位模式整数。（这种真实示例将产生过大而难以在教科书中打印的数字！）</p>
<p>鉴于 <a class="reference internal" href="#table-8-2"><span class="std std-ref">表 8.2</span></a> 和 <a class="reference internal" href="#table-8-3"><span class="std std-ref">表 8.3</span></a> 中这个“玩具”示例已经产生了极大的数字，同时我们也知道 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code> 应该是几百位长，由此引出几个关于 RSA 的实际问题。如何选择大素数？之后如何选择 <code class="docutils literal notranslate"><span class="pre">e</span></code> 和 <code class="docutils literal notranslate"><span class="pre">d</span></code>？如何对大数进行快速乘方计算？这些重要问题超出了本书的范围；请参阅 <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a> 及其参考资料以获取详细信息。</p>
<p id="table-8-3"><strong>表 8.3 Bob 的 RSA 解密，d=29，n=35</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>密文 c</p></td>
<td><p><span class="math notranslate nohighlight">\(c^d\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m = c^d mod n\)</span></p></td>
<td><p>明文字母</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>4819685721067509150915091411825223071697</p></td>
<td><p>12</p></td>
<td><p>l</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>127834039403948858939111232757568359375</p></td>
<td><p>15</p></td>
<td><p>o</p></td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p>851643319086537701956194499721106030592</p></td>
<td><p>22</p></td>
<td><p>v</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>1000000000000000000000000000000</p></td>
<td><p>5</p></td>
<td><p>e</p></td>
</tr>
</tbody>
</table>
</div>
<div class="toggle docutils container">
<p>While there may be many algorithms that address these concerns, the <strong>RSA Aalgorithm</strong> (named after its founders, Ron Rivest, Adi Shamir, and Leonard Adleman) has become almost synonymous with public key cryptography. Let’s first see how RSA works and then examine why it works.</p>
<p>RSA makes extensive use of arithmetic operations using modulo-n arithmetic. So let’s briefly review modular arithmetic. Recall that x mod n simply means the remainder of x when divided by n; so, for example, 19 mod 5=4. In modular arithmetic, one performs the usual operations of addition, multiplication, and exponentiation. However, the result of each operation is replaced by the integer remainder that is left when the result is divided by n. Adding and multiplying with modular arithmetic is facilitated with the following handy facts:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[ (a mod n)+(b mod n)]mod n=(a+b)mod n[ (a mod n)-(b mod n)]mod n=(a-b)mod n[ (a mod n)⋅(b mod n)]mod n=(a⋅b) mod n
</pre></div>
</div>
<p>It follows from the third fact that (a mod n)d n=ad mod n, which is an identity that we will soon find very useful.</p>
<p>Now suppose that Alice wants to send to Bob an RSA-encrypted message, as shown in Figure 8.6. In our discussion of RSA, let’s always keep in mind that a message is nothing but a bit pattern, and every bit pattern can be uniquely represented by an integer number (along with the length of the bit pattern). For example, suppose a message is the bit pattern 1001; this message can be represented by the decimal integer 9. Thus, when encrypting a message with RSA, it is equivalent to encrypting the unique integer number that represents the message.</p>
<p>There are two interrelated components of RSA:</p>
<ul class="simple">
<li><p>The choice of the public key and the private key</p></li>
<li><p>The encryption and decryption algorithm</p></li>
</ul>
<p>To generate the public and private RSA keys, Bob performs the following steps:</p>
<ol class="arabic simple">
<li><p>Choose two large prime numbers, p and q. How large should p and q be? The larger the values, the more difficult it is to break RSA, but the longer it takes to perform the encoding and decoding. RSA Laboratories recommends that the product of p and q be on the order of 1,024 bits. For a discussion of how to find large prime numbers, see <a class="reference internal" href="../references.html#caldwell-2012"><span class="std std-ref">[Caldwell 2012]</span></a>.</p></li>
<li><p>Compute n=pq and z=(p-1)(q-1).</p></li>
<li><p>Choose a number, e, less than n, that has no common factors (other than 1) with z. (In this case, e and z are said to be relatively prime.) The letter e is used since this value will be used in encryption.</p></li>
<li><p>Find a number, d, such that ed-1 is exactly divisible (that is, with no ­remainder) by z. The letter d is used because this value will be used in decryption. Put another way, given e, we choose d such that ed modz=1</p></li>
<li><p>The public key that Bob makes available to the world, KB+, is the pair of numbers (n, e); his private key, KB-, is the pair of numbers (n, d).</p></li>
</ol>
<p>The encryption by Alice and the decryption by Bob are done as follows:</p>
<ul class="simple">
<li><p>Suppose Alice wants to send Bob a bit pattern represented by the integer number m (with m&lt;n). To encode, Alice performs the exponentiation me, and then computes the integer remainder when me is divided by n. In other words, the encrypted value, c, of Alice’s plaintext message, m, is c=memod n The bit pattern corresponding to this ciphertext c is sent to Bob.</p></li>
<li><p>To decrypt the received ciphertext message, c, Bob computes m=cdmod n</p></li>
</ul>
<p>which requires the use of his private key (n, d).</p>
<p><strong>Table 8.2 Alice’s RSA encryption, e=5, n=35</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Plaintext Letter</p></td>
<td><p>m: numeric representation</p></td>
<td><p><span class="math notranslate nohighlight">\(m^e\)</span></p></td>
<td><p>Ciphertext c=me mod n</p></td>
</tr>
<tr class="row-even"><td><p>l</p></td>
<td><p>12</p></td>
<td><p>248832</p></td>
<td><p>17</p></td>
</tr>
<tr class="row-odd"><td><p>o</p></td>
<td><p>15</p></td>
<td><p>759375</p></td>
<td><p>15</p></td>
</tr>
<tr class="row-even"><td><p>v</p></td>
<td><p>22</p></td>
<td><p>5153632</p></td>
<td><p>22</p></td>
</tr>
<tr class="row-odd"><td><p>e</p></td>
<td><p>5</p></td>
<td><p>3125</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</div>
<p>As a simple example of RSA, suppose Bob chooses p=5 and q=7. ­(Admittedly, these values are far too small to be secure.) Then n=35 and z=24. Bob chooses e=5, since 5 and 24 have no common factors. Finally, Bob chooses d=29, since 5⋅29-1 (that is, ed-1) is exactly divisible by 24. Bob makes the two values, n=35 and e=5, public and keeps the value d=29 secret. Observing these two public values, suppose Alice now wants to send the letters l, o, v, and e to Bob. Interpreting each letter as a number between 1 and 26 (with a being 1, and z being 26), Alice and Bob perform the encryption and decryption shown in <span class="xref std std-ref">Tables 8.2</span> and <span class="xref std std-ref">8.3</span>, respectively. Note that in this example, we consider each of the four letters as a distinct message. A more realistic example would be to convert the four letters into their 8-bit ASCII representations and then encrypt the integer corresponding to the resulting 32-bit bit pattern. (Such a realistic example generates numbers that are much too long to print in a textbook!)</p>
<p>Given that the “toy” example in <span class="xref std std-ref">Tables 8.2</span> and <span class="xref std std-ref">8.3</span> has already produced some extremely large numbers, and given that we saw earlier that p and q should each be several hundred bits long, several practical issues regarding RSA come to mind. How does one choose large prime numbers? How does one then choose e and d? How does one perform exponentiation with large numbers? A discussion of these important issues is beyond the scope of this book; see <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a> and the references therein for details.</p>
<p><strong>Table 8.3  Bob’s RSA decryption, d=29, n=35</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Ciphertext c</p></td>
<td><p><span class="math notranslate nohighlight">\(c^d\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m = c^d mod n\)</span></p></td>
<td><p>Plaintext Letter</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>4819685721067509150915091411825223071697</p></td>
<td><p>12</p></td>
<td><p>l</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>127834039403948858939111232757568359375</p></td>
<td><p>15</p></td>
<td><p>o</p></td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p>851643319086537701956194499721106030592</p></td>
<td><p>22 v</p></td>
<td><p>v</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>1000000000000000000000000000000</p></td>
<td><p>5</p></td>
<td><p>e</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<section id="id7">
<h3>会话密钥<a class="headerlink" href="#id7" title="此标题的永久链接">#</a></h3>
<p>Session Keys</p>
<p>我们在此指出，RSA 所需的幂运算是一个相当耗时的过程。相比之下，DES 在软件中至少快 100 倍，在硬件中则快 1,000 到 10,000 倍 <a class="reference internal" href="../references.html#rsa-fast-2012"><span class="std std-ref">[RSA Fast 2012]</span></a>。因此，在实际应用中，RSA 通常与对称密钥密码算法结合使用。例如，如果 Alice 想要向 Bob 发送大量加密数据，她可以这样做：首先，Alice 选择一个用于加密数据本身的密钥；这个密钥被称为 <strong>会话密钥</strong>，记作 <span class="math notranslate nohighlight">\(K_S\)</span> 。由于这是他们将与对称密钥加密算法（例如 DES 或 AES）一起使用的共享密钥，Alice 必须将会话密钥告知 Bob。Alice 使用 Bob 的公钥加密会话密钥，即计算 <span class="math notranslate nohighlight">\(c = (K_S)^e \space \text{mod} \space n\)</span> 。Bob 接收到 RSA 加密的会话密钥 <code class="docutils literal notranslate"><span class="pre">c</span></code> 后，解密得到会话密钥 <span class="math notranslate nohighlight">\(K_S\)</span>。至此，Bob 已知 Alice 将用于加密数据传输的会话密钥。</p>
<div class="toggle docutils container">
<p>We note here that the exponentiation required by RSA is a rather time-consuming process. By contrast, DES is at least 100 times faster in software and between 1,000 and 10,000 times faster in hardware <a class="reference internal" href="../references.html#rsa-fast-2012"><span class="std std-ref">[RSA Fast 2012]</span></a>. As a result, RSA is often used in practice in combination with symmetric key cryptography. For example, if Alice wants to send Bob a large amount of encrypted data, she could do the following. First Alice chooses a key that will be used to encode the data itself; this key is referred to as a <strong>session key</strong>, and is denoted by KS. Alice must inform Bob of the session key, since this is the shared ­symmetric key they will use with a symmetric key cipher (e.g., with DES or AES). Alice encrypts the session key using Bob’s public key, that is, computes c=(KS)e mod n. Bob receives the RSA-encrypted session key, c, and decrypts it to obtain the session key, KS. Bob now knows the session key that Alice will use for her encrypted data transfer.</p>
</div>
</section>
<section id="id8">
<h3>RSA 为何有效？<a class="headerlink" href="#id8" title="此标题的永久链接">#</a></h3>
<p>Why Does RSA Work?</p>
<p>RSA 的加解密过程似乎相当神奇。为何在应用加密算法后再应用解密算法，就能恢复原始消息？为了理解 RSA 的原理，我们再次记 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">pq</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code> 是用于 RSA 算法中的两个大素数。</p>
<p>回忆一下，在 RSA 加密中，一个消息（可以唯一表示为一个整数） <code class="docutils literal notranslate"><span class="pre">m</span></code> 被提升到 <code class="docutils literal notranslate"><span class="pre">e</span></code> 次幂，并使用模 <code class="docutils literal notranslate"><span class="pre">n</span></code> 运算，即：</p>
<div class="math notranslate nohighlight">
\[c = m^e \space \text{mod} \space n\]</div>
<p>解密则是将该值提升到 <code class="docutils literal notranslate"><span class="pre">d</span></code> 次幂，同样使用模 <code class="docutils literal notranslate"><span class="pre">n</span></code> 运算。因此，加密步骤后接解密步骤的结果为 <code class="docutils literal notranslate"><span class="pre">(m^e</span> <span class="pre">mod</span> <span class="pre">n)^d</span> <span class="pre">mod</span> <span class="pre">n</span></code>。现在我们来看一下这个表达式的含义。如前所述，模运算的一个重要性质是 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">mod</span> <span class="pre">n)^d</span> <span class="pre">mod</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">a^d</span> <span class="pre">mod</span> <span class="pre">n</span></code>，对于任意 <code class="docutils literal notranslate"><span class="pre">a、n、d</span></code> 都成立。因此，令 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">m^e</span></code> 应用于该性质，我们有：</p>
<div class="math notranslate nohighlight">
\[(m^e \space \text{mod} \space n)^d \space \text{mod} \space n = \space m^{e⋅d} \space \text{mod} \space n\]</div>
<p>因此我们只需证明 <span class="math notranslate nohighlight">\(m^{e⋅d} \space \text{mod} \space n = m\)</span>。虽然我们试图揭开 RSA 的神秘面纱，但为证明这一点，我们需要引用一个来自数论的“神奇”定理。具体来说，该定理指出，如果 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code> 是素数， <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">pq</span></code>，且  <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">(p-1)(q-1)</span></code>，那么：<span class="math notranslate nohighlight">\(x^y \space \text{mod} \space n\)</span> 与 <span class="math notranslate nohighlight">\(x^{(y \space \text{mod} \space z)} \space \text{mod} \space n\)</span> 相等 <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a>。将该结论应用于 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span></code>,  <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">e⋅d</span></code>，我们得到：</p>
<div class="math notranslate nohighlight">
\[m^{e⋅d} \space \text{mod} \space n = m^{(e⋅d \space \text{mod} \space z)} \space \text{mod} \space n\]</div>
<p>而我们已知选择 <code class="docutils literal notranslate"><span class="pre">e</span></code> 和 <code class="docutils literal notranslate"><span class="pre">d</span></code> 满足 <code class="docutils literal notranslate"><span class="pre">e⋅d</span> <span class="pre">mod</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">1</span></code>。因此：</p>
<div class="math notranslate nohighlight">
\[m^{e⋅d} \space \text{mod} \space n = m^1 \space \text{mod} \space n \space = \space m\]</div>
<p>这正是我们想要的结果！先执行 <code class="docutils literal notranslate"><span class="pre">e</span></code> 次幂运算（即加密），然后执行 <code class="docutils literal notranslate"><span class="pre">d</span></code> 次幂运算（即解密），即可恢复原始值 <code class="docutils literal notranslate"><span class="pre">m</span></code>。更令人惊奇的是，如果我们先执行 <code class="docutils literal notranslate"><span class="pre">d</span></code> 次幂运算，然后再执行 <code class="docutils literal notranslate"><span class="pre">e</span></code> 次幂运算——即先解密再加密——我们也能得到原始值 <code class="docutils literal notranslate"><span class="pre">m</span></code>。这一奇妙结果直接源于模运算的性质：</p>
<div class="math notranslate nohighlight">
\[(m^d \space \text{mod} \space n)^e \space \text{mod} \space n = m^{(d⋅e)} \space \text{mod} \space n = m^{(e⋅d)} \space \text{mod} \space n = (m^e \space \text{mod} \space n)^d \space \text{mod} \space n\]</div>
<p>RSA 的安全性依赖于一个事实：目前尚无快速算法可将一个数（即公开值 <code class="docutils literal notranslate"><span class="pre">n</span></code>）分解为其素因数 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code>。如果知道了 <code class="docutils literal notranslate"><span class="pre">p</span></code> 和 <code class="docutils literal notranslate"><span class="pre">q</span></code>，那么给定公开值 <code class="docutils literal notranslate"><span class="pre">e</span></code>，就可以轻松计算出私钥 <code class="docutils literal notranslate"><span class="pre">d</span></code>。另一方面，目前尚不清楚是否存在快速因数分解算法，因此从这个意义上说，RSA 的安全性并非绝对保证。</p>
<p>另一个流行的公钥加密算法是 Diffie-Hellman 算法，我们将在习题中简要探讨。与 RSA 不同，Diffie-Hellman 不具备加密任意长度消息的能力；但它可以用于建立一个对称会话密钥，而该密钥随后可用于加密消息。</p>
<div class="toggle docutils container">
<p>RSA encryption/decryption appears rather magical. Why should it be that by applying the encryption algorithm and then the decryption algorithm, one recovers the original message? In order to understand why RSA works, again denote n=pq, where p and q are the large prime numbers used in the RSA algorithm.</p>
<p>Recall that, under RSA encryption, a message (uniquely represented by an ­integer), m, is exponentiated to the power e using modulo-n arithmetic, that is,</p>
<blockquote>
<div><p>c=memod n</p>
</div></blockquote>
<p>Decryption is performed by raising this value to the power d, again using modulo-n arithmetic. The result of an encryption step followed by a decryption step is thus (me mod n)d mod n. Let’s now see what we can say about this quantity. As mentioned earlier, one important property of modulo arithmetic is (a mod n)d mod n=ad mod n for any values a, n, and d. Thus, using a=me in this property, we have</p>
<blockquote>
<div><p>(memod n)dmod n=medmod n</p>
</div></blockquote>
<p>It therefore remains to show that medmod n=m. Although we’re trying to remove some of the magic about why RSA works, to establish this, we’ll need to use a rather magical result from number theory here. Specifically, we’ll need the result that says if p and q are prime, n=pq, and z=(p-1)(q-1), then <span class="math notranslate nohighlight">\(x^y\)</span> mod n is the same as <span class="math notranslate nohighlight">\(x^{(y mod z)}  mod n\)</span> <a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">[Kaufman 1995]</span></a>. Applying this result with x=m and y=ed we have</p>
<blockquote>
<div><p>medmod n=m(edmod z)mod n</p>
</div></blockquote>
<p>But remember that we have chosen e and d such that edmod z=1. This gives us</p>
<blockquote>
<div><p>medmod n=m1mod n=m</p>
</div></blockquote>
<p>which is exactly the result we are looking for! By first exponentiating to the power of e (that is, encrypting) and then exponentiating to the power of d (that is, ­decrypting), we obtain the original value, m. Even more wonderful is the fact that if we first exponentiate to the power of d and then exponentiate to the power of e—that is, we reverse the order of encryption and decryption, performing the decryption operation first and then applying the encryption operation—we also obtain the original value, m. This wonderful result follows immediately from the modular arithmetic:</p>
<blockquote>
<div><p>(mdmod n)emod n=mdemod n=medmod n=(memod n)dmod n</p>
</div></blockquote>
<p>The security of RSA relies on the fact that there are no known algorithms for quickly factoring a number, in this case the public value n, into the primes p and q. If one knew p and q, then given the public value e, one could easily compute the secret key, d. On the other hand, it is not known whether or not there exist fast algorithms for factoring a number, and in this sense, the security of RSA is not guaranteed.</p>
<p>Another popular public-key encryption algorithm is the Diffie-Hellman algorithm, which we will briefly explore in the homework problems. Diffie-Hellman is not as versatile as RSA in that it cannot be used to encrypt messages of arbitrary length; it can be used, however, to establish a symmetric session key, which is in turn used to encrypt messages.</p>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="s1.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">8.1 什么是网络安全？</p>
      </div>
    </a>
    <a class="right-next"
       href="s3.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">8.3 消息完整性和数字签名</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-2-1">8.2.1 对称密钥密码学</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">块加密</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cbc">密码块链接（CBC）</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-2-2">8.2.2 公钥加密 6048.3 消息完整性与数字签名</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rsa">RSA</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">会话密钥</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">RSA 为何有效？</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>