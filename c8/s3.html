

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>8.3 消息完整性和数字签名 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c8/s3';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="8.4 终端认证" href="s4.html" />
    <link rel="prev" title="8.2 密码学原理" href="s2.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c2/index.html">第 2 章 应用层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c2/s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s3.html">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s4.html">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s5.html">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c4/index.html">第 4 章 网络层：数据平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c4/s1.html">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c6/index.html">第 6 章 链路层与局域网（LANs）</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c6/s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s2.html">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 8 章 计算机网络中的安全</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2"><a class="reference internal" href="s2.html">8.2 密码学原理</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c9/index.html">第 9 章 多媒体网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c9/s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s2.html">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c8/s3.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>8.3 消息完整性和数字签名</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-3-1">8.3.1 加密哈希函数</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-3-2">8.3.2 消息认证码</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-3-3">8.3.3 数字签名</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">公钥认证</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="c8-3">
<span id="id1"></span><h1>8.3 消息完整性和数字签名<a class="headerlink" href="#c8-3" title="此标题的永久链接">#</a></h1>
<p>8.3 Message Integrity and Digital Signatures</p>
<p>在上一节中，我们看到加密如何用于为两个通信实体提供保密性。本节我们转向密码学中同样重要的一个主题：提供 <strong>消息完整性</strong> （也称为消息认证）。在讨论消息完整性的同时，我们还将介绍两个相关主题：数字签名和端点认证。</p>
<p>我们再次以 Alice 和 Bob 为例来定义消息完整性问题。假设 Bob 收到了一条消息（可能是加密的，也可能是明文的），他相信这条消息是 Alice 发送的。为了验证该消息的真实性，Bob 需要确认以下两点：</p>
<ol class="arabic simple">
<li><p>该消息确实来源于 Alice；</p></li>
<li><p>在传送过程中，该消息没有被篡改。</p></li>
</ol>
<p>我们将在 <a class="reference internal" href="s4.html#c8-4"><span class="std std-ref">Sections 8.4</span></a> 到 <a class="reference internal" href="s7.html#c8-7"><span class="std std-ref">8.7</span></a> 中看到，消息完整性问题几乎在所有安全网络协议中都是一个关键问题。</p>
<p>举一个具体的例子，考虑一个计算机网络使用链路状态路由算法（例如 OSPF）来确定网络中每对路由器之间的路由（见 <a class="reference internal" href="../c5/index.html#c5"><span class="std std-ref">Chapter 5</span></a>）。在链路状态算法中，每个路由器需要向网络中的所有其他路由器广播一条链路状态消息。一个路由器的链路状态消息包含其直接连接的邻居列表以及到这些邻居的直达代价。一旦某个路由器收到了所有其他路由器的链路状态消息，它就可以创建出整个网络的完整图，运行最短路径路由算法，并配置其转发表。对该路由算法的一种相对简单的攻击是，Trudy 发布伪造的链路状态消息，包含错误的链路状态信息。因此需要消息完整性机制 —— 当路由器 B 接收到来自路由器 A 的链路状态消息时，路由器 B 应该验证该消息确实是由路由器 A 创建的，并且在传输过程中没有被篡改。</p>
<p>在本节中，我们将介绍一种在许多安全网络协议中广泛使用的消息完整性技术。但在此之前，我们需要先介绍密码学中的另一个重要主题 —— 密码哈希函数。</p>
<div class="toggle docutils container">
<p>In the previous section we saw how encryption can be used to provide confidentiality to two communicating entities. In this section we turn to the equally important cryptography topic of providing <strong>message integrity</strong> (also known as message ­authentication). Along with message integrity, we will discuss two related topics in this section: digital signatures and end-point authentication.</p>
<p>We define the message integrity problem using, once again, Alice and Bob. Suppose Bob receives a message (which may be encrypted or may be in plaintext) and he believes this message was sent by Alice. To authenticate this message, Bob needs to verify:</p>
<ol class="arabic simple">
<li><p>The message indeed originated from Alice.</p></li>
<li><p>The message was not tampered with on its way to Bob.</p></li>
</ol>
<p>We’ll see in <a class="reference internal" href="s4.html#c8-4"><span class="std std-ref">Sections 8.4</span></a> through <a class="reference internal" href="s7.html#c8-7"><span class="std std-ref">8.7</span></a> that this problem of message integrity is a critical concern in just about all secure networking protocols.</p>
<p>As a specific example, consider a computer network using a link-state routing algorithm (such as OSPF) for determining routes between each pair of routers in the network (see <a class="reference internal" href="../c5/index.html#c5"><span class="std std-ref">Chapter 5</span></a>). In a link-state algorithm, each router needs to broadcast a link-state message to all other routers in the network. A router’s link-state message includes a list of its directly connected neighbors and the direct costs to these neighbors. Once a router receives link-state messages from all of the other routers, it can create a complete map of the network, run its least-cost routing algorithm, and configure its forwarding table. One relatively easy attack on the routing algorithm is for Trudy to distribute bogus link-state messages with incorrect link-state information. Thus the need for message integrity—when router B receives a link- state message from router A, router B should verify that router A actually created the message and, further, that no one tampered with the message in transit.</p>
<p>In this section, we describe a popular message integrity technique that is used by many secure networking protocols. But before doing so, we need to cover another important topic in cryptography— cryptographic hash functions.</p>
</div>
<section id="c8-3-1">
<span id="id2"></span><h2>8.3.1 加密哈希函数<a class="headerlink" href="#c8-3-1" title="此标题的永久链接">#</a></h2>
<p>8.3.1 Cryptographic Hash Functions</p>
<p>如 <span class="xref std std-ref">Figure 8.7</span> 所示，哈希函数接受一个输入 m，并计算出一个固定长度的字符串 H(m)，称为哈希值。Internet 校验和（<a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a>）和 CRC（<a class="reference internal" href="../c6/index.html#c6"><span class="std std-ref">Chapter 6</span></a>）都符合这个定义。密码哈希函数还需要满足以下附加性质：</p>
<ul class="simple">
<li><p>计算上无法找到任意两个不同的消息 x 和 y，使得 H(x)=H(y)。</p></li>
</ul>
<p>非正式地说，这个性质意味着攻击者在计算上无法通过替换另一条消息来伪造一个具有相同哈希值的消息。也就是说，如果（m, H(m)）是一条由发送方生成的消息及其哈希值，那么攻击者无法伪造另一条消息 y，使得 H(y)=H(m)。</p>
<figure class="align-center" id="figure-8-7">
<img alt="../_images/675-0.png" src="../_images/675-0.png" />
</figure>
<p><strong>图 8.7 哈希函数</strong></p>
<figure class="align-center" id="figure-8-8">
<img alt="../_images/675-1.png" src="../_images/675-1.png" />
</figure>
<p><strong>图 8.8 原始消息和伪造消息具有相同的校验和！</strong></p>
<p>让我们来验证一下，一个简单的校验和（如 Internet 校验和）为何不适合作为密码哈希函数。我们不使用一补码运算（如 Internet 校验和所用），而是将每个字符视为一个字节，并每次使用 4 字节块将这些字节相加来计算校验和。假设 Bob 欠 Alice 100.99 美元，并发送一条 IOU 消息给 Alice，内容为字符串 “IOU100.99BOB”。该字符串的 ASCII 表示（十六进制）为：49、4F、55、31、30、30、2E、39、39、42、4F、42。</p>
<p><span class="xref std std-ref">Figure 8.8</span> 的底部。消息 “IOU100.99BOB” 和 “IOU900.19BOB” 拥有相同的校验和。因此，这个简单的校验和算法违反了上述的要求。给定原始数据，很容易找出另一组具有相同校验和的数据。显然，在安全方面，我们需要比校验和更强大的哈希函数。</p>
<p>Ron Rivest 的 MD5 哈希算法 [<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>] 是目前广泛使用的算法。它以四步过程计算 128 位哈希值，这四步包括填充（添加一个 1 后跟足够的 0，以满足消息长度的特定要求）、附加（在填充前附加消息长度的 64 位表示）、初始化累加器，以及最终循环步骤，在该步骤中消息的 16 个字块在四轮中被处理（混乱变形）。有关 MD5 的描述（包括 C 源码实现）请参见 [<span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>]。</p>
<p>当前使用的第二个主要哈希算法是安全哈希算法（SHA-1）:ref:<cite>[FIPS 1995] &lt;FIPS 1995&gt;</cite>。该算法基于与其前身 MD4 [<span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1320.html"><strong>RFC 1320</strong></a>] 设计中类似的原理。SHA-1 是美国联邦标准，在联邦应用中需要使用密码哈希算法时必须采用。它生成一个 160 位的消息摘要。更长的输出长度使 SHA-1 更加安全。</p>
<div class="toggle docutils container">
<p>As shown in <span class="xref std std-ref">Figure 8.7</span>, a hash function takes an input, m, and computes a fixed-size string H(m) known as a hash. The Internet checksum (<a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a>) and CRCs (<a class="reference internal" href="../c6/index.html#c6"><span class="std std-ref">Chapter 6</span></a>) meet this definition. A cryptographic hash function is required to have the following additional property:</p>
<ul class="simple">
<li><p>It is computationally infeasible to find any two different messages x and y such that H(x)=H(y).</p></li>
</ul>
<p>Informally, this property means that it is computationally infeasible for an intruder to substitute one message for another message that is protected by the hash function. That is, if (m, H(m)) are the message and the hash of the message created by the sender, then an intruder cannot forge the contents of another message, y, that has the same hash value as the original message.</p>
<figure class="align-center">
<img alt="../_images/675-0.png" src="../_images/675-0.png" />
</figure>
<p id="id3"><strong>Figure 8.7 Hash functions</strong></p>
<figure class="align-center">
<img alt="../_images/675-1.png" src="../_images/675-1.png" />
</figure>
<p><strong>Figure 8.8 Initial message and fraudulent message have the same ­checksum!</strong></p>
<p>Let’s convince ourselves that a simple checksum, such as the Internet checksum, would make a poor cryptographic hash function. Rather than performing 1s complement arithmetic (as in the Internet checksum), let us compute a checksum by treating each character as a byte and adding the bytes together using 4-byte chunks at a time. Suppose Bob owes Alice $100.99 and sends an IOU to Alice consisting of the text string “IOU100.99BOB.” The ASCII representation (in hexadecimal notation) for these letters is 49, 4F, 55, 31, 30, 30, 2E, 39, 39, 42, 4F, 42.</p>
<p><a class="reference internal" href="#figure-8-8"><span class="std std-ref">Figure 8.8</span></a> (top) shows that the 4-byte checksum for this message is B2 C1 D2 AC. A slightly different message (and a much more costly one for Bob) is shown in the bottom half of <a class="reference internal" href="#figure-8-8"><span class="std std-ref">Figure 8.8</span></a>. The messages “IOU100.99BOB” and “IOU900.19BOB” have the same checksum. Thus, this simple checksum algorithm violates the requirement above. Given the original data, it is simple to find another set of data with the same checksum. Clearly, for security purposes, we are going to need a more powerful hash function than a checksum.</p>
<p>The MD5 hash algorithm of Ron Rivest [<span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>] is in wide use today. It computes a 128-bit hash in a four-step process consisting of a padding step (adding a one followed by enough zeros so that the length of the message satisfies certain conditions), an append step (appending a 64-bit representation of the message length before padding), an initialization of an accumulator, and a final looping step in which the message’s 16-word blocks are processed (mangled) in four rounds. For a description of MD5 (including a C source code implementation) see [<span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>].</p>
<p>The second major hash algorithm in use today is the Secure Hash Algorithm (SHA-1) <a class="reference internal" href="../references.html#fips-1995"><span class="std std-ref">[FIPS 1995]</span></a>. This algorithm is based on principles similar to those used in the design of MD4 [<span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1320.html"><strong>RFC 1320</strong></a>], the predecessor to MD5. SHA-1, a US federal standard, is required for use whenever a cryptographic hash algorithm is needed for federal applications. It produces a 160-bit message digest. The longer output length makes SHA-1 more secure.</p>
</div>
</section>
<section id="c8-3-2">
<span id="id4"></span><h2>8.3.2 消息认证码<a class="headerlink" href="#c8-3-2" title="此标题的永久链接">#</a></h2>
<p>8.3.2 Message Authentication Code</p>
<p>现在我们回到消息完整性的问题上。既然我们已经理解了哈希函数，那么我们可以初步尝试如何实现消息完整性：</p>
<ol class="arabic simple">
<li><p>Alice 创建消息 m，并计算其哈希值 H(m)（例如使用 SHA-1）。</p></li>
<li><p>然后 Alice 将 H(m) 添加到消息 m 后面，形成扩展消息 (m, H(m))，并将扩展消息发送给 Bob。</p></li>
<li><p>Bob 接收到扩展消息 (m, h) 后计算 H(m)。如果 H(m)=h，Bob 就认为一切正常。</p></li>
</ol>
<p>这种方法显然是有缺陷的。Trudy 可以伪造一条消息 ḿ，声称她是 Alice，然后计算 H(ḿ)，再将 (ḿ, H(ḿ)) 发送给 Bob。当 Bob 收到该消息时，第三步中一切看起来都没问题，因此 Bob 不会怀疑有问题。</p>
<p>为了实现消息完整性，除了使用密码哈希函数外，Alice 和 Bob 还需要共享一个秘密 s。这个共享的秘密（只是一串比特）称为 <strong>认证密钥（authentication key）</strong>。使用这个共享秘密，可以按如下方式实现消息完整性：</p>
<ol class="arabic simple">
<li><p>Alice 创建消息 m，将 s 与 m 拼接形成 m+s，并计算哈希值 H(m+s)（例如使用 SHA-1）。H(m+s) 被称为 <strong>消息认证码（message authentication code, MAC）</strong>。</p></li>
<li><p>然后 Alice 将 MAC 添加到消息 m 后面，形成扩展消息 (m, H(m+s))，并将扩展消息发送给 Bob。</p></li>
<li><p>Bob 接收到扩展消息 (m, h) 后，知道 s，于是计算 MAC 值 H(m+s)。如果 H(m+s)=h，Bob 就认为一切正常。</p></li>
</ol>
<p>该过程的总结如 <a class="reference internal" href="#figure-8-9"><span class="std std-ref">Figure 8.9</span></a> 所示。读者应注意，这里的 MAC（意为“消息认证码”）不同于链路层协议中所使用的 MAC（意为“媒体访问控制”）！</p>
<figure class="align-center" id="figure-8-9">
<img alt="../_images/677-0.png" src="../_images/677-0.png" />
</figure>
<p><strong>图 8.9 消息认证码（MAC）</strong></p>
<p>MAC 的一个好处是它不需要加密算法。事实上，在许多应用中，包括前面提到的链路状态路由算法，通信实体只关心消息的完整性，而不关心消息的保密性。使用 MAC，通信双方可以在不将复杂的加密算法集成到完整性过程中的情况下，对彼此发送的消息进行认证。</p>
<p>正如你可能预期的，多年来已经提出了多种不同的 MAC 标准。目前最流行的标准是 HMAC，它可以与 MD5 或 SHA-1 一起使用。HMAC 实际上是将数据和认证密钥两次传递给哈希函数 [<a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">Kaufman 1995</span></a>; <span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2104.html"><strong>RFC 2104</strong></a>]。</p>
<p>还有一个重要的问题尚未解决。我们如何将共享的认证密钥分发给通信实体？例如，在链路状态路由算法中，我们需要以某种方式将秘密认证密钥分发给自治系统中的每一个路由器。（注意，所有路由器可以使用相同的认证密钥。）网络管理员可以通过亲自访问每一个路由器来完成这项工作。或者，如果网络管理员是个懒人，而且每个路由器都有自己的公钥，网络管理员也可以用某个路由器的公钥对认证密钥进行加密，然后通过网络将加密后的密钥发送给该路由器。</p>
<div class="toggle docutils container">
<p>Let’s now return to the problem of message integrity. Now that we understand hash functions, let’s take a first stab at how we might perform message integrity:</p>
<ol class="arabic simple">
<li><p>Alice creates message m and calculates the hash H(m) (for example with SHA-1).</p></li>
<li><p>Alice then appends H(m) to the message m, creating an extended message (m, H(m)), and sends the extended message to Bob.</p></li>
<li><p>Bob receives an extended message (m, h) and calculates H(m). If H(m)=h, Bob concludes that everything is fine.</p></li>
</ol>
<p>This approach is obviously flawed. Trudy can create a bogus message m ́ in which she says she is Alice, calculate H(m ́), and send Bob (m ́, H(m ́)). When Bob receives the message, everything checks out in step 3, so Bob doesn’t suspect any funny ­business.</p>
<p>To perform message integrity, in addition to using cryptographic hash functions, Alice and Bob will need a shared secret s. This shared secret, which is nothing more than a string of bits, is called the <strong>authentication key</strong>. Using this shared secret, message integrity can be performed as follows:</p>
<ol class="arabic simple">
<li><p>Alice creates message m, concatenates s with m to create m+s, and calculates the hash H(m+s) (for example with SHA-1). H(m+s) is called the <strong>message authentication code (MAC)</strong>.</p></li>
<li><p>Alice then appends the MAC to the message m, creating an extended message (m, H(m+s)), and sends the extended message to Bob.</p></li>
</ol>
<p>3. Bob receives an extended message (m, h) and knowing s, calculates the MAC H(m+s). If H(m+s)=h, Bob concludes that everything is fine.
A summary of the procedure is shown in <a class="reference internal" href="#figure-8-9"><span class="std std-ref">Figure 8.9</span></a>. Readers should note that the MAC here (standing for “message authentication code”) is not the same MAC used in link-layer protocols (standing for “medium access control”)!</p>
<figure class="align-center">
<img alt="../_images/677-0.png" src="../_images/677-0.png" />
</figure>
<p><strong>Figure 8.9 Message authentication code (MAC)</strong></p>
<p>One nice feature of a MAC is that it does not require an encryption algorithm. Indeed, in many applications, including the link-state routing algorithm described earlier, communicating entities are only concerned with message integrity and are not concerned with message confidentiality. Using a MAC, the entities can authenticate the messages they send to each other without having to integrate complex encryption algorithms into the integrity process.</p>
<p>As you might expect, a number of different standards for MACs have been proposed over the years. The most popular standard today is HMAC, which can be used either with MD5 or SHA-1. HMAC actually runs data and the authentication key through the hash function twice [<a class="reference internal" href="../references.html#kaufman-1995"><span class="std std-ref">Kaufman 1995</span></a>; <span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2104.html"><strong>RFC 2104</strong></a>].</p>
<p>There still remains an important issue. How do we distribute the shared authentication key to the communicating entities? For example, in the link-state routing algorithm, we would somehow need to distribute the secret authentication key to each of the routers in the autonomous system. (Note that the routers can all use the same authentication key.) A network administrator could actually accomplish this by physically visiting each of the routers. Or, if the network administrator is a lazy guy, and if each router has its own public key, the network administrator could distribute the authentication key to any one of the routers by encrypting it with the router’s public key and then sending the encrypted key over the network to the router.</p>
</div>
</section>
<section id="c8-3-3">
<span id="id5"></span><h2>8.3.3 数字签名<a class="headerlink" href="#c8-3-3" title="此标题的永久链接">#</a></h2>
<p>8.3.3 Digital Signatures</p>
<p>想想你上周在纸上签过多少次名。你会签支票、信用卡收据、法律文件和信件。你的签名证明是你本人（而非其他人）认可和/或同意了文件的内容。在数字世界中，人们常常希望标示文件的所有者或创建者，或表示自己同意文件的内容。 <strong>数字签名</strong> 是一种在数字世界中实现这些目标的加密技术。</p>
<p>就像手写签名一样，数字签名应当是可验证的且不可伪造的。也就是说，必须能够证明某个文件确实是由某个人签署的（签名是可验证的），并且只有该人能够签署该文件（签名是不可伪造的）。</p>
<p>我们现在来考虑如何设计一个数字签名方案。注意，当 Bob 签署一条消息时，Bob 必须在消息上添加一些独属于他的信息。Bob 可以考虑为签名附加一个 MAC，其中 MAC 是将他的密钥（他独有的）附加到消息后再进行哈希计算得到的。但如果 Alice 要验证签名，她也必须拥有这把密钥，在这种情况下密钥就不再是 Bob 独有的了。因此，MAC 在这里无法满足需求。</p>
<p>回忆一下公钥加密，Bob 拥有一对公钥和私钥，这两把钥匙都是 Bob 独有的。因此，公钥加密是实现数字签名的极好候选方案。我们现在来看它是如何实现的。</p>
<p>假设 Bob 想要对一个文档 m 进行数字签名。我们可以把这个文档看作是一个文件或消息，Bob 将对其签名并发送出去。如 <a class="reference internal" href="#figure-8-10"><span class="std std-ref">Figure 8.10</span></a> 所示，为了签署该文档，Bob 只需使用他的私钥 KB− 计算 KB−(m)。起初，这可能看起来有些奇怪，因为我们在 <a class="reference internal" href="s2.html#c8-2"><span class="std std-ref">Section 8.2</span></a> 中看到 Bob 是用私钥对用公钥加密的消息进行解密的。但要记住，加密和解密不过是数学运算（例如 RSA 中是对 e 或 d 次方的幂运算；见 <a class="reference internal" href="s2.html#c8-2"><span class="std std-ref">Section 8.2</span></a>），而 Bob 的目标并不是对文档内容进行加密或混淆，而是以一种可验证且不可伪造的方式对文档进行签名。Bob 的数字签名是 KB−(m)。</p>
<figure class="align-center" id="figure-8-10">
<img alt="../_images/679-0.png" src="../_images/679-0.png" />
</figure>
<p><strong>图 8.10 为文档创建数字签名</strong></p>
<p>这个数字签名 KB−(m) 是否满足可验证且不可伪造的要求？假设 Alice 拥有 m 和 KB−(m)。她希望在法庭上（她是个喜欢打官司的人）证明该文档确实是 Bob 签署的，并且只有 Bob 才可能签署该文档。Alice 使用 Bob 的公钥 KB+ 应用于该文档相关的数字签名 KB−(m)，也就是说，她计算 KB+(KB−(m))，然后哗啦一声，她得到了 m，这正好与原始文档完全一致！于是 Alice 便可以论证只有 Bob 才能签署该文档，理由如下：</p>
<ul class="simple">
<li><p>签署该消息的人必须使用了私钥 KB− 来计算签名 KB−(m)，使得 KB+(KB−(m))=m。</p></li>
<li><p>唯一可能知道私钥 KB− 的人是 Bob。回忆我们在 <a class="reference internal" href="s2.html#c8-2"><span class="std std-ref">Section 8.2</span></a> 中对 RSA 的讨论，知道公钥 KB+ 并不能帮助推导出私钥 KB−。因此，唯一可能知道 KB− 的人是最初生成该密钥对 (KB+, KB−) 的人，也就是 Bob。（注意，这里假设 Bob 没有将 KB− 提供给任何人，也没有人从他那里窃取过 KB−。）</p></li>
</ul>
<p>还需要指出的是，如果原始文档 m 被修改成某个替代形式 ḿ，那么 Bob 为 m 创建的签名对 ḿ 是无效的，因为 KB+(KB−(m)) 不等于 ḿ。因此我们可以看到，数字签名也提供了消息完整性，使接收方能够验证消息是否未被篡改以及消息的来源。</p>
<p>使用加密对数据进行签名的一个问题是，加密和解密的计算代价很高。考虑到加密/解密的开销，使用完整加密/解密来签名数据可能过于繁重。一个更高效的方法是将哈希函数引入数字签名。回忆 <a class="reference internal" href="#c8-3-2"><span class="std std-ref">Section 8.3.2</span></a> 中所述，哈希算法接收一个任意长度的消息 m，并计算出固定长度的“指纹”，记作 H(m)。使用哈希函数，Bob 对消息的哈希值进行签名，而不是消息本身，即 Bob 计算 KB−(H(m))。由于 H(m) 通常远小于原始消息 m，生成数字签名所需的计算量大大降低。</p>
<p>在 Bob 向 Alice 发送消息的场景中，<span class="xref std std-ref">Figure 8.11</span> 总结了创建数字签名的操作过程。Bob 将原始的长消息输入哈希函数，然后用他的私钥对生成的哈希值进行数字签名。原始消息（明文）和数字签名后的消息摘要（下文简称为数字签名）一并发送给 Alice。<a class="reference internal" href="#figure-8-12"><span class="std std-ref">Figure 8.12</span></a> 总结了验证签名的操作过程。Alice 使用发送者的公钥对签名进行解密，得到哈希值；然后 Alice 对明文消息进行哈希计算，得到第二个哈希值。如果两个哈希值相等，那么 Alice 就可以确信消息的完整性和来源。</p>
<p>在继续之前，让我们简要比较一下数字签名和 MAC，因为它们有相似之处，但也存在重要的细微差别。数字签名和 MAC 都从一条消息（或一个文档）开始。为了从消息创建 MAC，我们将认证密钥附加到消息后，然后对结果进行哈希。注意，创建 MAC 时既不涉及公钥加密，也不涉及对称加密。而创建数字签名时，我们先对消息进行哈希，然后用我们的私钥加密该哈希值（使用公钥加密技术）。因此，数字签名是一种“更重”的技术，因为它需要一个包含证书颁发机构的公钥基础设施（PKI）。我们将在 <a class="reference internal" href="s4.html#c8-4"><span class="std std-ref">Section 8.4</span></a> 中看到，PGP——一个流行的安全电子邮件系统——使用数字签名来实现消息完整性。而我们已经看到 OSPF 使用 MAC 实现消息完整性。在 <a class="reference internal" href="s5.html#c8-5"><span class="std std-ref">Sections 8.5</span></a> 和 <a class="reference internal" href="s6.html#c8-6"><span class="std std-ref">8.6</span></a> 中我们将看到，MAC 也被用于流行的传输层和网络层安全协议中。</p>
<div class="toggle docutils container">
<p>Think of the number of the times you’ve signed your name to a piece of paper during the last week. You sign checks, credit card receipts, legal documents, and letters. Your signature attests to the fact that you (as opposed to someone else) have acknowledged and/or agreed with the document’s contents. In a digital world, one often wants to indicate the owner or creator of a document, or to signify one’s agreement with a document’s content. A <strong>digital signature</strong> is a cryptographic technique for achieving these goals in a digital world.</p>
<p>Just as with handwritten signatures, digital signing should be done in a way that is verifiable and nonforgeable. That is, it must be possible to prove that a document signed by an individual was indeed signed by that individual (the signature must be verifiable) and that only that individual could have signed the document (the signature cannot be forged).</p>
<p>Let’s now consider how we might design a digital signature scheme. Observe that when Bob signs a message, Bob must put something on the message that is unique to him. Bob could consider attaching a MAC for the signature, where the MAC is created by appending his key (unique to him) to the message, and then taking the hash. But for Alice to verify the signature, she must also have a copy of the key, in which case the key would not be unique to Bob. Thus, MACs are not going to get the job done here.</p>
<p>Recall that with public-key cryptography, Bob has both a public and private key, with both of these keys being unique to Bob. Thus, public-key cryptography is an excellent candidate for providing digital signatures. Let us now examine how it is done.</p>
<p>Suppose that Bob wants to digitally sign a document, m. We can think of the document as a file or a message that Bob is going to sign and send. As shown in <a class="reference internal" href="#figure-8-10"><span class="std std-ref">Figure 8.10</span></a>, to sign this document, Bob simply uses his private key, KB−, to compute KB−(m). At first, it might seem odd that Bob is using his private key (which, as we saw in <a class="reference internal" href="s2.html#c8-2"><span class="std std-ref">Section 8.2</span></a>, was used to decrypt a message that had been encrypted with his public key) to sign a document. But recall that encryption and decryption are nothing more than mathematical operations (exponentiation to the power of e or d in RSA; see <a class="reference internal" href="s2.html#c8-2"><span class="std std-ref">Section 8.2</span></a>) and recall that Bob’s goal is not to scramble or obscure the contents of the document, but rather to sign the document in a manner that is verifiable and nonforgeable. Bob’s digital signature of the document is KB−(m).</p>
<figure class="align-center">
<img alt="../_images/679-0.png" src="../_images/679-0.png" />
</figure>
<p><strong>Figure 8.10 Creating a digital signature for a document</strong></p>
<p>Does the digital signature KB−(m) meet our requirements of being verifiable and nonforgeable? Suppose Alice has m and KB−(m). She wants to prove in court (being litigious) that Bob had indeed signed the document and was the only person who could have possibly signed the document. Alice takes Bob’s public key, KB+, and applies it to the digital signature, KB−(m), associated with the document, m. That is, she computes KB+(KB−(m)), and voilà, with a dramatic flurry, she produces m, which exactly matches the original document! Alice then argues that only Bob could have signed the document, for the following reasons:</p>
<ul class="simple">
<li><p>Whoever signed the message must have used the private key, KB−, in computing the signature KB−(m), such that KB+(KB−(m))=m.</p></li>
<li><p>The only person who could have known the private key, KB−, is Bob. Recall from our discussion of RSA in <a class="reference internal" href="s2.html#c8-2"><span class="std std-ref">Section 8.2</span></a> that knowing the public key, KB+, is of no help in learning the private key, KB−. Therefore, the only person who could know KB− is the person who generated the pair of keys, (KB+, KB−), in the first place, Bob. (Note that this assumes, though, that Bob has not given KB− to anyone, nor has anyone stolen KB− from Bob.)</p></li>
</ul>
<p>It is also important to note that if the original document, m, is ever modified to some alternate form, m ́, the signature that Bob created for m will not be valid for m ́, since KB+(KB−(m)) does not equal m ́. Thus we see that digital signatures also provide message integrity, allowing the receiver to verify that the message was unaltered as well as the source of the message.</p>
<p>One concern with signing data by encryption is that encryption and decryption are computationally expensive. Given the overheads of encryption and decryption, signing data via complete encryption/decryption can be overkill. A more efficient approach is to introduce hash functions into the digital signature. Recall from <a class="reference internal" href="#c8-3-2"><span class="std std-ref">­Section 8.3.2</span></a> that a hash algorithm takes a message, m, of arbitrary length and computes a fixed-length “fingerprint” of the message, denoted by H(m). Using a hash function, Bob signs the hash of a message rather than the message itself, that is, Bob calculates KB−(H(m)). Since H(m) is generally much smaller than the original message m, the computational effort required to create the digital signature is substantially reduced.</p>
<p>In the context of Bob sending a message to Alice, <span class="xref std std-ref">Figure 8.11</span> provides a summary of the operational procedure of creating a digital signature. Bob puts his original long message through a hash function. He then digitally signs the resulting hash with his private key. The original message (in cleartext) along with the digitally signed message digest (henceforth referred to as the digital signature) is then sent to
Alice. <a class="reference internal" href="#figure-8-12"><span class="std std-ref">Figure 8.12</span></a> provides a summary of the operational procedure of the signature. Alice applies the sender’s public key to the message to obtain a hash result. Alice also applies the hash function to the cleartext message to obtain a second hash result. If the two hashes match, then Alice can be sure about the integrity and author of the message.</p>
<p>Before moving on, let’s briefly compare digital signatures with MACs, since they have parallels, but also have important subtle differences. Both digital signatures and MACs start with a message (or a document). To create a MAC out of the message, we append an authentication key to the message, and then take the hash of the result. Note that neither public key nor symmetric key encryption is involved in creating the MAC. To create a digital signature, we first take the hash of the message and then encrypt the message with our private key (using public key cryptography). Thus, a digital signature is a “heavier” technique, since it requires an underlying Public Key Infrastructure (PKI) with certification authorities as described below. We’ll see in <a class="reference internal" href="s4.html#c8-4"><span class="std std-ref">Section 8.4</span></a> that PGP—a popular secure e-mail system—uses digital signatures for message integrity. We’ve seen already that OSPF uses MACs for message integrity. We’ll see in <a class="reference internal" href="s5.html#c8-5"><span class="std std-ref">Sections 8.5</span></a> and <a class="reference internal" href="s6.html#c8-6"><span class="std std-ref">8.6</span></a> that MACs are also used for popular transport-layer and network-layer security protocols.</p>
</div>
<section id="id6">
<h3>公钥认证<a class="headerlink" href="#id6" title="此标题的永久链接">#</a></h3>
<p>Public Key Certification</p>
<p>数字签名的一个重要应用是 <strong>公钥认证</strong>，也就是认证某个公钥确实属于某个特定实体。公钥认证被应用在许多流行的安全网络协议中，包括 IPsec 和 SSL。</p>
<p>为了更好地理解这个问题，我们来看一个关于互联网商业的“披萨恶作剧”经典案例。Alice 从事披萨外卖生意，并接受通过互联网下的订单。Bob 是个披萨爱好者，他给 Alice 发送了一条明文消息，包含了他的家庭地址和他想要的披萨种类。在这条消息中，Bob 还附加了一个数字签名（即对原始明文消息的哈希值进行签名），以此向 Alice 证明该消息确实来自他本人。为了验证签名，Alice 获取 Bob 的公钥（可能从公钥服务器或邮件中获得），然后验证该数字签名。通过这种方式，她可以确认是 Bob 下的订单，而不是某个调皮捣蛋的青少年。</p>
<figure class="align-center" id="figure-8-12">
<img alt="../_images/682-0.png" src="../_images/682-0.png" />
</figure>
<p><strong>图 8.12 验证带签名的消息</strong></p>
<p>这一切听起来都不错，直到聪明的 Trudy 出场。如 <a class="reference internal" href="#figure-8-13"><span class="std std-ref">Figure 8.13</span></a> 所示，Trudy 正在进行一场恶作剧。她向 Alice 发送了一条消息，自称是 Bob，提供了 Bob 的家庭地址，并订购了一份披萨。在这条消息中，她还附上了她自己的（Trudy 的）公钥，尽管 Alice 自然地认为这就是 Bob 的公钥。Trudy 还附加了一个数字签名，这个签名是用她自己的（Trudy 的）私钥生成的。收到消息后，Alice 使用 Trudy 的公钥（以为这是 Bob 的）验证数字签名，并得出该明文消息确实是由 Bob 创建的结论。当外卖员将一份有香肠和凤尾鱼的披萨送到 Bob 家时，Bob 会非常吃惊！</p>
<figure class="align-center" id="figure-8-13">
<img alt="../_images/683-0.png" src="../_images/683-0.png" />
</figure>
<p><strong>图 8.13 Trudy 使用公钥加密伪装成 Bob</strong></p>
<p>从这个例子可以看出，要使公钥加密有用，你必须能够验证你所拥有的公钥确实属于你想要通信的实体（人、路由器、浏览器等）。例如，当 Alice 想要与 Bob 使用公钥加密通信时，她需要验证该公钥确实属于 Bob。</p>
<p>将公钥绑定到特定实体通常由 <strong>认证机构（CA）</strong> 完成，其职责是验证身份并颁发证书。CA 的角色包括：</p>
<ol class="arabic">
<li><p>CA 验证某个实体（人、路由器等）的身份是否属实。认证的具体过程并没有统一的规定。在与 CA 打交道时，人们必须信任 CA 已经执行了足够严格的身份验证。例如，如果 Trudy 能走进 Fly-by-Night</p>
<figure class="align-center" id="figure-8-14">
<img alt="../_images/684-0.png" src="../_images/684-0.png" />
</figure>
<p><strong>图 8.14 Bob 由 CA 认证其公钥</strong></p>
<p>CA 并直接宣称“我是 Alice”，然后就获得了与 Alice 身份相关的证书，那么就不应太过信任由该 Fly-by-Night CA 所认证的公钥。另一方面，人们可能（也可能不会！）更愿意信任隶属于联邦或州政府项目的 CA。你对某个公钥所关联身份的信任程度，仅能达到你对该 CA 及其身份验证方法的信任程度。我们所编织的是一张错综复杂的信任之网！</p>
</li>
<li><p>一旦 CA 验证了实体的身份，CA 就会创建一个 <strong>证书</strong>，将该实体的公钥绑定到该身份。该证书包含公钥及其所有者的全局唯一标识信息（例如人名或 IP 地址）。该证书由 CA 进行数字签名。这些步骤如 <a class="reference internal" href="#figure-8-14"><span class="std std-ref">Figure 8.14</span></a> 所示。</p></li>
</ol>
<p>现在我们来看看如何使用证书来对抗像 Trudy 那样的订披萨恶作剧者以及其他不良行为者。当 Bob 下订单时，他同时发送由 CA 签发的证书。Alice 使用 CA 的公钥来验证 Bob 的证书有效性并提取出 Bob 的公钥。</p>
<p>国际电信联盟（ITU）和 IETF 都制定了 CA 的相关标准。ITU 的 X.509 <a class="reference internal" href="../references.html#itu-2005a"><span class="std std-ref">[ITU 2005a]</span></a> 规范定义了认证服务以及证书的特定语法。[<span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1422.html"><strong>RFC 1422</strong></a>] 描述了用于安全电子邮件的基于 CA 的密钥管理方式。它兼容 X.509，并通过建立密钥管理架构的过程与惯例扩展了 X.509。<a class="reference internal" href="#table-8-4"><span class="std std-ref">Table 8.4</span></a> 描述了证书中的一些重要字段。</p>
<p id="table-8-4"><strong>表 8.4 X.509 和 RFC 1422 公钥证书中的字段</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>字段名</strong></p></td>
<td><p><strong>描述</strong></p></td>
</tr>
<tr class="row-even"><td><p>Version</p></td>
<td><p>X.509 规范的版本号</p></td>
</tr>
<tr class="row-odd"><td><p>Serial number</p></td>
<td><p>CA 为证书分配的唯一标识符</p></td>
</tr>
<tr class="row-even"><td><p>Signature</p></td>
<td><p>CA 用于签署该证书的算法</p></td>
</tr>
<tr class="row-odd"><td><p>Issuer name</p></td>
<td><p>签发该证书的 CA 的身份信息，采用 DN（可分辨名称）格式 [<span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4514.html"><strong>RFC 4514</strong></a>]</p></td>
</tr>
<tr class="row-even"><td><p>Validity period</p></td>
<td><p>证书的有效期起始与结束时间</p></td>
</tr>
<tr class="row-odd"><td><p>Subject name</p></td>
<td><p>与此证书相关联的公钥所有者的身份，采用 DN 格式</p></td>
</tr>
<tr class="row-even"><td><p>Subject public key</p></td>
<td><p>该主体的公钥，以及用于该公钥的公钥算法及参数</p></td>
</tr>
</tbody>
</table>
</div>
<div class="toggle docutils container">
<p>An important application of digital signatures is <strong>public key certification</strong>, that is, certifying that a public key belongs to a specific entity. Public key certification is used in many popular secure networking protocols, including IPsec and SSL.</p>
<p>To gain insight into this problem, let’s consider an Internet-commerce version of the classic “pizza prank.” Alice is in the pizza delivery business and accepts orders over the Internet. Bob, a pizza lover, sends Alice a plaintext message that includes his home address and the type of pizza he wants. In this message, Bob also includes a digital signature (that is, a signed hash of the original plaintext message) to prove to Alice that he is the true source of the message. To verify the signature, Alice obtains Bob’s public key (perhaps from a public key server or from the e-mail message) and checks the digital signature. In this manner she makes sure that Bob, rather than some adolescent prankster, placed the order.</p>
<figure class="align-center">
<img alt="../_images/682-0.png" src="../_images/682-0.png" />
</figure>
<p><strong>Figure 8.12 Verifying a signed message</strong></p>
<p>This all sounds fine until clever Trudy comes along. As shown in <a class="reference internal" href="#figure-8-13"><span class="std std-ref">Figure 8.13</span></a>, Trudy is indulging in a prank. She sends a message to Alice in which she says she is Bob, gives Bob’s home address, and orders a pizza. In this message she also includes her (Trudy’s) public key, although Alice naturally assumes it is Bob’s public key. Trudy also attaches a digital signature, which was created with her own (Trudy’s) private key. After receiving the message, Alice applies Trudy’s public key (thinking that it is Bob’s) to the digital signature and concludes that the plaintext message was indeed created by Bob. Bob will be very surprised when the delivery person brings a pizza with pepperoni and anchovies to his home!</p>
<figure class="align-center">
<img alt="../_images/683-0.png" src="../_images/683-0.png" />
</figure>
<p><strong>Figure 8.13 Trudy masquerades as Bob using public key cryptography</strong></p>
<p>We see from this example that for public key cryptography to be useful, you need to be able to verify that you have the actual public key of the entity (person, router, browser, and so on) with whom you want to communicate. For example, when Alice wants to communicate with Bob using public key cryptography, she needs to verify that the public key that is supposed to be Bob’s is indeed Bob’s.</p>
<p>Binding a public key to a particular entity is typically done by a <strong>Certification Authority (CA)</strong>, whose job is to validate identities and issue certificates. A CA has the following roles:</p>
<ol class="arabic">
<li><p>A CA verifies that an entity (a person, a router, and so on) is who it says it is. There are no mandated procedures for how certification is done. When dealing with a CA, one must trust the CA to have performed a suitably rigorous identity verification. For example, if Trudy were able to walk into the Fly-by-Night</p>
<figure class="align-center">
<img alt="../_images/684-0.png" src="../_images/684-0.png" />
</figure>
<p><strong>Figure 8.14  Bob has his public key certified by the CA</strong></p>
<p>CA and simply announce “I am Alice” and receive certificates associated with the identity of Alice, then one shouldn’t put much faith in public keys certified by the Fly-by-Night CA. On the other hand, one might (or might not!) be more willing to trust a CA that is part of a federal or state program. You can trust the identity associated with a public key only to the extent to which you can trust a CA and its identity verification techniques. What a tangled web of trust we spin!</p>
</li>
<li><p>Once the CA verifies the identity of the entity, the CA creates a <strong>certificate</strong> that binds the public key of the entity to the identity. The certificate contains the public key and globally unique identifying information about the owner of the public key (for example, a human name or an IP address). The certificate is digitally signed by the CA. These steps are shown in <a class="reference internal" href="#figure-8-14"><span class="std std-ref">Figure 8.14</span></a>.</p></li>
</ol>
<p>Let us now see how certificates can be used to combat pizza-ordering pranksters, like Trudy, and other undesirables. When Bob places his order he also sends his CA-signed certificate. Alice uses the CA’s public key to check the validity of Bob’s certificate and extract Bob’s public key.</p>
<p>Both the International Telecommunication Union (ITU) and the IETF have developed standards for CAs. ITU X.509 <a class="reference internal" href="../references.html#itu-2005a"><span class="std std-ref">[ITU 2005a]</span></a> specifies an authentication service as well as a specific syntax for certificates. [<span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1422.html"><strong>RFC 1422</strong></a>] describes CA-based key management for use with secure Internet e-mail. It is compatible with X.509 but goes beyond X.509 by establishing procedures and conventions for a key management architecture. <a class="reference internal" href="#table-8-4"><span class="std std-ref">Table 8.4</span></a> describes some of the important fields in a certificate.</p>
<p><strong>Table 8.4 Selected fields in an X.509 and RFC 1422 public key</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>Field Name</strong></p></td>
<td><p><strong>Description</strong></p></td>
</tr>
<tr class="row-even"><td><p>Version</p></td>
<td><p>Version number of X.509 specification</p></td>
</tr>
<tr class="row-odd"><td><p>Serial number</p></td>
<td><p>CA-issued unique identifier for a certificate</p></td>
</tr>
<tr class="row-even"><td><p>Signature</p></td>
<td><p>Specifies the algorithm used by CA to sign this certificate</p></td>
</tr>
<tr class="row-odd"><td><p>Issuer name</p></td>
<td><p>Identity of CA issuing this certificate, in distinguished name (DN) [<span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4514.html"><strong>RFC 4514</strong></a>] format</p></td>
</tr>
<tr class="row-even"><td><p>Validity period</p></td>
<td><p>Start and end of period of validity for certificate</p></td>
</tr>
<tr class="row-odd"><td><p>Subject name</p></td>
<td><p>Identity of entity whose public key is associated with this certificate, in DN format</p></td>
</tr>
<tr class="row-even"><td><p>Subject public key</p></td>
<td><p>The subject’s public key as well indication of the public key algorithm (and algorithm parameters) to be used with this key</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="s2.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">8.2 密码学原理</p>
      </div>
    </a>
    <a class="right-next"
       href="s4.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">8.4 终端认证</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-3-1">8.3.1 加密哈希函数</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-3-2">8.3.2 消息认证码</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c8-3-3">8.3.3 数字签名</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">公钥认证</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>