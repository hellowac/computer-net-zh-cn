

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>2.3 互联网中的电子邮件 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c2/s3';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="2.4 DNS——互联网的目录服务" href="s4.html" />
    <link rel="prev" title="2.2 Web 与 HTTP" href="s2.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 2 章 应用层</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2"><a class="reference internal" href="s4.html">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="s5.html">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c4/index.html">第 4 章 网络层：数据平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c4/s1.html">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c6/index.html">第 6 章 链路层与局域网（LANs）</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c6/s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s2.html">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c8/index.html">第 8 章 计算机网络中的安全</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c8/s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s2.html">8.2 密码学原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s3.html">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c9/index.html">第 9 章 多媒体网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c9/s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s2.html">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c2/s3.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>2.3 互联网中的电子邮件</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#smtp">2.3.1 SMTP</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#http">2.3.2 与 HTTP 的对比</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-3-3">2.3.3 邮件消息格式</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-3-4">2.3.4 邮件访问协议</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pop3">POP3</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#imap">IMAP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#web">基于 Web 的电子邮件</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="c2-3">
<span id="id1"></span><h1>2.3 互联网中的电子邮件<a class="headerlink" href="#c2-3" title="此标题的永久链接">#</a></h1>
<p>2.3 Electronic Mail in the Internet</p>
<p>电子邮件自互联网诞生之初便已存在。它在互联网早期是最流行的应用 <a class="reference internal" href="../references.html#segaller-1998"><span class="std std-ref">[Segaller 1998]</span></a>，并在这些年中变得更加复杂和强大。它仍然是互联网中最重要和最常用的应用之一。</p>
<p>与普通邮政邮件类似，电子邮件是一种异步通信媒介 —— 人们可以在方便的时候发送和阅读消息，无需与他人的时间安排协调。与邮政邮件相比，电子邮件传输快速、易于分发且成本低廉。现代电子邮件拥有许多强大功能，包括带附件的消息、超链接、HTML 格式文本和嵌入图片等。</p>
<p>本节我们将研究构成互联网电子邮件核心的应用层协议。但在深入讨论这些协议之前，先从更高层次了解互联网邮件系统及其关键组件。</p>
<p><a class="reference internal" href="#figure-2-14"><span class="std std-ref">图 2.14</span></a> 展示了互联网邮件系统的高层视图。从图中可见，该系统包含三个主要组件： <strong>用户代理（user agents）</strong>、 <strong>邮件服务器（mail servers）</strong> 和 <strong>简单邮件传输协议（SMTP）</strong>。</p>
<p>我们将在发送者 Alice 向接收者 Bob 发送电子邮件的场景中描述这些组件。用户代理允许用户读取、回复、转发、保存和撰写消息。Microsoft Outlook 和 Apple Mail 是电子邮件用户代理的例子。当 Alice 撰写完她的邮件后，她的用户代理将邮件发送到她的邮件服务器，邮件被放入该服务器的外发邮件队列中。当 Bob 想要阅读邮件时，他的用户代理会从其邮件服务器的邮箱中提取邮件。</p>
<p>邮件服务器构成电子邮件基础设施的核心。每位接收者，例如 Bob，在某个邮件服务器中都有一个 <strong>邮箱（mailbox）</strong>。Bob 的邮箱管理并维护发送给他的邮件。通常一封邮件从发送者的用户代理开始，传送到发送者的邮件服务器，再传送到接收者的邮件服务器，最后投递到接收者的邮箱中。当 Bob 想访问邮箱中的邮件时，包含其邮箱的邮件服务器会对其进行身份验证（通过用户名和密码）。Alice 的邮件服务器还必须处理 Bob 的邮件服务器出现故障的情况。如果 Alice 的服务器无法向 Bob 的服务器投递邮件，它会将邮件保存在一个 <strong>消息队列（message queue）</strong> 中，并尝试稍后再次发送。通常每隔 30 分钟重试一次；如果几天内仍未成功，服务器会删除该邮件，并通过电子邮件通知发件人（Alice）。</p>
<figure class="align-center" id="figure-2-14">
<img alt="../_images/150-0.png" src="../_images/150-0.png" />
</figure>
<p><strong>图 2.14 互联网邮件系统的高层视图</strong></p>
<p>SMTP 是互联网电子邮件的主要应用层协议。它使用 TCP 提供的可靠数据传输服务将邮件从发送方邮件服务器传送到接收方邮件服务器。与大多数应用层协议类似，SMTP 包含两个部分：在发送方邮件服务器上运行的客户端部分，以及在接收方邮件服务器上运行的服务器部分。每个邮件服务器都运行 SMTP 的客户端和服务器两部分。当邮件服务器向其他邮件服务器发送邮件时，它充当 SMTP 客户端；当从其他邮件服务器接收邮件时，它充当 SMTP 服务器。</p>
<div class="toggle docutils container">
<p>Electronic mail has been around since the beginning of the Internet. It was the most popular application
when the Internet was in its infancy <a class="reference internal" href="../references.html#segaller-1998"><span class="std std-ref">[Segaller 1998]</span></a> , and has become more elaborate and powerful over the years. It remains one of the Internet’s most important and utilized applications.</p>
<p>As with ordinary postal mail, e-mail is an asynchronous communication medium—people send and read messages when it is convenient for them, without having to coordinate with other people’s schedules. In contrast with postal mail, electronic mail is fast, easy to distribute, and inexpensive. Modern e-mail has many powerful features, including messages with attachments, hyperlinks, HTML-formatted text, and embedded photos.</p>
<p>In this section, we examine the application-layer protocols that are at the heart of Internet e-mail. But before we jump into an in-depth discussion of these protocols, let’s take a high-level view of the Internet mail system and its key components.</p>
<p><a class="reference internal" href="#figure-2-14"><span class="std std-ref">Figure 2.14</span></a> presents a high-level view of the Internet mail system. We see from this diagram that it has three major components: <strong>user agents</strong>, <strong>mail servers</strong>, and the <strong>Simple Mail Transfer Protocol (SMTP)</strong>.
We now describe each of these components in the context of a sender, Alice, sending an e-mail message to a recipient, Bob. User agents allow users to read, reply to, forward, save, and compose messages. Microsoft Outlook and Apple Mail are examples of user agents for e-mail. When Alice is finished composing her message, her user agent sends the message to her mail server, where the message is placed in the mail server’s outgoing message queue. When Bob wants to read a message, his user agent retrieves the message from his mailbox in his mail server.</p>
<p>Mail servers form the core of the e-mail infrastructure. Each recipient, such as Bob, has a <strong>mailbox</strong> located in one of the mail servers. Bob’s mailbox manages and maintains the messages that have been sent to him. A typical message starts its journey in the sender’s user agent, travels to the sender’s mail server, and travels to the recipient’s mail server, where it is deposited in the recipient’s mailbox. When Bob wants to access the messages in his mailbox, the mail server containing his mailbox authenticates Bob (with usernames and passwords). Alice’s mail server must also deal with failures in Bob’s mail server. If Alice’s server cannot deliver mail to Bob’s server, Alice’s server holds the message in a <strong>message queue</strong> and attempts to transfer the message later. Reattempts are often done every 30 minutes or so; if there is no success after several days, the server removes the message and notifies the sender (Alice) with an e-mail message.</p>
<figure class="align-default">
<img alt="../_images/150-0.png" src="../_images/150-0.png" />
</figure>
<dl class="field-list simple">
<dt class="field-odd">align<span class="colon">:</span></dt>
<dd class="field-odd"><p>center</p>
</dd>
</dl>
<p><strong>Figure 2.14 A high-level view of the Internet e-mail system</strong></p>
<p>SMTP is the principal application-layer protocol for Internet electronic mail. It uses the reliable data transfer service of TCP to transfer mail from the sender’s mail server to the recipient’s mail server. As with most application-layer protocols, SMTP has two sides: a client side, which executes on the sender’s mail server, and a server side, which executes on the recipient’s mail server. Both the client and server sides of SMTP run on every mail server. When a mail server sends mail to other mail servers, it acts as an SMTP client. When a mail server receives mail from other mail servers, it acts as an SMTP server.</p>
</div>
<section id="smtp">
<span id="c2-3-1"></span><h2>2.3.1 SMTP<a class="headerlink" href="#smtp" title="此标题的永久链接">#</a></h2>
<p>SMTP 定义于 <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5321.html"><strong>RFC 5321</strong></a>，是互联网电子邮件的核心。如前所述，SMTP 将邮件从发送方邮件服务器传输到接收方邮件服务器。SMTP 的历史远早于 HTTP（最初的 SMTP RFC 可追溯到 1982 年，SMTP 在那之前就已经存在）。尽管 SMTP 拥有众多优点并广泛应用于互联网，但它仍是一种遗留技术，具有某些过时特性。例如，它限制所有邮件消息的正文（不仅是头部）为简单的 7 位 ASCII。这种限制在 20 世纪 80 年代初传输能力有限、没有人通过电子邮件发送大型附件或图像、音频、视频文件时是合理的。但在多媒体时代，这种限制带来不便 —— 二进制多媒体数据必须在通过 SMTP 发送前编码为 ASCII；在 SMTP 传输后还需再解码为二进制。回忆一下 <a class="reference internal" href="s2.html#c2-2"><span class="std std-ref">第 2.2 节</span></a> 中提到的，HTTP 不要求在传输前将多媒体数据编码为 ASCII。</p>
<p>为说明 SMTP 的基本操作，我们通过一个常见场景来演示。假设 Alice 想向 Bob 发送一个简单的 ASCII 消息。</p>
<ol class="arabic simple">
<li><p>Alice 启动她的电子邮件用户代理，填写 Bob 的电子邮件地址（例如 <a class="reference external" href="mailto:bob&#37;&#52;&#48;someschool&#46;edu">bob<span>&#64;</span>someschool<span>&#46;</span>edu</a>），撰写消息，并指示用户代理发送该消息。</p></li>
<li><p>Alice 的用户代理将消息发送到她的邮件服务器，消息被放入消息队列中。</p></li>
<li><p>SMTP 客户端部分在 Alice 的邮件服务器上运行，看到消息在队列中，于是建立到 SMTP 服务器（运行在 Bob 的邮件服务器上）的 TCP 连接。</p></li>
<li><p>经过初始的 SMTP 握手过程后，SMTP 客户端将 Alice 的消息通过 TCP 连接发送出去。</p></li>
<li><p>在 Bob 的邮件服务器上，SMTP 服务器部分接收该消息。Bob 的邮件服务器随后将消息放入 Bob 的邮箱中。</p></li>
<li><p>Bob 启动他的用户代理，在方便的时候读取该消息。</p></li>
</ol>
<p>此过程在 <a class="reference internal" href="#figure-2-15"><span class="std std-ref">图 2.15</span></a> 中进行了总结。</p>
<p>需要注意的是，SMTP 通常不使用中间邮件服务器转发邮件，即使两个邮件服务器位于地球两端。如果 Alice 的服务器在香港，而 Bob 的服务器在圣路易斯，TCP 连接就是香港与圣路易斯服务器之间的直接连接。特别地，如果 Bob 的邮件服务器宕机，消息会保留在 Alice 的邮件服务器上，等待后续尝试 —— 而不会转发到某个中间邮件服务器。</p>
<figure class="align-center" id="figure-2-15">
<img alt="../_images/152-0.png" src="../_images/152-0.png" />
</figure>
<p><strong>图 2.15 Alice 向 Bob 发送一封邮件</strong></p>
<p>我们现在更深入地了解 SMTP 如何将邮件从发送服务器传送到接收服务器。SMTP 协议在许多方面与面对面的人际交流协议类似。首先，SMTP 客户端（运行在发送方邮件服务器主机上）通过 TCP 建立到 SMTP 服务器（运行在接收方邮件服务器主机上）端口 25 的连接。如果服务器宕机，客户端会稍后重试。一旦连接建立，服务器和客户端进行应用层握手 —— 就像人们在互相传递信息前会先相互介绍一样，SMTP 客户端和服务器也在传输信息前相互介绍。在握手阶段，SMTP 客户端会指明发件人和收件人的电子邮件地址。介绍完成后，客户端发送邮件。SMTP 借助 TCP 的可靠数据传输确保消息不出错地传送到服务器。如果客户端还有其他消息需要发送，会通过同一 TCP 连接重复该过程；否则，它会指示 TCP 关闭连接。</p>
<p>我们接下来来看一个 SMTP 客户端（C）与 SMTP 服务器（S）之间交换消息的示例对话。客户端主机名为 <a class="reference external" href="http://crepes.fr/">crepes.fr</a>，服务器主机名为 <a class="reference external" href="http://hamburger.edu/">hamburger.edu</a>。标有 <code class="docutils literal notranslate"><span class="pre">C:</span></code> 的 ASCII 文本行为客户端通过其 TCP 套接字发送的内容，标有 <code class="docutils literal notranslate"><span class="pre">S:</span></code> 的文本行为服务器发送的内容。以下对话从 TCP 连接建立开始：</p>
<div class="highlight-smtp notranslate"><div class="highlight"><pre><span></span>S:  220 hamburger.edu
C:  HELO crepes.fr
S:  250 Hello crepes.fr, pleased to meet you
C:  MAIL FROM: &lt;alice@crepes.fr&gt;
S:  250 alice@crepes.fr ... Sender ok
C:  RCPT TO: &lt;bob@hamburger.edu&gt;
S:  250 bob@hamburger.edu ... Recipient ok
C:  DATA
S:  354 Enter mail, end with ”.” on a line by itself
C:  Do you like ketchup?
C:  How about pickles?
C:  .
S:  250 Message accepted for delivery
C:  QUIT
S:  221 hamburger.edu closing connection
</pre></div>
</div>
<p>在上述示例中，客户端从邮件服务器 <cite>crepes.fr</cite> 向 <cite>hamburger.edu</cite> 发送消息（“Do you like ketchup? How about pickles?”）。在对话过程中，客户端发出了五个命令： <cite>HELO</cite> （HELLO 的缩写）、 <cite>MAIL FROM</cite>、 <cite>RCPT TO</cite>、 <cite>DATA</cite> 和 <cite>QUIT</cite>。这些命令直观易懂。客户端还发送了一行仅包含一个句点的行，表示消息结束。（在 ASCII 中，每封消息以 <cite>CRLF.CRLF</cite> 结束，CR 和 LF 分别表示回车和换行。）服务器对每个命令进行响应，响应包含一个代码及可选的英文解释说明。值得一提的是，SMTP 使用持久连接：如果发送服务器有多封邮件要发送给同一个接收服务器，它可以通过同一个 TCP 连接发送所有消息。每封消息开始于新的 <code class="docutils literal notranslate"><span class="pre">MAIL</span> <span class="pre">FROM:</span> <span class="pre">crepes.fr</span></code>，以句点标记结束，直到所有消息发送完毕后才发出 QUIT 命令。</p>
<p>强烈建议你使用 Telnet 与 SMTP 服务器直接对话。可执行如下命令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>telnet<span class="w"> </span>serverName<span class="w"> </span><span class="m">25</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">serverName</span></code> 是本地邮件服务器的名称。该命令会在本地主机与邮件服务器之间建立 TCP 连接。输入此行后，你应立即收到来自服务器的 <code class="docutils literal notranslate"><span class="pre">220</span></code> 回复。然后在适当时机依次输入 SMTP 命令 <code class="docutils literal notranslate"><span class="pre">HELO</span></code>、 <code class="docutils literal notranslate"><span class="pre">MAIL</span> <span class="pre">FROM</span></code>、 <code class="docutils literal notranslate"><span class="pre">RCPT</span> <span class="pre">TO</span></code>、 <code class="docutils literal notranslate"><span class="pre">DATA</span></code>、 <code class="docutils literal notranslate"><span class="pre">CRLF.CRLF</span></code> 和 <code class="docutils literal notranslate"><span class="pre">QUIT</span></code>。我们也强烈建议你完成本章末尾的编程练习 3。在该练习中，你将构建一个实现 SMTP 客户端功能的简单用户代理，能够通过本地邮件服务器向任意收件人发送电子邮件。</p>
<div class="toggle docutils container">
<p>SMTP, defined in RFC 5321, is at the heart of Internet electronic mail. As mentioned above, SMTP transfers messages from senders’ mail servers to the recipients’ mail servers. SMTP is much older than HTTP. (The original SMTP RFC dates back to 1982, and SMTP was around long before that.) Although SMTP has numerous wonderful qualities, as evidenced by its ubiquity in the Internet, it is nevertheless a legacy technology that possesses certain archaic characteristics. For example, it restricts the body (not just the headers) of all mail messages to simple 7-bit ASCII. This restriction made sense in the early 1980s when transmission capacity was scarce and no one was e-mailing large attachments or large image, audio, or video files. But today, in the multimedia era, the 7-bit ASCII restriction is a bit of a pain —it requires binary multimedia data to be encoded to ASCII before being sent over SMTP; and it requires the corresponding ASCII message to be decoded back to binary after SMTP transport. Recall from <a class="reference internal" href="s2.html#c2-2"><span class="std std-ref">Section 2.2</span></a> that HTTP does not require multimedia data to be ASCII encoded before transfer.</p>
<p>To illustrate the basic operation of SMTP, let’s walk through a common scenario. Suppose Alice wants to send Bob a simple ASCII message.</p>
<ol class="arabic simple">
<li><p>Alice invokes her user agent for e-mail, provides Bob’s e-mail address (for example, <a class="reference external" href="mailto:bob&#37;&#52;&#48;someschool&#46;edu">bob<span>&#64;</span>someschool<span>&#46;</span>edu</a>), composes a message, and instructs the user agent to send the message.</p></li>
<li><p>Alice’s user agent sends the message to her mail server, where it is placed in a message queue.</p></li>
<li><p>The client side of SMTP, running on Alice’s mail server, sees the message in the message queue. It opens a TCP connection to an SMTP server, running on Bob’s mail server.</p></li>
<li><p>After some initial SMTP handshaking, the SMTP client sends Alice’s message into the TCP connection.</p></li>
<li><p>At Bob’s mail server, the server side of SMTP receives the message. Bob’s mail server then places the message in Bob’s mailbox.</p></li>
<li><p>Bob invokes his user agent to read the message at his convenience.</p></li>
</ol>
<p>The scenario is summarized in <a class="reference internal" href="#figure-2-15"><span class="std std-ref">Figure 2.15</span></a>.</p>
<p>It is important to observe that SMTP does not normally use intermediate mail servers for sending mail, even when the two mail servers are located at opposite ends of the world. If Alice’s server is in Hong Kong and Bob’s server is in St. Louis, the TCP connection is a direct connection between the Hong Kong and St. Louis servers. In particular, if Bob’s mail server is down, the message remains in Alice’s mail server and waits for a new attempt—the message does not get placed in some intermediate mail server.</p>
<figure class="align-center">
<img alt="../_images/152-0.png" src="../_images/152-0.png" />
</figure>
<p><strong>Figure 2.15 Alice sends a message to Bob</strong></p>
<p>Let’s now take a closer look at how SMTP transfers a message from a sending mail server to a receiving mail server. We will see that the SMTP protocol has many similarities with protocols that are used for face-to-face human interaction. First, the client SMTP (running on the sending mail server host) has TCP establish a connection to port 25 at the server SMTP (running on the receiving mail server host). If the server is down, the client tries again later. Once this connection is established, the server and client perform some application-layer handshaking—just as humans often introduce themselves before transferring information from one to another, SMTP clients and servers introduce themselves before transferring information. During this SMTP handshaking phase, the SMTP client indicates the e- mail address of the sender (the person who generated the message) and the e-mail address of the recipient. Once the SMTP client and server have introduced themselves to each other, the client sends the message. SMTP can count on the reliable data transfer service of TCP to get the message to the server without errors. The client then repeats this process over the same TCP connection if it has other messages to send to the server; otherwise, it instructs TCP to close the connection.</p>
<p>Let’s next take a look at an example transcript of messages exchanged between an SMTP client (C) and an SMTP server (S). The hostname of the client is <a class="reference external" href="http://crepes.fr/">crepes.fr</a> and the hostname of the server is <a class="reference external" href="http://hamburger.edu/">hamburger.edu</a>. The ASCII text lines prefaced with <code class="docutils literal notranslate"><span class="pre">C:</span></code> are exactly the lines the client sends into its TCP socket, and the ASCII text lines prefaced with <code class="docutils literal notranslate"><span class="pre">S:</span></code> are exactly the lines the server sends into its TCP socket. The following transcript begins as soon as the TCP connection is established.</p>
<div class="highlight-smtp notranslate"><div class="highlight"><pre><span></span>S:  220 hamburger.edu
C:  HELO crepes.fr
S:  250 Hello crepes.fr, pleased to meet you
C:  MAIL FROM: &lt;alice@crepes.fr&gt;
S:  250 alice@crepes.fr ... Sender ok
</pre></div>
</div>
<p>C:  RCPT TO: &lt;<a class="reference external" href="mailto:bob&#37;&#52;&#48;hamburger&#46;edu">bob<span>&#64;</span>hamburger<span>&#46;</span>edu</a>&gt;
S:  250 <a class="reference external" href="mailto:bob&#37;&#52;&#48;hamburger&#46;edu">bob<span>&#64;</span>hamburger<span>&#46;</span>edu</a> … Recipient ok
C:  DATA
S:  354 Enter mail, end with ”.” on a line by itself
C:  Do you like ketchup?
C:  How about pickles?
C:  .
S:  250 Message accepted for delivery
C:  QUIT
S:  221 hamburger.edu closing connection</p>
<p>In the example above, the client sends a message (“Do you like ketchup? How about pickles?”) from mail server <cite>crepes.fr</cite> to mail server <cite>hamburger.edu</cite>. As part of the dialogue, the client issued five commands: <cite>HELO</cite> (an abbreviation for HELLO), <cite>MAIL FROM</cite>, <cite>RCPT TO</cite>, <cite>DATA</cite>,
and <cite>QUIT</cite>. These commands are self-explanatory. The client also sends a line consisting of a single period, which indicates the end of the message to the server. (In ASCII jargon, each message ends with <cite>CRLF.CRLF</cite>, where <cite>CR</cite> and <cite>LF</cite> stand for carriage return and line feed, respectively.) The server issues replies to each command, with each reply having a reply code and some (optional) English- language explanation. We mention here that SMTP uses persistent connections: If the sending mail server has several messages to send to the same receiving mail server, it can send all of the messages over the same TCP connection. For each message, the client begins the process with a new <code class="docutils literal notranslate"><span class="pre">MAIL</span> <span class="pre">FROM:</span> <span class="pre">crepes.fr</span></code>, designates the end of message with an isolated period, and issues QUIT only after all messages have been sent.</p>
<p>It is highly recommended that you use Telnet to carry out a direct dialogue with an SMTP server. To do this, issue</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>telnet<span class="w"> </span>serverName<span class="w"> </span><span class="m">25</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">serverName</span></code> is the name of a local mail server. When you do this, you are simply establishing a TCP connection between your local host and the mail server. After typing this line, you should immediately receive the <code class="docutils literal notranslate"><span class="pre">220</span></code> reply from the server. Then issue the SMTP commands <code class="docutils literal notranslate"><span class="pre">HELO</span></code>, <code class="docutils literal notranslate"><span class="pre">MAIL</span> <span class="pre">FROM</span></code>, <code class="docutils literal notranslate"><span class="pre">RCPT</span> <span class="pre">TO</span></code>, <code class="docutils literal notranslate"><span class="pre">DATA</span></code>, <code class="docutils literal notranslate"><span class="pre">CRLF.CRLF</span></code>, and <code class="docutils literal notranslate"><span class="pre">QUIT</span></code> at the appropriate times. It is also highly recommended that you do Programming Assignment 3 at the end of this chapter. In that assignment, you’ll build a simple user agent that implements the client side of SMTP. It will allow you to send an e-mail message to an arbitrary recipient via a local mail server.</p>
</div>
</section>
<section id="http">
<span id="c2-3-2"></span><h2>2.3.2 与 HTTP 的对比<a class="headerlink" href="#http" title="此标题的永久链接">#</a></h2>
<p>2.3.2 Comparison with HTTP</p>
<p>现在我们简要比较一下 SMTP 和 HTTP。这两个协议都用于在主机之间传输文件：HTTP 将文件（也称为对象）从 Web 服务器传输到 Web 客户端（通常是浏览器）；SMTP 将文件（即电子邮件消息）从一个邮件服务器传输到另一个邮件服务器。在传输文件时，持久性 HTTP 和 SMTP 都使用持久连接。因此，这两个协议具有一些共同特性。然而，它们之间也存在重要差异。首先，HTTP 主要是一个 <code class="docutils literal notranslate"><span class="pre">拉取协议（pull</span> <span class="pre">protocol）</span></code> —— 某人将信息加载到 Web 服务器上，用户通过 HTTP 在方便时从服务器拉取信息。特别地，TCP 连接由想要接收文件的机器发起。而 SMTP 主要是一个 <code class="docutils literal notranslate"><span class="pre">推送协议（push</span> <span class="pre">protocol）</span></code> —— 发送方邮件服务器将文件推送到接收方邮件服务器。特别地，TCP 连接由想要发送文件的机器发起。</p>
<p>第二个差异，我们之前已经提到，SMTP 要求每条消息（包括消息正文）必须为 7 位 ASCII 格式。如果消息包含非 7 位 ASCII 的字符（例如带重音符的法语字符）或包含二进制数据（如图像文件），则必须将消息编码为 7 位 ASCII。而 HTTP 数据不受此限制。</p>
<p>第三个重要差异与文本和图像（以及可能的其他媒体类型）组成的文档的处理方式有关。如我们在 <a class="reference internal" href="s2.html#c2-2"><span class="std std-ref">第 2.2 节</span></a> 中了解到的，HTTP 为每个对象封装一个独立的 HTTP 响应消息。而 SMTP 将所有消息对象放入一条消息中。</p>
<div class="toggle docutils container">
<p>Let’s now briefly compare SMTP with HTTP. Both protocols are used to transfer files from one host to another: HTTP transfers files (also called objects) from a Web server to a Web client (typically a browser); SMTP transfers files (that is, e-mail messages) from one mail server to another mail server. When transferring the files, both persistent HTTP and SMTP use persistent connections. Thus, the two protocols have common characteristics. However, there are important differences. First, HTTP is mainly a <code class="docutils literal notranslate"><span class="pre">pull</span> <span class="pre">protocol</span></code> — someone loads information on a Web server and users use HTTP to pull the information from the server at their convenience. In particular, the TCP connection is initiated by the machine that wants to receive the file. On the other hand, SMTP is primarily a <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">protocol</span></code> —the sending mail server pushes the file to the receiving mail server. In particular, the TCP connection is initiated by the machine that wants to send the file.</p>
<p>A second difference, which we alluded to earlier, is that SMTP requires each message, including the body of each message, to be in 7-bit ASCII format. If the message contains characters that are not 7-bit ASCII (for example, French characters with accents) or contains binary data (such as an image file), then the message has to be encoded into 7-bit ASCII. HTTP data does not impose this restriction.</p>
<p>A third important difference concerns how a document consisting of text and images (along with possibly
other media types) is handled. As we learned in <a class="reference internal" href="s2.html#c2-2"><span class="std std-ref">Section 2.2</span></a>, HTTP encapsulates each object in its own HTTP response message. SMTP places all of the message’s objects into one message.</p>
</div>
</section>
<section id="c2-3-3">
<span id="id4"></span><h2>2.3.3 邮件消息格式<a class="headerlink" href="#c2-3-3" title="此标题的永久链接">#</a></h2>
<p>2.3.3 Mail Message Formats</p>
<p>当 Alice 写一封普通的邮政邮件给 Bob 时，她可能在信的开头写上各种附加的头部信息，如 Bob 的地址、她自己的回信地址和日期。类似地，当一封电子邮件从一个人发送给另一个人时，在消息正文之前也会有一个包含附加信息的头部。此类附加信息包含在一系列头部行中，这些头部行定义在 <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a> 中。头部行与消息正文之间通过一个空行（即 <code class="docutils literal notranslate"><span class="pre">CRLF</span></code>）分隔。 <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a> 规定了邮件头部行的精确格式及其语义解释。与 HTTP 一样，每个头部行包含可读文本，由关键字、冒号以及对应值组成。其中一些关键字是必需的，另一些是可选的。每个头部必须包含一个 <code class="docutils literal notranslate"><span class="pre">From:</span></code> 行和一个 <code class="docutils literal notranslate"><span class="pre">To:</span></code> 行；头部还可以包含一个 <code class="docutils literal notranslate"><span class="pre">Subject:</span></code> 行以及其他可选的头部行。需要注意的是，这些头部行与我们在 <a class="reference internal" href="s4.html#c2-4-1"><span class="std std-ref">第 2.4.1 节</span></a> 中研究的 SMTP 命令是不同的（尽管它们包含一些相同的词，如 “from” 和 “to”）。该节中的命令属于 SMTP 握手协议的一部分；而本节中的头部行则是邮件消息本身的一部分。</p>
<p>一个典型的消息头如下所示：</p>
<div class="highlight-SMTP notranslate"><div class="highlight"><pre><span></span>From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.
</pre></div>
</div>
<p>在消息头之后是一个空行；随后是消息正文（以 ASCII 编码）。你应该使用 Telnet 向邮件服务器发送一条包含若干头部行（包括 <code class="docutils literal notranslate"><span class="pre">Subject:</span></code> 行）的消息。为此，请执行 <code class="docutils literal notranslate"><span class="pre">telnet</span> <span class="pre">serverName</span> <span class="pre">25</span></code>，具体方法如 <a class="reference internal" href="s4.html#c2-4-1"><span class="std std-ref">第 2.4.1 节</span></a> 中所述。</p>
<div class="toggle docutils container">
<p>When Alice writes an ordinary snail-mail letter to Bob, she may include all kinds of peripheral header information at the top of the letter, such as Bob’s address, her own return address, and the date. Similarly, when an e-mail message is sent from one person to another, a header containing peripheral information precedes the body of the message itself. This peripheral information is contained in a series of header lines, which are defined in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a>. The header lines and the body of the message are separated by a blank line (that is, by <code class="docutils literal notranslate"><span class="pre">CRLF</span></code>). <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a> specifies the exact format for mail header lines as well as their semantic interpretations. As with HTTP, each header line contains readable text, consisting of a keyword followed by a colon followed by a value. Some of the keywords are required and others are optional. Every header must have a <code class="docutils literal notranslate"><span class="pre">From:</span></code> header line and a <code class="docutils literal notranslate"><span class="pre">To:</span></code> header line; a header may include a <code class="docutils literal notranslate"><span class="pre">Subject:</span></code> header line as well as other optional header lines. It is important to note that these header lines are different from the SMTP commands we studied in <a class="reference internal" href="s4.html#c2-4-1"><span class="std std-ref">Section 2.4.1</span></a> (even though they contain some common words such as “from” and “to”). The commands in that section were part of the SMTP handshaking protocol; the header lines examined in this section are part of the mail message itself.</p>
<p>A typical message header looks like this:</p>
<div class="highlight-SMTP notranslate"><div class="highlight"><pre><span></span>From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.
</pre></div>
</div>
<p>After the message header, a blank line follows; then the message body (in ASCII) follows. You should use Telnet to send a message to a mail server that contains some header lines, including the <code class="docutils literal notranslate"><span class="pre">Subject:</span></code> header line. To do this, issue <code class="docutils literal notranslate"><span class="pre">telnet</span> <span class="pre">serverName</span> <span class="pre">25</span></code>, as discussed in <a class="reference internal" href="s4.html#c2-4-1"><span class="std std-ref">Section 2.4.1</span></a>.</p>
</div>
</section>
<section id="c2-3-4">
<span id="id5"></span><h2>2.3.4 邮件访问协议<a class="headerlink" href="#c2-3-4" title="此标题的永久链接">#</a></h2>
<p>2.3.4 Mail Access Protocols</p>
<p>一旦 SMTP 将消息从 Alice 的邮件服务器传输到 Bob 的邮件服务器，该消息就被放入 Bob 的邮箱中。在整个讨论过程中，我们默认为 Bob 通过登录服务器主机并执行在该主机上运行的邮件读取器来阅读他的邮件。直到 1990 年代初期，这是标准的做法。但如今，邮件访问采用了客户端-服务器架构——典型用户在自己的终端系统上（例如办公室电脑、笔记本电脑或智能手机）运行客户端程序来阅读电子邮件。通过在本地 PC 上运行邮件客户端，用户可以享受丰富的功能，包括查看多媒体消息和附件的能力。</p>
<p>既然 Bob（收件人）在其本地 PC 上执行用户代理，那么也可以考虑将一个邮件服务器放置在他的本地 PC 上。采用这种方式，Alice 的邮件服务器就可以直接与 Bob 的 PC 通信。然而，这种方式存在问题。请记住，邮件服务器管理邮箱，并运行 SMTP 的客户端和服务器端。如果 Bob 的邮件服务器位于其本地 PC 上，那么 Bob 的 PC 就必须始终保持开机并连接互联网，以便接收随时可能到达的新邮件。这对许多互联网用户来说并不现实。相反，典型用户在本地 PC 上运行用户代理，但访问存储在始终在线的共享邮件服务器中的邮箱。这个邮件服务器与其他用户共享，通常由用户的 ISP（例如大学或公司）维护。</p>
<p>现在让我们来看看当一封电子邮件从 Alice 发送给 Bob 时，它所经过的路径。我们刚刚了解到，在路径的某个点上，这封电子邮件需要被投递到 Bob 的邮件服务器。这可以通过让 Alice 的用户代理直接将邮件发送给 Bob 的邮件服务器来实现，并且可以使用 SMTP ——实际上，SMTP 就是为将电子邮件从一个主机推送到另一个主机而设计的。然而，通常情况下，发送方的用户代理不会直接与接收方的邮件服务器通信。如 <a class="reference internal" href="#figure-2-16"><span class="std std-ref">图 2.16</span></a> 所示，Alice 的用户代理使用 SMTP 将电子邮件推送到她的邮件服务器，然后 Alice 的邮件服务器作为 SMTP 客户端将邮件中继到 Bob 的邮件服务器。为什么要采用这个两步过程？主要是因为如果不通过 Alice 的邮件服务器中继，Alice 的用户代理就无法应对无法到达的目标邮件服务器。通过让 Alice 首先将电子邮件存入她自己的邮件服务器，Alice 的邮件服务器可以每隔 30 分钟尝试将消息发送给 Bob 的邮件服务器，直到 Bob 的邮件服务器恢复正常。（如果 Alice 的邮件服务器宕机，她还可以向系统管理员抱怨！）SMTP RFC 定义了如何使用 SMTP 命令在多个 SMTP 服务器之间中继消息。</p>
<figure class="align-center" id="figure-2-16">
<img alt="../_images/156-0.png" src="../_images/156-0.png" />
</figure>
<p><strong>图 2.16 电子邮件协议及其通信实体</strong></p>
<p>但谜题还缺少最后一块拼图！像 Bob 这样的收件人，在本地 PC 上运行用户代理，该如何获取存储在其 ISP 的邮件服务器中的消息呢？请注意，Bob 的用户代理无法使用 SMTP 获取邮件，因为获取消息是拉取操作，而 SMTP 是推送协议。这个问题通过引入一种特殊的邮件访问协议来完成拼图，该协议将消息从 Bob 的邮件服务器传输到其本地 PC。目前流行的邮件访问协议包括 Post <strong>Office Protocol—Version 3 (POP3)</strong>、 <strong>Internet Mail Access Protocol (IMAP)</strong> 和 HTTP。</p>
<p><a class="reference internal" href="#figure-2-16"><span class="std std-ref">图 2.16</span></a> 总结了用于互联网邮件的协议：SMTP 用于将邮件从发送者的邮件服务器传输到接收者的邮件服务器；SMTP 也用于将邮件从发送者的用户代理传输到发送者的邮件服务器。诸如 POP3 的邮件访问协议，用于将邮件从接收者的邮件服务器传输到接收者的用户代理。</p>
<div class="toggle docutils container">
<p>Once SMTP delivers the message from Alice’s mail server to Bob’s mail server, the message is placed in Bob’s mailbox. Throughout this discussion we have tacitly assumed that Bob reads his mail by logging onto the server host and then executing a mail reader that runs on that host. Up until the early 1990s this was the standard way of doing things. But today, mail access uses a client-server architecture—the typical user reads e-mail with a client that executes on the user’s end system, for example, on an office PC, a laptop, or a smartphone. By executing a mail client on a local PC, users enjoy a rich set of features, including the ability to view multimedia messages and attachments.</p>
<p>Given that Bob (the recipient) executes his user agent on his local PC, it is natural to consider placing a mail server on his local PC as well. With this approach, Alice’s mail server would dialogue directly with Bob’s PC. There is a problem with this approach, however. Recall that a mail server manages mailboxes and runs the client and server sides of SMTP. If Bob’s mail server were to reside on his local PC, then Bob’s PC would have to remain always on, and connected to the Internet, in order to receive new mail, which can arrive at any time. This is impractical for many Internet users. Instead, a typical user runs a user agent on the local PC but accesses its mailbox stored on an always-on shared mail server. This mail server is shared with other users and is typically maintained by the user’s ISP (for example, university or company).</p>
<p>Now let’s consider the path an e-mail message takes when it is sent from Alice to Bob. We just learned that at some point along the path the e-mail message needs to be deposited in Bob’s mail server. This could be done simply by having Alice’s user agent send the message directly to Bob’s mail server. and this could be done with SMTP—indeed, SMTP has been designed for pushing e-mail from one host to another. However, typically the sender’s user agent does not dialogue directly with the recipient’s mail server. Instead, as shown in <a class="reference internal" href="#figure-2-16"><span class="std std-ref">Figure 2.16</span></a>, Alice’s user agent uses SMTP to push the e-mail message into her mail server, then Alice’s mail server uses SMTP (as an SMTP client) to relay the e-mail message to Bob’s mail server. Why the two-step procedure? Primarily because without relaying through Alice’s mail server, Alice’s user agent doesn’t have any recourse to an unreachable destination mail server. By having Alice first deposit the e-mail in her own mail server, Alice’s mail server can repeatedly try to send the message to Bob’s mail server, say every 30 minutes, until Bob’s mail server becomes operational. (And if Alice’s mail server is down, then she has the recourse of complaining to her system administrator!) The SMTP RFC defines how the SMTP commands can be used to relay a message across multiple SMTP servers.</p>
<figure class="align-center">
<img alt="../_images/156-0.png" src="../_images/156-0.png" />
</figure>
<p><strong>Figure 2.16 E-mail protocols and their communicating entities</strong></p>
<p>But there is still one missing piece to the puzzle! How does a recipient like Bob, running a user agent on his local PC, obtain his messages, which are sitting in a mail server within Bob’s ISP? Note that Bob’s user agent can’t use SMTP to obtain the messages because obtaining the messages is a pull operation, whereas SMTP is a push protocol. The puzzle is completed by introducing a special mail access protocol that transfers messages from Bob’s mail server to his local PC. There are currently a number of popular mail access protocols, including Post <strong>Office Protocol—Version 3 (POP3)</strong>, <strong>Internet Mail Access Protocol (IMAP)</strong>, and HTTP.</p>
<p><a class="reference internal" href="#figure-2-16"><span class="std std-ref">Figure 2.16</span></a> provides a summary of the protocols that are used for Internet mail: SMTP is used to transfer mail from the sender’s mail server to the recipient’s mail server; SMTP is also used to transfer mail from the sender’s user agent to the sender’s mail server. A mail access protocol, such as POP3, is used to transfer mail from the recipient’s mail server to the recipient’s user agent.</p>
</div>
<section id="pop3">
<h3>POP3<a class="headerlink" href="#pop3" title="此标题的永久链接">#</a></h3>
<p>POP3 是一种极其简单的邮件访问协议。其定义见 <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1939.html"><strong>RFC 1939</strong></a>，该 RFC 简短且易读。由于协议非常简单，其功能也相当有限。POP3 会在用户代理（客户端）打开到邮件服务器（服务器）110 端口的 TCP 连接时启动。在建立 TCP 连接后，POP3 会经历三个阶段：授权、事务和更新。在第一个阶段 —— 授权阶段，用户代理发送用户名和密码（明文）来认证用户。在第二阶段 —— 事务阶段，用户代理检索消息；在此阶段，用户代理还可以标记消息为删除、移除删除标记以及获取邮件统计信息。第三阶段 —— 更新阶段，在客户端发出 <code class="docutils literal notranslate"><span class="pre">quit</span></code> 命令并结束 POP3 会话后进行；此时，邮件服务器会删除所有被标记为删除的消息。</p>
<p>在 POP3 的一次事务中，用户代理发出命令，服务器对每个命令作出响应。可能的响应有两种： <code class="docutils literal notranslate"><span class="pre">+OK</span></code> （有时后接从服务器到客户端的数据），表示前一个命令正常；<code class="docutils literal notranslate"><span class="pre">-ERR</span></code>，表示前一个命令出错。</p>
<p>授权阶段有两个主要命令： <code class="docutils literal notranslate"><span class="pre">user</span> <span class="pre">&lt;username&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pass</span> <span class="pre">&lt;password&gt;</span></code>。为了说明这两个命令，建议你直接使用 Telnet 连接到 POP3 服务器，端口号为 110，并发出这些命令。假设 <code class="docutils literal notranslate"><span class="pre">mailServer</span></code> 是你的邮件服务器名称。你会看到类似如下输出：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">telnet</span> <span class="n">mailServer</span> <span class="mi">110</span>
<span class="o">+</span><span class="n">OK</span> <span class="n">POP3</span> <span class="n">server</span> <span class="n">ready</span>
<span class="n">user</span> <span class="n">bob</span>
<span class="o">+</span><span class="n">OK</span>
<span class="k">pass</span> <span class="n">hungry</span>
<span class="o">+</span><span class="n">OK</span> <span class="n">user</span> <span class="n">successfully</span> <span class="n">logged</span> <span class="n">on</span>
</pre></div>
</div>
<p>如果你拼写错误某个命令，POP3 服务器将返回 <code class="docutils literal notranslate"><span class="pre">-ERR</span></code> 消息。</p>
<p>现在我们来看事务阶段。使用 POP3 的用户代理通常可以配置为“下载并删除”或“下载并保留”。POP3 用户代理发出的命令序列取决于其工作模式。在下载并删除模式中，用户代理将发出 <code class="docutils literal notranslate"><span class="pre">list</span></code>、<code class="docutils literal notranslate"><span class="pre">retr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dele</span></code> 命令。例如，假设用户邮箱中有两条消息。以下对话中， <code class="docutils literal notranslate"><span class="pre">C:</span></code> （客户端）为用户代理， <code class="docutils literal notranslate"><span class="pre">S:</span></code> （服务器）为邮件服务器。事务过程可能如下所示：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span> <span class="nb">list</span>
<span class="n">S</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">498</span>
<span class="n">S</span><span class="p">:</span> <span class="mi">2</span> <span class="mi">912</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.</span>
<span class="n">C</span><span class="p">:</span> <span class="n">retr</span> <span class="mi">1</span>
<span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="n">blah</span> <span class="n">blah</span> <span class="o">...</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.................</span>
<span class="n">S</span><span class="p">:</span> <span class="o">..........</span><span class="n">blah</span><span class="p">)</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.</span>
<span class="n">C</span><span class="p">:</span> <span class="n">dele</span> <span class="mi">1</span>
<span class="n">C</span><span class="p">:</span> <span class="n">retr</span> <span class="mi">2</span>
<span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="n">blah</span> <span class="n">blah</span> <span class="o">...</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.................</span>
<span class="n">S</span><span class="p">:</span> <span class="o">..........</span><span class="n">blah</span><span class="p">)</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.</span>
<span class="n">C</span><span class="p">:</span> <span class="n">dele</span> <span class="mi">2</span>
<span class="n">C</span><span class="p">:</span> <span class="n">quit</span>
<span class="n">S</span><span class="p">:</span> <span class="o">+</span><span class="n">OK</span> <span class="n">POP3</span> <span class="n">server</span> <span class="n">signing</span> <span class="n">off</span>
</pre></div>
</div>
<p>用户代理首先请求邮件服务器列出每条已存储消息的大小。然后用户代理检索并删除每条消息。请注意，在授权阶段之后，用户代理仅使用了四个命令： <code class="docutils literal notranslate"><span class="pre">list</span></code>、 <code class="docutils literal notranslate"><span class="pre">retr</span></code>、 <code class="docutils literal notranslate"><span class="pre">dele</span></code> 和 <code class="docutils literal notranslate"><span class="pre">quit</span></code>。这些命令的语法在 <span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1939.html"><strong>RFC 1939</strong></a> 中有定义。处理完 quit 命令后，POP3 服务器进入更新阶段，并从邮箱中移除消息 1 和 2。</p>
<p>该下载并删除模式的问题在于收件人 Bob 可能是个游牧用户，可能希望从多台设备上访问邮件，例如他的办公电脑、家用电脑和便携设备。下载并删除模式会将 Bob 的邮件分散在这三台机器上；特别是，如果 Bob 首先在办公室电脑上阅读了某封邮件，他晚上回家后就无法再在便携设备上阅读该邮件了。而在下载并保留模式中，用户代理在下载邮件后保留服务器上的副本。这样 Bob 就可以从不同的设备上重复阅读邮件；他可以在工作时阅读一封邮件，然后在周末从家里再次访问。</p>
<p>在用户代理与邮件服务器之间的 POP3 会话期间，POP3 服务器会维护一些状态信息；尤其是，它会记录哪些用户邮件被标记为删除。然而，POP3 服务器不会在多个会话之间保留状态信息。这种跨会话无状态的特性极大地简化了 POP3 服务器的实现。</p>
<div class="toggle docutils container">
<p>POP3 is an extremely simple mail access protocol. It is defined in <a class="reference internal" href="../references.html#rfc-1939"><span class="std std-ref">[RFC 1939]</span></a> , which is short and quite readable. Because the protocol is so simple, its functionality is rather limited. POP3 begins when the user agent (the client) opens a TCP connection to the mail server (the server) on port 110. With the TCP connection established, POP3 progresses through three phases: authorization, transaction, and update. During the first phase, authorization, the user agent sends a username and a password (in the clear) to authenticate the user. During the second phase, transaction, the user agent retrieves messages; also during this phase, the user agent can mark messages for deletion, remove deletion marks, and obtain mail statistics. The third phase, update, occurs after the client has issued the <code class="docutils literal notranslate"><span class="pre">quit</span></code> command, ending the POP3 session; at this time, the mail server deletes the messages that were marked for deletion.</p>
<p>In a POP3 transaction, the user agent issues commands, and the server responds to each command with a reply. There are two possible responses: <code class="docutils literal notranslate"><span class="pre">+OK</span></code> (sometimes followed by server-to-client data), used by the server to indicate that the previous command was fine; and <code class="docutils literal notranslate"><span class="pre">-ERR</span></code>, used by the server to indicate that something was wrong with the previous command.</p>
<p>The authorization phase has two principal commands: <code class="docutils literal notranslate"><span class="pre">user</span> <span class="pre">&lt;username&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">pass</span> <span class="pre">&lt;password&gt;</span></code>. To illustrate these two commands, we suggest that you Telnet directly into a POP3 server, using port 110, and issue these commands. Suppose that <code class="docutils literal notranslate"><span class="pre">mailServer</span></code> is the name of your mail server. You will see something like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">telnet</span> <span class="n">mailServer</span> <span class="mi">110</span>
<span class="o">+</span><span class="n">OK</span> <span class="n">POP3</span> <span class="n">server</span> <span class="n">ready</span>
<span class="n">user</span> <span class="n">bob</span>
<span class="o">+</span><span class="n">OK</span>
<span class="k">pass</span> <span class="n">hungry</span>
<span class="o">+</span><span class="n">OK</span> <span class="n">user</span> <span class="n">successfully</span> <span class="n">logged</span> <span class="n">on</span>
</pre></div>
</div>
<p>If you misspell a command, the POP3 server will reply with an <code class="docutils literal notranslate"><span class="pre">-ERR</span></code> message.</p>
<p>Now let’s take a look at the transaction phase. A user agent using POP3 can often be configured (by the user) to “download and delete” or to “download and keep.” The sequence of commands issued by a POP3 user agent depends on which of these two modes the user agent is operating in. In the download-and-delete mode, the user agent will issue the <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">retr</span></code>, and <code class="docutils literal notranslate"><span class="pre">dele</span></code> commands. As an example, suppose the user has two messages in his or her mailbox. In the dialogue below, <code class="docutils literal notranslate"><span class="pre">C:</span></code> (standing for client) is the user agent and <code class="docutils literal notranslate"><span class="pre">S:</span></code> (standing for server) is the mail server. The transaction will look something like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span> <span class="nb">list</span>
<span class="n">S</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">498</span>
<span class="n">S</span><span class="p">:</span> <span class="mi">2</span> <span class="mi">912</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.</span>
<span class="n">C</span><span class="p">:</span> <span class="n">retr</span> <span class="mi">1</span>
<span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="n">blah</span> <span class="n">blah</span> <span class="o">...</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.................</span>
<span class="n">S</span><span class="p">:</span> <span class="o">..........</span><span class="n">blah</span><span class="p">)</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.</span>
<span class="n">C</span><span class="p">:</span> <span class="n">dele</span> <span class="mi">1</span>
<span class="n">C</span><span class="p">:</span> <span class="n">retr</span> <span class="mi">2</span>
<span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="n">blah</span> <span class="n">blah</span> <span class="o">...</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.................</span>
<span class="n">S</span><span class="p">:</span> <span class="o">..........</span><span class="n">blah</span><span class="p">)</span>
<span class="n">S</span><span class="p">:</span> <span class="o">.</span>
<span class="n">C</span><span class="p">:</span> <span class="n">dele</span> <span class="mi">2</span>
<span class="n">C</span><span class="p">:</span> <span class="n">quit</span>
<span class="n">S</span><span class="p">:</span> <span class="o">+</span><span class="n">OK</span> <span class="n">POP3</span> <span class="n">server</span> <span class="n">signing</span> <span class="n">off</span>
</pre></div>
</div>
<p>The user agent first asks the mail server to list the size of each of the stored messages. The user agent then retrieves and deletes each message from the server. Note that after the authorization phase, the
user agent employed only four commands: <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">retr</span></code>, <code class="docutils literal notranslate"><span class="pre">dele</span></code>, and <code class="docutils literal notranslate"><span class="pre">quit</span></code>. The syntax for these commands is defined in RFC 1939. After processing the quit command, the POP3 server enters the
update phase and removes messages 1 and 2 from the mailbox.</p>
<p>A problem with this download-and-delete mode is that the recipient, Bob, may be nomadic and may want to access his mail messages from multiple machines, for example, his office PC, his home PC, and his portable computer. The download-and-delete mode partitions Bob’s mail messages over these three machines; in particular, if Bob first reads a message on his office PC, he will not be able to reread the message from his portable at home later in the evening. In the download-and-keep mode, the user agent leaves the messages on the mail server after downloading them. In this case, Bob can reread messages from different machines; he can access a message from work and access it again later in the week from home.</p>
<p>During a POP3 session between a user agent and the mail server, the POP3 server maintains some state information; in particular, it keeps track of which user messages have been marked deleted. However, the POP3 server does not carry state information across POP3 sessions. This lack of state information across sessions greatly simplifies the implementation of a POP3 server.</p>
</div>
</section>
<section id="imap">
<h3>IMAP<a class="headerlink" href="#imap" title="此标题的永久链接">#</a></h3>
<p>使用 POP3 访问时，一旦 Bob 将邮件下载到本地机器，他可以创建邮件文件夹并将已下载的邮件移动到这些文件夹中。Bob 然后可以删除邮件、在文件夹之间移动邮件，或按发件人姓名或主题搜索邮件。但这种“文件夹和本地机器上的邮件”的模式对游牧用户来说是个问题，他们更希望在远程服务器上维护一个文件夹结构，以便可以从任何计算机访问。这在 POP3 中是不可能的 —— POP3 协议不提供创建远程文件夹并将消息分配给文件夹的能力。</p>
<p>为了解决这个问题以及其他问题，IMAP 协议被设计出来，其定义见 <span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3501.html"><strong>RFC 3501</strong></a>。与 POP3 一样，IMAP 是一种邮件访问协议。它具有比 POP3 更多的功能，但也显著更复杂。（因此客户端和服务器端的实现也复杂得多。）</p>
<p>IMAP 服务器会将每条消息关联到一个文件夹；当消息首次到达服务器时，它被关联到收件人的 INBOX 文件夹。收件人随后可以将消息移动到用户创建的新文件夹中、读取消息、删除消息，等等。IMAP 协议提供命令，允许用户创建文件夹并在文件夹之间移动消息。IMAP 还提供命令，允许用户在远程文件夹中搜索满足特定条件的消息。请注意，与 POP3 不同，IMAP 服务器在多个 IMAP 会话之间维护用户状态信息 —— 例如文件夹名称及哪些消息属于哪些文件夹。</p>
<p>IMAP 的另一个重要特性是，它支持一些命令，允许用户代理仅获取消息的一部分。例如，用户代理可以仅获取消息头，或仅获取一个多部分 MIME 消息中的某一部分。当用户代理与邮件服务器之间的连接带宽较低（例如低速调制解调器连接）时，此功能非常有用。带宽受限时，用户可能不希望下载邮箱中所有邮件，尤其是不愿意下载那些可能包含音频或视频片段的长消息。</p>
<div class="toggle docutils container">
<p>With POP3 access, once Bob has downloaded his messages to the local machine, he can create mail folders and move the downloaded messages into the folders. Bob can then delete messages, move messages across folders, and search for messages (by sender name or subject). But this paradigm— namely, folders and messages in the local machine—poses a problem for the nomadic user, who would prefer to maintain a folder hierarchy on a remote server that can be accessed from any computer. This is not possible with POP3—the POP3 protocol does not provide any means for a user to create remote folders and assign messages to folders.
To solve this and other problems, the IMAP protocol, defined in <a class="reference internal" href="../references.html#rfc-3501"><span class="std std-ref">[RFC 3501]</span></a>, was invented. Like POP3, IMAP is a mail access protocol. It has many more features than POP3, but it is also significantly more complex. (And thus the client and server side implementations are significantly more complex.)</p>
<p>An IMAP server will associate each message with a folder; when a message first arrives at the server, it is associated with the recipient’s INBOX folder. The recipient can then move the message into a new, user-created folder, read the message, delete the message, and so on. The IMAP protocol provides commands to allow users to create folders and move messages from one folder to another. IMAP also provides commands that allow users to search remote folders for messages matching specific criteria. Note that, unlike POP3, an IMAP server maintains user state information across IMAP sessions—for example, the names of the folders and which messages are associated with which folders.</p>
<p>Another important feature of IMAP is that it has commands that permit a user agent to obtain components of messages. For example, a user agent can obtain just the message header of a message or just one part of a multipart MIME message. This feature is useful when there is a low-bandwidth connection (for example, a slow-speed modem link) between the user agent and its mail server. With a low-bandwidth connection, the user may not want to download all of the messages in its mailbox, particularly avoiding long messages that might contain, for example, an audio or video clip.</p>
</div>
</section>
<section id="web">
<h3>基于 Web 的电子邮件<a class="headerlink" href="#web" title="此标题的永久链接">#</a></h3>
<p>Web-Based E-Mail</p>
<p>如今，越来越多的用户通过 Web 浏览器发送和访问电子邮件。Hotmail 在 1990 年代中期首次引入了基于 Web 的访问。现在，Google、Yahoo! 以及几乎所有大学和大型公司都提供基于 Web 的电子邮件服务。使用这种服务时，用户代理是一个普通的 Web 浏览器，用户通过 HTTP 与远程邮箱通信。当收件人（如 Bob）想访问其邮箱中的邮件时，电子邮件是通过 HTTP 协议从 Bob 的邮件服务器发送到 Bob 的浏览器，而不是使用 POP3 或 IMAP 协议。当发件人（如 Alice）想发送邮件时，电子邮件是通过 HTTP 从她的浏览器发送到她的邮件服务器，而不是通过 SMTP。然而，Alice 的邮件服务器仍然使用 SMTP 向其他邮件服务器发送消息，并从它们接收消息。</p>
<div class="toggle docutils container">
<p>More and more users today are sending and accessing their e-mail through their Web browsers. Hotmail introduced Web-based access in the mid 1990s. Now Web-based e-mail is also provided by Google, Yahoo!, as well as just about every major university and corporation. With this service, the user agent is an ordinary Web browser, and the user communicates with its remote mailbox via HTTP. When a recipient, such as Bob, wants to access a message in his mailbox, the e-mail message is sent from Bob’s mail server to Bob’s browser using the HTTP protocol rather than the POP3 or IMAP protocol. When a sender, such as Alice, wants to send an e-mail message, the e-mail message is sent from her browser to her mail server over HTTP rather than over SMTP. Alice’s mail server, however, still sends messages to, and receives messages from, other mail servers using SMTP.</p>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="s2.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">2.2 Web 与 HTTP</p>
      </div>
    </a>
    <a class="right-next"
       href="s4.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">2.4 DNS——互联网的目录服务</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#smtp">2.3.1 SMTP</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#http">2.3.2 与 HTTP 的对比</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-3-3">2.3.3 邮件消息格式</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-3-4">2.3.4 邮件访问协议</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pop3">POP3</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#imap">IMAP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#web">基于 Web 的电子邮件</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>