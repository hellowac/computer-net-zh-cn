

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>2.5 对等网络应用 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c2/s5';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="2.6 视频流与内容分发" href="s6.html" />
    <link rel="prev" title="2.4 DNS——互联网的目录服务" href="s4.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 2 章 应用层</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="s3.html">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2"><a class="reference internal" href="s4.html">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c4/index.html">第 4 章 网络层：数据平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c4/s1.html">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c6/index.html">第 6 章 链路层与局域网（LANs）</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c6/s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s2.html">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c8/index.html">第 8 章 计算机网络中的安全</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c8/s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s2.html">8.2 密码学原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s3.html">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c9/index.html">第 9 章 多媒体网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c9/s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s2.html">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c2/s5.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>2.5 对等网络应用</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#p2p">2.5.1 P2P 文件分发</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">P2P 架构的可扩展性</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bittorrent">BitTorrent</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="c2-5">
<span id="id1"></span><h1>2.5 对等网络应用<a class="headerlink" href="#c2-5" title="此标题的永久链接">#</a></h1>
<p>2.5 Peer-to-Peer Applications</p>
<p>到目前为止，本章描述的应用程序——包括 Web、电子邮件和 DNS——都采用了客户端-服务器架构，并在很大程度上依赖于始终在线的基础设施服务器。回顾 <a class="reference internal" href="s1.html#c2-1-1"><span class="std std-ref">第 2.1.1 节</span></a>，在 P2P 架构中，几乎不依赖（或完全不依赖）始终在线的基础设施服务器。相反，一对一的间歇连接主机（称为对等方，peers）彼此直接通信。这些对等方不属于某个服务提供商，而是由用户控制的桌面电脑和笔记本电脑。</p>
<p>在本节中，我们将探讨一种非常自然的 P2P 应用，即将一个大文件从单个服务器分发到大量主机（称为对等方）。该文件可能是 Linux 操作系统的新版本、某个操作系统或应用程序的软件补丁、一个 MP3 音乐文件或 MPEG 视频文件。在客户端-服务器文件分发中，服务器必须向每个对等方发送一份文件副本——这给服务器带来了巨大的负担，并消耗了大量带宽。而在 P2P 文件分发中，每个对等方都可以将其接收到的文件部分重新分发给其他对等方，从而协助服务器完成分发任务。截至 2016 年，最流行的 P2P 文件分发协议是 BitTorrent。该协议最初由 Bram Cohen 开发，如今已出现许多符合 BitTorrent 协议的独立客户端，正如有许多符合 HTTP 协议的 Web 浏览器客户端一样。在本小节中，我们首先分析 P2P 架构在文件分发场景中的自我可扩展性（self-scalability），然后对 BitTorrent 协议做详细介绍，突出其最重要的特性与机制。</p>
<div class="toggle docutils container">
<p>The applications described in this chapter thus far—including the Web, e-mail, and DNS—all employ client-server architectures with significant reliance on always-on infrastructure servers. Recall from <a class="reference internal" href="s1.html#c2-1-1"><span class="std std-ref">Section 2.1.1</span></a> that with a P2P architecture, there is minimal (or no) reliance on always-on infrastructure servers. Instead, pairs of intermittently connected hosts, called peers, communicate directly with each other. The peers are not owned by a service provider, but are instead desktops and laptops controlled by users.</p>
<p>In this section we consider a very natural P2P application, namely, distributing a large file from a single server to a large number of hosts (called peers). The file might be a new version of the Linux operating system, a software patch for an existing operating system or application, an MP3 music file, or an MPEG video file. In client-server file distribution, the server must send a copy of the file to each of the peers—placing an enormous burden on the server and consuming a large amount of server bandwidth. In P2P file distribution, each peer can redistribute any portion of the file it has received to any other peers, thereby assisting the server in the distribution process. As of 2016, the most popular P2P file distribution protocol is BitTorrent. Originally developed by Bram Cohen, there are now many different independent BitTorrent clients conforming to the BitTorrent protocol, just as there are a number of Web browser clients that conform to the HTTP protocol. In this subsection, we first examine the self- scalability of P2P architectures in the context of file distribution. We then describe BitTorrent in some detail, highlighting its most important characteristics and features.</p>
</div>
<section id="p2p">
<span id="c2-5-1"></span><h2>2.5.1 P2P 文件分发<a class="headerlink" href="#p2p" title="此标题的永久链接">#</a></h2>
<p>2.5.1 P2P File Distribution</p>
<section id="id2">
<h3>P2P 架构的可扩展性<a class="headerlink" href="#id2" title="此标题的永久链接">#</a></h3>
<p>Scalability of P2P Architectures</p>
<p>为比较客户端-服务器架构和对等网络架构，并说明 P2P 的内在自我可扩展性，我们现在为这两种架构建立一个用于将文件分发到固定对等方集合的简单定量模型。如 <span class="xref std std-ref">图 2.22</span> 所示，服务器和对等方通过接入链路连接到互联网。设服务器接入链路的上传速率为 us，第 i 个对等方接入链路的上传速率为 ui，下载速率为 di。设要分发的文件大小为 F（以比特计），希望获得文件副本的对等方数量为 N。 <strong>分发时间</strong> 指的是将文件副本传送给所有 N 个对等方所需的时间。在下面对这两种架构分发时间的分析中，我们做一个简化（但通常准确 <a class="reference internal" href="../references.html#akella-2003"><span class="std std-ref">[Akella 2003]</span></a>) 假设，即互联网核心拥有充足的带宽，意味着所有瓶颈都在接入网络中。我们还假设服务器和客户端不参与任何其他网络应用，因此他们所有的上传与下载接入带宽都可以完全用于文件分发。</p>
<figure class="align-center" id="id3">
<img alt="../_images/176-0.png" src="../_images/176-0.png" />
</figure>
<p><strong>图 2.22 文件分发问题示意图</strong></p>
<p>首先来确定客户端-服务器架构的分发时间，记为 Dcs。在客户端-服务器架构中，没有对等方参与文件分发。我们做出以下观察：</p>
<ul class="simple">
<li><p>服务器必须向每个对等方传输一份文件，因此服务器需要传输 NF 比特。由于服务器上传速率为 us，因此文件分发时间至少为 <span class="math notranslate nohighlight">\(NF/u_s\)</span>。</p></li>
<li><p>设 <span class="math notranslate nohighlight">\(d_{min}\)</span> 表示下载速率最慢的对等方，即 <span class="math notranslate nohighlight">\(dmin=min{d_1,d_2,. . .,d_N}\)</span>。下载速率最慢的对等方获取完整文件（F 比特）所需时间至少为 <span class="math notranslate nohighlight">\(F/d_{min}\)</span> 秒。因此最小分发时间至少为 <span class="math notranslate nohighlight">\(F/d_{min}\)</span>。</p></li>
</ul>
<p>将上述两条观察合并，我们得到：</p>
<blockquote>
<div><p>Dcs≥max{NFus,Fdmin}.</p>
</div></blockquote>
<p>这就为客户端-服务器架构的最小分发时间提供了一个下界。在作业中你将被要求证明服务器可以安排其传输使该下界确实达到。因此，我们将上述下界作为实际分发时间，即：</p>
<div class="math notranslate nohighlight" id="equation-2-1">
<span class="eqno">(1)<a class="headerlink" href="#equation-2-1" title="此公式的永久链接">#</a></span>\[ Dcs≥max{NFus,Fdmin}.\]</div>
<p>由 <a class="reference internal" href="#equation-2-1">(1)</a> 可见，当 N 足够大时，客户端-服务器的分发时间为 NF/us。因此，分发时间随对等方数量 N 线性增长。例如，如果某一周对等方数量从 1,000 增加到 1,000,000，所需分发时间将增长 1,000 倍。</p>
<p>现在我们对 P2P 架构进行类似分析，在该架构中，每个对等方都可以协助服务器分发文件。具体来说，当对等方接收到部分文件后，可利用自身上传能力将数据重新分发给其他对等方。由于分发时间依赖于每个对等方如何将文件部分传递给其他对等方，P2P 架构的分发时间计算比客户端-服务器架构复杂。但依然可以得到一个简单的最小分发时间表达式 <a class="reference internal" href="../references.html#kumar-2006"><span class="std std-ref">[Kumar 2006]</span></a>。为此，我们做出以下观察：</p>
<ul class="simple">
<li><p>分发开始时，只有服务器拥有完整文件。要将该文件引入对等方群体中，服务器必须至少一次将每一比特送入其接入链路。因此，最小分发时间至少为 <em>F/us</em>。（不同于客户端-服务器方式，服务器发出的一比特不必再发送一次，因为对等方可彼此重新分发该比特。）</p></li>
<li><p>与客户端-服务器架构一样，下载速率最慢的对等方无法在少于 <span class="math notranslate nohighlight">\(F/d_{min}\)</span> 秒内获取完整文件。因此最小分发时间至少为 <span class="math notranslate nohighlight">\(F/d_{min}\)</span>。</p></li>
<li><p>最后，系统的总上传能力为服务器上传速率加上每个对等方的上传速率，即 utotal=us+u1+⋯+uN。系统必须向 N 个对等方分发（上传） F 比特，总传输量为 NF 比特。该过程所需时间不可能少于 <span class="math notranslate nohighlight">\(NF/u_{total}\)</span>。因此，最小分发时间还至少为 NF/(us+u1+⋯+uN)。</p></li>
</ul>
<p>将这三条观察合并，得到 P2P 的最小分发时间，记作 <span class="math notranslate nohighlight">\(D_{P2P}\)</span>：</p>
<div class="math notranslate nohighlight" id="equation-2-2">
<span class="eqno">(2)<a class="headerlink" href="#equation-2-2" title="此公式的永久链接">#</a></span>\[DP2P ≥ max{Fus,Fdmin,NFus+∑i=1Nui}\]</div>
<p><a class="reference internal" href="#equation-2-2">(2)</a> 给出了 P2P 架构的最小分发时间下界。实际上，如果我们设想每个对等方在接收到比特后即可重新分发，则存在一种分发策略可达成此下界 <a class="reference internal" href="../references.html#kumar-2006"><span class="std std-ref">[Kumar 2006]</span></a>。（我们将在作业中证明该结论的特例。）现实中文件是按块（chunk）分发，而不是逐比特，<a class="reference internal" href="#equation-2-2">(2)</a> 是实际最小分发时间的良好近似。因此我们将其作为实际最小分发时间，即：</p>
<div class="math notranslate nohighlight" id="equation-2-3">
<span class="eqno">(3)<a class="headerlink" href="#equation-2-3" title="此公式的永久链接">#</a></span>\[ DP2P=max{Fus,Fdmin,NFus+∑i=1Nui}\]</div>
<p><a class="reference internal" href="#id4"><span class="std std-ref">图 2.23</span></a> 对比了客户端-服务器架构和 P2P 架构的最小分发时间，假设所有对等方上传速率均为 u。在 <a class="reference internal" href="#id4"><span class="std std-ref">图 2.23</span></a> 中，我们设 F/u=1 小时，us=10u，且 dmin≥us。即：对等方可在一小时内传输整个文件，服务器传输速率是对等方的 10 倍，并设下载速率足够高，不构成瓶颈。可见：在客户端-服务器架构中，分发时间随对等方数量线性增长且无上限。而在 P2P 架构中，最小分发时间不仅总是小于客户端-服务器架构的分发时间，而且在任意对等方数量 N 下均小于 1 小时。因此，采用 P2P 架构的应用具备自我扩展能力。这种可扩展性直接得益于对等方既是比特的消费者，也是分发者。</p>
<figure class="align-center" id="id4">
<img alt="../_images/178-0.png" src="../_images/178-0.png" />
</figure>
<p><strong>图 2.23 P2P 与客户端-服务器架构的分发时间</strong></p>
<div class="toggle docutils container">
<p>To compare client-server architectures with peer-to-peer architectures, and illustrate the inherent self- scalability of P2P, we now consider a simple quantitative model for distributing a file to a fixed set of peers for both architecture types. As shown in <span class="xref std std-ref">Figure 2.22</span>, the server and the peers are connected to the Internet with access links. Denote the upload rate of the server’s access link by us, the upload rate of the ith peer’s access link by ui, and the download rate of the ith peer’s access link by di. Also denote the size of the file to be distributed (in bits) by F and the number of peers that want to obtain a copy of the file by N. The <strong>distribution time</strong> is the time it takes to get a copy of the file to all N peers. In our analysis of the distribution time below, for both client-server and P2P architectures, we make the simplifying (and generally accurate <a class="reference internal" href="../references.html#akella-2003"><span class="std std-ref">[Akella 2003]</span></a>) assumption that the Internet core has abundant bandwidth, implying that all of the bottlenecks are in access networks. We also suppose that the server and clients are not participating in any other network applications, so that all of their upload and download access bandwidth can be fully devoted to distributing this file.</p>
<figure class="align-center" id="figure-2-22">
<img alt="../_images/176-0.png" src="../_images/176-0.png" />
</figure>
<p><strong>Figure 2.22 An illustrative file distribution problem</strong></p>
<p>Let’s first determine the distribution time for the client-server architecture, which we denote by Dcs. In the client-server architecture, none of the peers aids in distributing the file. We make the following observations:</p>
<ul class="simple">
<li><p>The server must transmit one copy of the file to each of the N peers. Thus the server must transmit NF bits. Since the server’s upload rate is us, the time to distribute the file must be at least <span class="math notranslate nohighlight">\(NF/u_s\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(d_{min}\)</span> denote the download rate of the peer with the lowest download rate, that is, <span class="math notranslate nohighlight">\(dmin=min{d_1,d_p,. . .,d_N}\)</span>. The peer with the lowest download rate cannot obtain all <em>F</em> bits of the file in less than <span class="math notranslate nohighlight">\(F/d_{min}\)</span> seconds. Thus the minimum distribution time is at least <span class="math notranslate nohighlight">\(F/d_{min}\)</span>.</p></li>
</ul>
<p>Putting these two observations together, we obtain</p>
<blockquote>
<div><p>Dcs≥max{NFus,Fdmin}.</p>
</div></blockquote>
<p>This provides a lower bound on the minimum distribution time for the client-server architecture. In the homework problems you will be asked to show that the server can schedule its transmissions so that the lower bound is actually achieved. So let’s take this lower bound provided above as the actual distribution time, that is,</p>
<blockquote id="id5">
<div><p>Dcs≥max{NFus,Fdmin}.                                        (2.1)</p>
</div></blockquote>
<p>We see from <a class="reference internal" href="#id5"><span class="std std-ref">Equation 2.1</span></a> that for N large enough, the client-server distribution time is given by NF/us. Thus, the distribution time increases linearly with the number of peers N. So, for example, if the number of peers from one week to the next increases a thousand-fold from a thousand to a million, the time required to distribute the file to all peers increases by 1,000.</p>
<p>Let’s now go through a similar analysis for the P2P architecture, where each peer can assist the server in distributing the file. In particular, when a peer receives some file data, it can use its own upload capacity to redistribute the data to other peers. Calculating the distribution time for the P2P architecture is somewhat more complicated than for the client-server architecture, since the distribution time depends on how each peer distributes portions of the file to the other peers. Nevertheless, a simple expression for the minimal distribution time can be obtained <a class="reference internal" href="../references.html#kumar-2006"><span class="std std-ref">[Kumar 2006]</span></a>. To this end, we first make the following observations:</p>
<ul class="simple">
<li><p>At the beginning of the distribution, only the server has the file. To get this file into the community of peers, the server must send each bit of the file at least once into its access link. Thus, the minimum distribution time is at least <em>F/us</em>. (Unlike the client-server scheme, a bit sent once by the server may not have to be sent by the server again, as the peers may redistribute the bit among themselves.)</p></li>
<li><p>As with the client-server architecture, the peer with the lowest download rate cannot obtain all F bits of the file in less than <span class="math notranslate nohighlight">\(F/d_{min}\)</span> seconds. Thus the minimum distribution time is at least <span class="math notranslate nohighlight">\(F/d_{min}\)</span>.</p></li>
<li><p>Finally, observe that the total upload capacity of the system as a whole is equal to the upload rate of the server plus the upload rates of each of the individual peers, that is, utotal=us+u1+⋯+uN. The system must deliver (upload) F bits to each of the N peers, thus delivering a total of NF bits. This cannot be done at a rate faster than <span class="math notranslate nohighlight">\(u_{total}\)</span>. Thus, the minimum distribution time is also at least NF/(us+u1+⋯+uN).</p></li>
</ul>
<p>Putting these three observations together, we obtain the minimum distribution time for P2P, denoted by <span class="math notranslate nohighlight">\(D_{P2P}\)</span>.</p>
<blockquote id="id6">
<div><p>DP2P≥max{Fus,Fdmin,NFus+∑i=1Nui}            (2.2)</p>
</div></blockquote>
<p><a class="reference internal" href="#id6"><span class="std std-ref">Equation 2.2</span></a> provides a lower bound for the minimum distribution time for the P2P architecture. It turns out that if we imagine that each peer can redistribute a bit as soon as it receives the bit, then there is a redistribution scheme that actually achieves this lower bound <a class="reference internal" href="../references.html#kumar-2006"><span class="std std-ref">[Kumar 2006]</span></a>. (We will prove a special case of this result in the homework.) In reality, where chunks of the file are redistributed rather than individual bits, <a class="reference internal" href="#id6"><span class="std std-ref">Equation 2.2</span></a> serves as a good approximation of the actual minimum distribution time. Thus, let’s take the lower bound provided by <a class="reference internal" href="#id6"><span class="std std-ref">Equation 2.2</span></a> as the actual minimum distribution time, that is,</p>
<blockquote id="id7">
<div><p>DP2P=max{Fus,Fdmin,NFus+∑i=1Nui}            (2.3)</p>
</div></blockquote>
<p><a class="reference internal" href="#figure-2-23"><span class="std std-ref">Figure 2.23</span></a> compares the minimum distribution time for the client-server and P2P architectures
assuming that all peers have the same upload rate u. In <a class="reference internal" href="#figure-2-23"><span class="std std-ref">Figure 2.23</span></a>, we have set F/u=1 hour, us=10u, and dmin≥us. Thus, a peer can transmit the entire file in one hour, the server transmission rate is 10 times the peer upload rate, and (for simplicity) the peer download rates are set large enough so as not to have an effect. We see from <a class="reference internal" href="#figure-2-23"><span class="std std-ref">Figure 2.23</span></a> that for the client-server architecture, the distribution time increases linearly and without bound as the number of peers increases. However, for the P2P architecture, the minimal distribution time is not only always less than the distribution time of the client-server architecture; it is also less than one hour for any number of peers N. Thus, applications with the P2P architecture can be self-scaling. This scalability is a direct consequence of peers being redistributors as well as consumers of bits.</p>
<figure class="align-center" id="figure-2-23">
<img alt="../_images/178-0.png" src="../_images/178-0.png" />
</figure>
<p><strong>Figure 2.23 Distribution time for P2P and client-server architectures</strong></p>
</div>
</section>
<section id="bittorrent">
<h3>BitTorrent<a class="headerlink" href="#bittorrent" title="此标题的永久链接">#</a></h3>
<p>BitTorrent 是一个流行的 P2P 文件分发协议 <a class="reference internal" href="../references.html#chao-2011"><span class="std std-ref">[Chao 2011]</span></a>。在 BitTorrent 术语中，参与特定文件分发的所有对等方集合称为一个 torrent。torrent 中的对等方彼此下载等大小的数据块，典型块大小为 256 KB。当对等方首次加入 torrent 时，尚未拥有任何块。随着时间推移，它会逐步积累更多块。在下载块的同时，它也将块上传给其他对等方。一旦获取完整文件，对等方可能（自私地）退出 torrent，也可能（无私地）留下继续为其他对等方上传块。此外，任一对等方可随时仅携部分块离开，并在之后重新加入 torrent。</p>
<p>下面我们详细介绍 BitTorrent 的运行方式。由于 BitTorrent 是一个相当复杂的协议与系统，我们将仅描述其最重要的机制，并略去一些细节；这样可以让我们把握整体概貌。每个 torrent 都有一个基础设施节点，称为 tracker。</p>
<figure class="align-center" id="figure-2-24">
<img alt="../_images/179-0.png" src="../_images/179-0.png" />
</figure>
<p><strong>图 2.24 使用 BitTorrent 进行文件分发</strong></p>
<p>当对等方加入 torrent 时，会向 tracker 注册，并定期通知其仍然在线。通过这种方式，tracker 记录当前参与 torrent 的对等方。某个 torrent 在任意时刻可能有少于 10 个或多达数千个对等方。</p>
<p>如 <a class="reference internal" href="#figure-2-24"><span class="std std-ref">图 2.24</span></a> 所示，当新对等方 Alice 加入 torrent 后，tracker 从参与对等方中随机选出一组（例如 50 个）并将其 IP 地址发送给 Alice。获得该列表后，Alice 会尝试同时与这些对等方建立 TCP 连接。我们称与 Alice 成功建立 TCP 连接的这些对等方为“邻居对等方”。（在 <a class="reference internal" href="#figure-2-24"><span class="std std-ref">图 2.24</span></a> 中，Alice 仅有 3 个邻居对等方，实际上可能更多。）随着时间推移，部分对等方可能离开，其他对等方（不在初始 50 个中）可能尝试与 Alice 建立连接。因此，某对等方的邻居会随时间变化。</p>
<p>任意时刻，每个对等方仅拥有部分数据块，且各对等方拥有的块集合不同。Alice 会周期性地向其邻居请求块列表（通过 TCP 连接）。如果 Alice 有 L 个邻居，则会获得 L 个块列表。Alice 据此向邻居请求自己尚未拥有的块。</p>
<p>任意时刻，Alice 拥有部分块，并知道其邻居各自拥有哪些块。基于此信息，Alice 面临两个关键决策：第一，从邻居处优先请求哪些块？第二，向哪些邻居发送请求的块？在决定请求哪些块时，Alice 使用一种称为 <strong>稀有优先</strong> （rarest first）的方法。该方法旨在从尚未拥有的块中识别邻居中最稀有（副本最少）的块，并优先请求这些块。这样可以尽快扩散稀有块，趋于（大致）在整个 torrent 中平衡各块副本数量。</p>
<p>在决定响应哪些请求时，BitTorrent 使用一种巧妙的交易算法。基本思想是：Alice 优先响应当前上传速率最高的邻居。具体而言，Alice 持续测量每个邻居的上传速率，并选出上传速率最高的 4 个对等方。这 4 个对等方将获得 Alice 的块回传。每隔 10 秒，Alice 重新计算速率并更新这 4 个邻居。在 BitTorrent 术语中，这些对等方称为 <strong>unchoked</strong>。此外，每隔 30 秒，Alice 会随机选出另一个邻居（例如 Bob）并向其发送块。Bob 被称为 <strong>optimistically unchoked</strong>。由于 Alice 向 Bob 发送数据，Alice 可能成为 Bob 的上传速率前 4 名之一，进而 Bob 会开始向 Alice 发送数据。若 Bob 的上传速率足够高，他也可能成为 Alice 的前 4 上传者。也就是说，Alice 每 30 秒会随机选取一个交易对象并开始交易。若彼此满意，将互列为“前 4 名”，并持续交易，直至其中一方找到更优对象。这样上传能力匹配的对等方更容易彼此发现。随机选择机制也使新对等方获得块以供交换。除这 5 个（4 个 top + 1 个探索者）外的其他邻居将被 <strong>choked</strong>，即不接收 Alice 的任何块。BitTorrent 还有许多机制未在此详述，如片段（pieces）、流水线（pipelining）、随机优先选择、结束模式（endgame mode）以及防冷落（anti-snubbing） <span class="xref std std-ref">[Cohen 2003]</span>。</p>
<p>上述交易激励机制常被称为 tit-for-tat <span class="xref std std-ref">[Cohen 2003]</span>。虽然有研究指出该激励机制可被绕过 [ <span class="xref std std-ref">Liogkas 2006</span>； <a class="reference internal" href="../references.html#locher-2006"><span class="std std-ref">Locher 2006</span></a>；<a class="reference internal" href="../references.html#piatek-2007"><span class="std std-ref">Piatek 2007</span></a>]，BitTorrent 生态依然极为成功，数百万对等方在成千上万个 torrent 中活跃共享。如果 BitTorrent 没有采用 tit-for-tat 或其变体，即使其它机制完全相同，BitTorrent 可能根本不会存活，因为大多数用户会成为搭便车者 <a class="reference internal" href="../references.html#saroiu-2002"><span class="std std-ref">[Saroiu 2002]</span></a>。</p>
<p>在本节结尾，我们简要提及 P2P 的另一应用：分布式哈希表（DHT）。分布式哈希表是一个简单数据库，其记录分布在 P2P 系统的对等方中。DHT 被广泛实现（例如 BitTorrent 中），并成为重要研究主题。其概览见配套网站中的视频说明。</p>
<figure class="align-center">
<img alt="../_images/181-0.png" src="../_images/181-0.png" />
</figure>
<p><strong>漫步分布式哈希表</strong></p>
<div class="toggle docutils container">
<p>BitTorrent is a popular P2P protocol for file distribution <a class="reference internal" href="../references.html#chao-2011"><span class="std std-ref">[Chao 2011]</span></a> . In BitTorrent lingo, the collection of all peers participating in the distribution of a particular file is called a torrent. Peers in a torrent download equal-size chunks of the file from one another, with a typical chunk size of 256 KBytes. When a peer first joins a torrent, it has no chunks. Over time it accumulates more and more chunks. While it downloads chunks it also uploads chunks to other peers. Once a peer has acquired the entire file, it may (selfishly) leave the torrent, or (altruistically) remain in the torrent and continue to upload chunks to other peers. Also, any peer may leave the torrent at any time with only a subset of chunks, and later rejoin the torrent.</p>
<p>Let’s now take a closer look at how BitTorrent operates. Since BitTorrent is a rather complicated protocol and system, we’ll only describe its most important mechanisms, sweeping some of the details under the rug; this will allow us to see the forest through the trees. Each torrent has an infrastructure
node called a tracker.</p>
<figure class="align-center">
<img alt="../_images/179-0.png" src="../_images/179-0.png" />
</figure>
<p><strong>Figure 2.24 File distribution with BitTorrent</strong></p>
<p>When a peer joins a torrent, it registers itself with the tracker and periodically informs the tracker that it is still in the torrent. In this manner, the tracker keeps track of the peers that are participating in the torrent. A given torrent may have fewer than ten or more than a thousand peers participating at any instant of time.</p>
<p>As shown in <a class="reference internal" href="#figure-2-24"><span class="std std-ref">Figure 2.24</span></a>, when a new peer, Alice, joins the torrent, the tracker randomly selects a subset of peers (for concreteness, say 50) from the set of participating peers, and sends the IP addresses of these 50 peers to Alice. Possessing this list of peers, Alice attempts to establish concurrent TCP connections with all the peers on this list. Let’s call all the peers with which Alice succeeds in establishing a TCP connection “neighboring peers.” (In <a class="reference internal" href="#figure-2-24"><span class="std std-ref">Figure 2.24</span></a> , Alice is shown to have only three neighboring peers. Normally, she would have many more.) As time evolves, some of these peers may leave and other peers (outside the initial 50) may attempt to establish TCP connections with Alice. So a peer’s neighboring peers will fluctuate over time.</p>
<p>At any given time, each peer will have a subset of chunks from the file, with different peers having different subsets. Periodically, Alice will ask each of her neighboring peers (over the TCP connections) for the list of the chunks they have. If Alice has L different neighbors, she will obtain L lists of chunks. With this knowledge, Alice will issue requests (again over the TCP connections) for chunks she currently does not have.</p>
<p>So at any given instant of time, Alice will have a subset of chunks and will know which chunks her neighbors have. With this information, Alice will have two important decisions to make. First, which chunks should she request first from her neighbors? And second, to which of her neighbors should she send requested chunks? In deciding which chunks to request, Alice uses a technique called <strong>rarest first</strong>. The idea is to determine, from among the chunks she does not have, the chunks that are the rarest among her neighbors (that is, the chunks that have the fewest repeated copies among her neighbors) and then request those rarest chunks first. In this manner, the rarest chunks get more quickly redistributed, aiming to (roughly) equalize the numbers of copies of each chunk in the torrent.</p>
<p>To determine which requests she responds to, BitTorrent uses a clever trading algorithm. The basic idea
is that Alice gives priority to the neighbors that are currently supplying her data at the highest rate. Specifically, for each of her neighbors, Alice continually measures the rate at which she receives bits and determines the four peers that are feeding her bits at the highest rate. She then reciprocates by sending chunks to these same four peers. Every 10 seconds, she recalculates the rates and possibly modifies the set of four peers. In BitTorrent lingo, these four peers are said to be <strong>unchoked</strong>. Importantly, every 30 seconds, she also picks one additional neighbor at random and sends it chunks. Let’s call the randomly chosen peer Bob. In BitTorrent lingo, Bob is said to be <strong>optimistically unchoked</strong>. Because Alice is sending data to Bob, she may become one of Bob’s top four uploaders, in which case Bob would start to send data to Alice. If the rate at which Bob sends data to Alice is high enough, Bob could then, in turn, become one of Alice’s top four uploaders. In other words, every 30 seconds, Alice will randomly choose a new trading partner and initiate trading with that partner. If the two peers are satisfied with the trading, they will put each other in their top four lists and continue trading with each other until one of the peers finds a better partner. The effect is that peers capable of uploading at compatible rates tend to find each other. The random neighbor selection also allows new peers to get chunks, so that they can have something to trade. All other neighboring peers besides these five peers
(four “top” peers and one probing peer) are “choked,” that is, they do not receive any chunks from Alice. BitTorrent has a number of interesting mechanisms that are not discussed here, including pieces (mini- chunks), pipelining, random first selection, endgame mode, and anti-snubbing <span class="xref std std-ref">[Cohen 2003]</span>.</p>
<p>The incentive mechanism for trading just described is often referred to as tit-for-tat <span class="xref std std-ref">[Cohen 2003]</span>. It has been shown that this incentive scheme can be circumvented [ <span class="xref std std-ref">Liogkas 2006</span>; <a class="reference internal" href="../references.html#locher-2006"><span class="std std-ref">Locher 2006</span></a>; <a class="reference internal" href="../references.html#piatek-2007"><span class="std std-ref">Piatek 2007</span></a>]. Nevertheless, the BitTorrent ecosystem is wildly successful, with millions of simultaneous peers actively sharing files in hundreds of thousands of torrents. If BitTorrent had been designed without tit-for-tat (or a variant), but otherwise exactly the same, BitTorrent would likely not even exist now, as the majority of the users would have been freeriders <a class="reference internal" href="../references.html#saroiu-2002"><span class="std std-ref">[Saroiu 2002]</span></a>.</p>
<p>We close our discussion on P2P by briefly mentioning another application of P2P, namely, Distributed Hast Table (DHT). A distributed hash table is a simple database, with the database records being distributed over the peers in a P2P system. DHTs have been widely implemented (e.g., in BitTorrent) and have been the subject of extensive research. An overview is provided in a Video Note in the companion website.</p>
<figure class="align-center">
<img alt="../_images/181-0.png" src="../_images/181-0.png" />
</figure>
<p><strong>Walking though distributed hash tables</strong></p>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="s4.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">2.4 DNS——互联网的目录服务</p>
      </div>
    </a>
    <a class="right-next"
       href="s6.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">2.6 视频流与内容分发</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#p2p">2.5.1 P2P 文件分发</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">P2P 架构的可扩展性</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bittorrent">BitTorrent</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>