

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>2.4 DNS——互联网的目录服务 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c2/s4';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="2.5 对等网络应用" href="s5.html" />
    <link rel="prev" title="2.3 互联网中的电子邮件" href="s3.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 2 章 应用层</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="s3.html">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="s5.html">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c4/index.html">第 4 章 网络层：数据平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c4/s1.html">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c6/index.html">第 6 章 链路层与局域网（LANs）</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c6/s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s2.html">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c8/index.html">第 8 章 计算机网络中的安全</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c8/s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s2.html">8.2 密码学原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s3.html">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c9/index.html">第 9 章 多媒体网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c9/s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s2.html">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c9/interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c2/s4.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>2.4 DNS——互联网的目录服务</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-4-1">2.4.1 DNS 提供的服务</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-4-2">2.4.2 DNS 工作原理概述</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">分布式、层次化数据库</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">DNS 缓存</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-4-3">2.4.3 DNS 记录与消息</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">DNS 消息</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">向 DNS 数据库插入记录</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="dns">
<span id="c2-4"></span><h1>2.4 DNS——互联网的目录服务<a class="headerlink" href="#dns" title="此标题的永久链接">#</a></h1>
<p>2.4 DNS—The Internet’s Directory Service</p>
<p>我们人类可以通过多种方式被识别。例如，我们可以通过出生证明上的名字被识别，也可以通过社会保障号码或驾驶执照号码被识别。尽管这些标识符都可以用于识别人，但在特定上下文中，一个标识符可能比另一个更合适。例如，美国的国税局（IRS，臭名昭著的税收机构）更喜欢使用固定长度的社会保障号码而不是出生证明上的名字。另一方面，普通人更喜欢更具助记性的出生证明名字，而不是社会保障号码。（试想一下，说“你好，我叫132-67-9875。这是我丈夫，178-87-1146。”会是什么场景。）</p>
<p>正如人类可以通过多种方式被识别一样，互联网主机也可以。一种主机标识符是其 <strong>主机名（hostname）</strong>。主机名——例如 <a class="reference external" href="http://www.facebook.com">www.facebook.com</a>、<a class="reference external" href="http://www.google.com">www.google.com</a>、 <a class="reference external" href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a> ——具有助记性，因此受到人类的青睐。然而，主机名几乎不能提供主机在互联网中的位置信息。（例如 <a class="reference external" href="http://www.eurecom.fr">www.eurecom.fr</a> 以国家代码 <code class="docutils literal notranslate"><span class="pre">.fr</span></code> 结尾，我们可以推测该主机可能位于法国，但除此之外就无从得知了。）此外，由于主机名由可变长度的字母数字字符组成，路由器处理主机名将变得困难。因此，主机也通过所谓的 <strong>IP 地址</strong> 来识别。</p>
<p>我们将在 <a class="reference internal" href="../c4/index.html#c4"><span class="std std-ref">第4章</span></a> 中详细讨论 IP 地址，但现在简单介绍一下。一个 IP 地址由四个字节组成，具有严格的分层结构。IP 地址看起来像 <code class="docutils literal notranslate"><span class="pre">121.7.106.83</span></code>，其中每个句点将四个十进制表示的字节（0 到 255）分隔开。IP 地址具有层次性，因为从左到右扫描地址时，可以获得主机在互联网上越来越具体的位置（即其所在的网络，在网络的网络中）。类似地，从下往上扫描邮寄地址，也会获得收件人所在地的逐层具体信息。</p>
<div class="toggle docutils container">
<p>We human beings can be identified in many ways. For example, we can be identified by the names that appear on our birth certificates. We can be identified by our social security numbers. We can be identified by our driver’s license numbers. Although each of these identifiers can be used to identify people, within a given context one identifier may be more appropriate than another. For example, the computers at the IRS (the infamous tax-collecting agency in the United States) prefer to use fixed-length social security numbers rather than birth certificate names. On the other hand, ordinary people prefer the more mnemonic birth certificate names rather than social security numbers. (Indeed, can you imagine saying, “Hi. My name is 132-67-9875. Please meet my husband, 178-87-1146.”)</p>
<p>Just as humans can be identified in many ways, so too can Internet hosts. One identifier for a host is its <strong>hostname</strong>. Hostnames—such as <a class="reference external" href="http://www.facebook.com">www.facebook.com</a> , <a class="reference external" href="http://www.google.com">www.google.com</a> , <a class="reference external" href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a> —are mnemonic and are therefore appreciated by humans. However, hostnames provide little, if any, information about the location within the Internet of the host. (A hostname such as <a class="reference external" href="http://www.eurecom.fr">www.eurecom.fr</a> , which ends with the country code <code class="docutils literal notranslate"><span class="pre">.fr</span></code>, tells us that the host is probably in France, but doesn’t say much more.) Furthermore, because hostnames can consist of variable-length alphanumeric characters, they would be difficult to process by routers. For these reasons, hosts are also identified by so-called <strong>IP addresses</strong>.</p>
<p>We discuss IP addresses in some detail in <a class="reference internal" href="../c4/index.html#c4"><span class="std std-ref">Chapter 4</span></a> , but it is useful to say a few brief words about them now. An IP address consists of four bytes and has a rigid hierarchical structure. An IP address looks like <code class="docutils literal notranslate"><span class="pre">121.7.106.83</span></code>, where each period separates one of the bytes expressed in decimal notation from 0 to 255. An IP address is hierarchical because as we scan the address from left to right, we obtain more and more specific information about where the host is located in the Internet (that is, within which network, in the network of networks). Similarly, when we scan a postal address from bottom to top, we obtain more and more specific information about where the addressee is located.</p>
</div>
<section id="c2-4-1">
<span id="id5"></span><h2>2.4.1 DNS 提供的服务<a class="headerlink" href="#c2-4-1" title="此标题的永久链接">#</a></h2>
<p>2.4.1 Services Provided by DNS</p>
<p>我们刚刚看到，有两种方法可以识别主机——通过主机名和 IP 地址。人类更喜欢助记性的主机名标识符，而路由器则更喜欢固定长度、具有层次结构的 IP 地址。为了协调这些偏好，我们需要一个将主机名转换为 IP 地址的目录服务。这正是互联网的 <strong>域名系统（DNS）</strong> 的主要任务。DNS 是（1）一个由 <strong>DNS 服务器</strong> 构成的分层分布式数据库，（2）一个允许主机查询该分布式数据库的应用层协议。DNS 服务器通常是在 UNIX 机器上运行的 Berkeley Internet Name Domain (BIND) 软件 <a class="reference internal" href="../references.html#bind-2016"><span class="std std-ref">[BIND 2016]</span></a>。DNS 协议运行在 UDP 上，使用端口号 53。</p>
<p>DNS 通常被其他应用层协议调用（包括 HTTP 和 SMTP）以将用户提供的主机名转换为 IP 地址。例如，设想某用户主机上运行的浏览器（即 HTTP 客户端）请求 URL <cite>www.someschool.edu/index.html</cite>。为了使用户主机能够向 Web 服务器 www.someschool.edu 发送 HTTP 请求消息，它必须首先获取 <cite>www.someschool.edu</cite> 的 IP 地址。具体过程如下：</p>
<ol class="arabic simple">
<li><p>同一台用户主机运行 DNS 应用程序的客户端部分。</p></li>
<li><p>浏览器从 URL 中提取主机名 <em>www.someschool.edu</em>，并将主机名传递给 DNS 应用程序的客户端。</p></li>
<li><p>DNS 客户端向 DNS 服务器发送包含主机名的查询。</p></li>
<li><p>DNS 客户端最终收到一个回复，其中包含主机名对应的 IP 地址。</p></li>
<li><p>一旦浏览器从 DNS 获取 IP 地址，它就可以在该地址的 80 端口与 HTTP 服务器进程建立 TCP 连接。</p></li>
</ol>
<p>从该例中我们看到，DNS 给使用它的互联网应用增加了额外的延迟——有时还相当可观。幸运的是，正如下文所述，所需的 IP 地址通常会被缓存在“附近”的 DNS 服务器中，这有助于减少 DNS 网络流量和平均 DNS 延迟。</p>
<p>除了将主机名转换为 IP 地址之外，DNS 还提供其他几个重要服务：</p>
<ul class="simple">
<li><p><strong>主机别名</strong>。具有复杂主机名的主机可以拥有一个或多个别名。例如，主机名 relay1.west-coast.enterprise.com 可以有两个别名，如 <strong>enterprise.com</strong> 和 <strong>www.enterprise.com</strong>。在这种情况下，主机名 <em>relay1.west-coast.enterprise.com</em> 被称为 <strong>规范主机名（canonical hostname）</strong>。别名主机名通常比规范主机名更具助记性。应用程序可以调用 DNS，根据提供的别名主机名获取对应的规范主机名及其 IP 地址。</p></li>
<li><p><strong>邮件服务器别名</strong>。显然，我们希望电子邮件地址具有助记性。例如，如果 Bob 使用 Yahoo Mail，那么他的电子邮件地址可能是 <a class="reference external" href="mailto:bob&#37;&#52;&#48;yahoo&#46;mail">bob<span>&#64;</span>yahoo<span>&#46;</span>mail</a>。然而 Yahoo 邮件服务器的主机名可能比 <strong>yahoo.com</strong> 更复杂且不具助记性（例如，其规范主机名可能是 <em>relay1.west-coast.yahoo.com</em>）。邮件应用程序可以调用 DNS，根据提供的别名主机名获取规范主机名及其 IP 地址。事实上，MX 记录（见下文）允许公司的邮件服务器和 Web 服务器具有相同的（别名）主机名；例如，一家公司的 Web 服务器和邮件服务器都可以称为 <strong>enterprise.com</strong>。</p></li>
<li><p><strong>负载分担</strong>。DNS 也用于在多个副本服务器之间进行负载分担，例如多个副本 Web 服务器。像 <strong>cnn.com</strong> 这样的繁忙站点部署在多个服务器上，每台服务器运行在不同的终端系统上，具有不同的 IP 地址。对于副本 Web 服务器，一组 IP 地址关联到一个规范主机名。DNS 数据库包含这组 IP 地址。当客户端查询该主机名时，DNS 服务器返回所有 IP 地址，并在每次响应中旋转地址的顺序。因为客户端通常将其 HTTP 请求发送到返回列表中的第一个地址，所以 DNS 轮换机制可以将流量分布到各个副本服务器。电子邮件服务也使用 DNS 轮换，以便多个邮件服务器具有相同的别名。此外，内容分发公司（如 Akamai）使用 DNS 的方式更加复杂 <a class="reference internal" href="../references.html#dilley-2002"><span class="std std-ref">[Dilley 2002]</span></a>，以提供 Web 内容分发（参见 <a class="reference internal" href="s6.html#c2-6-3"><span class="std std-ref">第2.6.3节</span></a>）。</p></li>
</ul>
<p>DNS 的规范定义见 <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1034.html"><strong>RFC 1034</strong></a> 和 <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1035.html"><strong>RFC 1035</strong></a>，并在多个后续 RFC 中进行了更新。DNS 是一个复杂系统，这里我们仅涉及其关键操作方面。感兴趣的读者可参考上述 RFC 和 Albitz 与 Liu 所著的书籍 <a class="reference internal" href="../references.html#albitz-1993"><span class="std std-ref">[Albitz 1993]</span></a>；另可参考回顾性论文 <a class="reference internal" href="../references.html#mockapetris-1988"><span class="std std-ref">[Mockapetris 1988]</span></a>，该文很好地描述了 DNS 的“做什么”和“为什么”，以及 <a class="reference internal" href="../references.html#mockapetris-2005"><span class="std std-ref">[Mockapetris 2005]</span></a>。</p>
<div class="toggle docutils container">
<p>We have just seen that there are two ways to identify a host—by a hostname and by an IP address. People prefer the more mnemonic hostname identifier, while routers prefer fixed-length, hierarchically structured IP addresses. In order to reconcile these preferences, we need a directory service that
translates hostnames to IP addresses. This is the main task of the Internet’s <strong>domain name system (DNS)</strong>. The DNS is (1) a distributed database implemented in a hierarchy of <strong>DNS servers</strong>, and (2) an application-layer protocol that allows hosts to query the distributed database. The DNS servers are often
UNIX machines running the Berkeley Internet Name Domain (BIND) software <a class="reference internal" href="../references.html#bind-2016"><span class="std std-ref">[BIND 2016]</span></a> . The DNS protocol runs over UDP and uses port 53.</p>
<p>DNS is commonly employed by other application-layer protocols—including HTTP and SMTP to translate user-supplied hostnames to IP addresses. As an example, consider what happens when a browser (that is, an HTTP client), running on some user’s host, requests the URL <cite>www.someschool.edu/index.html</cite>. In order for the user’s host to be able to send an HTTP request message to the Web server www.someschool.edu, the user’s host must first obtain the IP address of <cite>www.someschool.edu</cite>. This is done as follows.</p>
<ol class="arabic simple">
<li><p>The same user machine runs the client side of the DNS application.</p></li>
<li><p>The browser extracts the hostname, <em>www.someschool.edu</em>, from the URL and passes the hostname to the client side of the DNS application.</p></li>
<li><p>The DNS client sends a query containing the hostname to a DNS server.</p></li>
<li><p>The DNS client eventually receives a reply, which includes the IP address for the hostname.</p></li>
<li><p>Once the browser receives the IP address from DNS, it can initiate a TCP connection to the HTTP server process located at port 80 at that IP address.</p></li>
</ol>
<p>We see from this example that DNS adds an additional delay—sometimes substantial—to the Internet applications that use it. Fortunately, as we discuss below, the desired IP address is often cached in a “nearby” DNS server, which helps to reduce DNS network traffic as well as the average DNS delay.</p>
<p>DNS provides a few other important services in addition to translating hostnames to IP addresses:</p>
<ul class="simple">
<li><p><strong>Host aliasing</strong>. A host with a complicated hostname can have one or more alias names. For example, a hostname such as relay1.west-coast.enterprise.com could have, say, two aliases such as <strong>enterprise.com</strong> and <strong>www.enterprise.com</strong>. In this case, the hostname <em>relay1.west-coast.enterprise.com</em> is said to be a <strong>canonical hostname</strong>. Alias hostnames, when present, are typically more mnemonic than canonical hostnames. DNS can be invoked by an application to obtain the canonical hostname for a supplied alias hostname as well as the IP address of the host.</p></li>
<li><p><strong>Mail server aliasing</strong>. For obvious reasons, it is highly desirable that e-mail addresses be mnemonic. For example, if Bob has an account with Yahoo Mail, Bob’s e-mail address might be as simple as <a class="reference external" href="mailto:bob&#37;&#52;&#48;yahoo&#46;mail">bob<span>&#64;</span>yahoo<span>&#46;</span>mail</a>. However, the hostname of the Yahoo mail server is more complicated and much less mnemonic than simply <strong>yahoo.com</strong> (for example, the canonical hostname might be something like <em>relay1.west-coast.yahoo.com</em> ). DNS can be invoked by a mail application to obtain the canonical hostname for a supplied alias hostname as well as the IP address of the host. In fact, the MX record (see below) permits a company’s mail server and Web server to have identical (aliased) hostnames; for example, a company’s Web server and mail server can both be called <strong>enterprise.com</strong> .</p></li>
<li><p><strong>Load distribution</strong>. DNS is also used to perform load distribution among replicated servers, such as replicated Web servers. Busy sites, such as <strong>cnn.com</strong>, are replicated over multiple servers, with each server running on a different end system and each having a different IP address. For replicated Web servers, a set of IP addresses is thus associated with one canonical hostname. The DNS database contains this set of IP addresses. When clients make a DNS query for a name mapped to a set of addresses, the server responds with the entire set of IP addresses, but rotates the ordering of the addresses within each reply. Because a client typically sends its HTTP request message to the IP address that is listed first in the set, DNS rotation distributes the traffic among the replicated servers. DNS rotation is also used for e-mail so that multiple mail servers can have the same alias name. Also, content distribution companies such as Akamai have used DNS in more sophisticated ways <a class="reference internal" href="../references.html#dilley-2002"><span class="std std-ref">[Dilley 2002]</span></a> to provide Web content distribution (see <a class="reference internal" href="s6.html#c2-6-3"><span class="std std-ref">Section 2.6.3</span></a> ).</p></li>
</ul>
<p>The DNS is specified in <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1034.html"><strong>RFC 1034</strong></a> and <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1035.html"><strong>RFC 1035</strong></a>, and updated in several additional RFCs. It is a complex system, and we only touch upon key aspects of its operation here. The interested reader is referred to these RFCs and the book by Albitz and Liu <a class="reference internal" href="../references.html#albitz-1993"><span class="std std-ref">[Albitz 1993]</span></a> ; see also the retrospective paper <a class="reference internal" href="../references.html#mockapetris-1988"><span class="std std-ref">[Mockapetris 1988]</span></a>, which provides a nice description of the what and why of DNS, and <a class="reference internal" href="../references.html#mockapetris-2005"><span class="std std-ref">[Mockapetris 2005]</span></a>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>实践中的原理(PRINCIPLES IN PRACTICE)</p>
<p>DNS：通过客户端-服务器范式实现的关键网络功能</p>
<p>和 HTTP、FTP、SMTP 一样，DNS 协议是一个应用层协议，因为它（1）在通信端系统之间基于客户端-服务器范式运行，（2）依赖底层端到端传输协议在通信端系统之间传输 DNS 消息。但从另一个角度看，DNS 的角色与 Web、文件传输和电子邮件应用程序非常不同。与这些应用程序不同，DNS 并不是一个用户直接交互的应用程序。相反，DNS 提供了一个核心互联网功能——即为用户应用和互联网中的其他软件将主机名转换为其底层 IP 地址。我们在 <a class="reference internal" href="../c1/s2.html#c1-2"><span class="std std-ref">第1.2节</span></a> 中指出，互联网架构的大部分复杂性位于网络“边缘”。DNS 使用位于网络边缘的客户端和服务器实现关键的名称到地址转换过程，是这一设计理念的又一例证。</p>
<div class="toggle docutils container">
<p>DNS: CRITICAL NETWORK FUNCTIONS VIA THE CLIENT-SERVER PARADIGM</p>
<p>Like HTTP, FTP, and SMTP, the DNS protocol is an application-layer protocol since it (1) runs between communicating end systems using the client-server paradigm and (2) relies on an underlying end-to-end transport protocol to transfer DNS messages between communicating end systems. In another sense, however, the role of the DNS is quite different from Web, file transfer, and e-mail applications. Unlike these applications, the DNS is not an application with which a user directly interacts. Instead, the DNS provides a core Internet function—namely, translating hostnames to their underlying IP addresses, for user applications and other software in the Internet. We noted in <a class="reference internal" href="../c1/s2.html#c1-2"><span class="std std-ref">Section 1.2</span></a> that much of the complexity in the Internet architecture is located at the “edges” of the network. The DNS, which implements the critical name-to- address translation process using clients and servers located at the edge of the network, is yet another example of that design philosophy.</p>
</div>
</div>
</section>
<section id="c2-4-2">
<span id="id6"></span><h2>2.4.2 DNS 工作原理概述<a class="headerlink" href="#c2-4-2" title="此标题的永久链接">#</a></h2>
<p>2.4.2 Overview of How DNS Works</p>
<p>现在我们给出一个关于 DNS 如何工作的高层次概述。我们的讨论将聚焦于主机名到 IP 地址的转换服务。</p>
<p>假设用户主机上运行的某个应用程序（例如 Web 浏览器或邮件阅读器）需要将主机名转换为 IP 地址。该应用程序会调用 DNS 的客户端部分，并指定需要转换的主机名。（在许多基于 UNIX 的机器上，<code class="docutils literal notranslate"><span class="pre">gethostbyname()</span></code> 是应用程序用来执行此转换的函数调用。）随后，用户主机中的 DNS 接管该请求，并将查询消息发送到网络中。所有的 DNS 查询和回复消息都通过 UDP 数据报在 53 端口上传输。在经历了从毫秒到几秒不等的延迟后，用户主机中的 DNS 会收到 DNS 回复消息，其中包含所需的映射关系。该映射随后传递给调用该服务的应用程序。因此，从用户主机中调用应用程序的视角来看，DNS 就像一个黑盒，提供一个简单、直接的转换服务。但实际上，实现该服务的黑盒是复杂的，它由分布在全球的大量 DNS 服务器组成，以及一个定义 DNS 服务器与查询主机之间如何通信的应用层协议。</p>
<p>一个简单的 DNS 设计是使用一个包含所有映射关系的 DNS 服务器。在这种集中式设计中，客户端只需将所有查询发送到这台 DNS 服务器，DNS 服务器则直接向查询客户端响应。尽管这种设计的简单性颇具吸引力，但它并不适用于当今拥有大量（且不断增长）主机的互联网。集中式设计存在的问题包括：</p>
<ul class="simple">
<li><p><strong>单点故障</strong>。如果该 DNS 服务器宕机，整个互联网也随之瘫痪！</p></li>
<li><p><strong>流量负载过大</strong>。一台 DNS 服务器需要处理来自数亿主机产生的所有 HTTP 请求和电子邮件消息的 DNS 查询。</p></li>
<li><p><strong>中心数据库距离过远</strong>。单个 DNS 服务器不可能“靠近”所有查询客户端。如果我们将这台 DNS 服务器设置在纽约市，那么来自澳大利亚的所有查询都必须穿越半个地球，可能还要通过速度慢、拥堵的链路，这将导致显著的延迟。</p></li>
<li><p><strong>维护困难</strong>。该 DNS 服务器必须记录所有互联网主机的信息。这个集中式数据库不仅会非常庞大，而且需要频繁更新以包含每一台新主机。</p></li>
</ul>
<p>总之，将所有数据集中到一台 DNS 服务器上的数据库是无法扩展的。因此，DNS 从设计上就是分布式的。事实上，DNS 是一个展示如何在互联网中实现分布式数据库的精彩案例。</p>
<div class="toggle docutils container">
<p>We now present a high-level overview of how DNS works. Our discussion will focus on the hostname-to-IP-address translation service.</p>
<p>Suppose that some application (such as a Web browser or a mail reader) running in a user’s host needs to translate a hostname to an IP address. The application will invoke the client side of DNS, specifying the hostname that needs to be translated. (On many UNIX-based machines, <code class="docutils literal notranslate"><span class="pre">gethostbyname()</span></code> is the function call that an application calls in order to perform the translation.) DNS in the user’s host then takes over, sending a query message into the network. All DNS query and reply messages are sent within UDP datagrams to port 53. After a delay, ranging from milliseconds to seconds, DNS in the user’s host receives a DNS reply message that provides the desired mapping. This mapping is then passed to the invoking application. Thus, from the perspective of the invoking application in the user’s host, DNS is a black box providing a simple, straightforward translation service. But in fact, the black box that implements the service is complex, consisting of a large number of DNS servers distributed around the globe, as well as an application-layer protocol that specifies how the DNS servers and querying hosts communicate.</p>
<p>A simple design for DNS would have one DNS server that contains all the mappings. In this centralized design, clients simply direct all queries to the single DNS server, and the DNS server responds directly to the querying clients. Although the simplicity of this design is attractive, it is inappropriate for today’s Internet, with its vast (and growing) number of hosts. The problems with a centralized design include:</p>
<ul class="simple">
<li><p><strong>A single point of failure</strong>. If the DNS server crashes, so does the entire Internet!</p></li>
<li><p><strong>Traffic volume</strong>. A single DNS server would have to handle all DNS queries (for all the HTTP requests and e-mail messages generated from hundreds of millions of hosts).</p></li>
<li><p><strong>Distant centralized database</strong>. A single DNS server cannot be “close to” all the querying clients. If we put the single DNS server in New York City, then all queries from Australia must travel to the other side of the globe, perhaps over slow and congested links. This can lead to significant delays.</p></li>
<li><p><strong>Maintenance</strong>. The single DNS server would have to keep records for all Internet hosts. Not only would this centralized database be huge, but it would have to be updated frequently to account for every new host.</p></li>
</ul>
<p>In summary, a centralized database in a single DNS server simply doesn’t scale. Consequently, the DNS is distributed by design. In fact, the DNS is a wonderful example of how a distributed database can be implemented in the Internet.</p>
</div>
<section id="id7">
<h3>分布式、层次化数据库<a class="headerlink" href="#id7" title="此标题的永久链接">#</a></h3>
<p>A Distributed, Hierarchical Database</p>
<p>为了解决可扩展性问题，DNS 使用了大量服务器，这些服务器按层次结构组织，并分布在世界各地。没有任何一台 DNS 服务器拥有所有主机的全部映射关系。相反，映射关系被分布存储在 DNS 服务器之间。粗略地说，DNS 服务器可分为三类：根 DNS 服务器、顶级域（TLD）DNS 服务器和权威 DNS 服务器，这些服务器构成了如 <a class="reference internal" href="#figure-2-17"><span class="std std-ref">图 2.17</span></a> 所示的层次结构。为了理解这三类服务器如何交互，假设某个 DNS 客户端希望获取主机名 <strong>www.amazon.com</strong> 的 IP 地址。大致流程如下：客户端首先联系某个根服务器，根服务器返回 <strong>com</strong> 顶级域的 TLD 服务器的 IP 地址。然后，客户端联系这些 TLD 服务器中的一个，TLD 服务器返回 amazon.com 的权威服务器的 IP 地址。最后，客户端联系 amazon.com 的权威服务器，该服务器返回主机名 www.amazon.com 的 IP 地址。我们稍后将更详细地检查这一 DNS 查询过程。但首先让我们更深入了解这三类 DNS 服务器：</p>
<figure class="align-center" id="figure-2-17">
<img alt="../_images/164-0.png" src="../_images/164-0.png" />
</figure>
<p><strong>图 2.17 DNS 服务器层级结构的一部分</strong></p>
<ul>
<li><p><strong>根 DNS 服务器</strong>。全球分布有超过 400 个根名称服务器。<a class="reference internal" href="#figure-2-18"><span class="std std-ref">图 2.18</span></a> 显示了设有根名称服务器的国家，深色区域表示有超过十台的国家。这些根名称服务器由 13 个不同的组织管理。所有根服务器的完整列表、管理机构及其 IP 地址见 <a class="reference internal" href="../references.html#root-servers-2016"><span class="std std-ref">[Root Servers 2016]</span></a>。根名称服务器提供 TLD 服务器的 IP 地址。</p></li>
<li><p><strong>顶级域（TLD）服务器</strong>。每个顶级域——如 com、org、net、edu 和 gov，以及所有国家的顶级域（如 uk、fr、ca 和 jp）——都有一个 TLD 服务器（或服务器集群）。Verisign Global Registry Services 公司维护 <strong>com</strong> 顶级域的 TLD 服务器，Educause 公司维护 <strong>edu</strong> 顶级域的 TLD 服务器。TLD 所需的网络基础设施可以非常庞大和复杂；关于 Verisign 网络的精彩概述见 <a class="reference internal" href="../references.html#osterweil-2012"><span class="std std-ref">[Osterweil 2012]</span></a>。所有顶级域的列表见 <a class="reference internal" href="../references.html#tld-list-2016"><span class="std std-ref">[TLD list 2016]</span></a>。TLD 服务器提供权威 DNS 服务器的 IP 地址。</p>
<figure class="align-center" id="figure-2-18">
<img alt="../_images/165-0.png" src="../_images/165-0.png" />
</figure>
<p><strong>图 2.18 2016 年的 DNS 根服务器</strong></p>
</li>
<li><p><strong>权威 DNS 服务器</strong>。每个在互联网上拥有公共访问主机（如 Web 服务器和邮件服务器）的组织必须提供可以公开访问的 DNS 记录，将这些主机的名称映射为 IP 地址。组织的权威 DNS 服务器保存这些 DNS 记录。组织可以选择自行部署权威 DNS 服务器来保存这些记录；也可以付费将记录托管在某服务提供商的权威 DNS 服务器中。大多数大学和大型公司都部署并维护自己的主权威和从权威 DNS 服务器（备份）。</p></li>
</ul>
<p>根、TLD 和权威 DNS 服务器共同构成了如 <a class="reference internal" href="#figure-2-17"><span class="std std-ref">图 2.17</span></a> 所示的 DNS 服务器层级结构。还有另一种重要的 DNS 服务器类型，称为 <strong>本地 DNS 服务器</strong>。本地 DNS 服务器并不严格属于该层级结构的一部分，但却是 DNS 架构中的核心组成部分。每个 ISP（无论是家庭 ISP 还是机构 ISP）都有一个本地 DNS 服务器（也称为默认名称服务器）。当主机连接到 ISP 时，ISP 会提供其一个或多个本地 DNS 服务器的 IP 地址（通常通过 DHCP，见 <a class="reference internal" href="../c4/index.html#c4"><span class="std std-ref">第4章</span></a>）。在 Windows 或 UNIX 系统中查看网络状态窗口即可轻松获知本地 DNS 服务器的 IP 地址。本地 DNS 服务器通常“靠近”主机。对于机构 ISP，本地 DNS 服务器可能与主机位于同一个局域网内；对于家庭 ISP，通常相隔不超过几个路由器。当主机发出 DNS 查询时，该查询会发送给本地 DNS 服务器，本地服务器作为代理将查询转发到 DNS 层级结构中，如下文将更详细讨论。</p>
<p>我们来看一个简单的例子。假设主机 <em>cse.nyu.edu</em> 想获取 <em>gaia.cs.umass.edu</em> 的 IP 地址。又假设 <em>cse.nyu.edu</em> 的本地 DNS 服务器为 <em>dns.nyu.edu</em>，而 <em>gaia.cs.umass.edu</em> 的权威 DNS 服务器为 <em>dns.umass.edu</em>。如 <a class="reference internal" href="#figure-2-19"><span class="std std-ref">图 2.19</span></a> 所示，主机 <em>cse.nyu.edu</em> 首先将 DNS 查询消息发送给其本地 DNS 服务器 <em>dns.nyu.edu</em>。查询消息包含待解析的主机名，即 <strong>gaia.cs.umass.edu</strong>。本地 DNS 服务器将查询消息转发给一个根 DNS 服务器。根 DNS 服务器识别出 edu 后缀，并将负责 <strong>edu</strong> 的 TLD 服务器的 IP 地址列表返回给本地 DNS 服务器。然后本地服务器将查询转发给这些 TLD 服务器之一。TLD 服务器识别出 <em>umass.edu</em> 后缀，并返回马萨诸塞大学的权威 DNS 服务器 IP 地址，即 <em>dns.umass.edu</em>。最后，本地 DNS 服务器将查询消息直接发送至 <em>dns.umass.edu</em>，后者返回 <em>gaia.cs.umass.edu</em> 的 IP 地址。注意，在此例中，为了获取一个主机名的映射，总共发送了八个 DNS 消息：四个查询消息和四个回复消息！我们将很快看到，DNS 缓存如何减少这种查询流量。</p>
<p>前例假设 TLD 服务器知道主机名的权威 DNS 服务器。实际上，并非总是如此。TLD 服务器有时只知道一个中间 DNS 服务器，而该服务器知道目标主机名的权威 DNS 服务器。例如，再次假设马萨诸塞大学有一个校级 DNS 服务器 <em>dns.umass.edu</em>。又假设该校的每个院系都有自己的 DNS 服务器，并且每个院系的 DNS 服务器都对该系的主机名具有权威。在这种情况下，当中间 DNS 服务器 <em>dns.umass.edu</em> 接收到一个以 cs.umass.edu 结尾的主机名查询时，它会将 dns.cs.umass.edu 的 IP 地址返回给 dns.nyu.edu，而 dns.cs.umass.edu 是对所有以 <em>cs.umass.edu</em> 结尾的主机名具有权威的服务器。然后，本地 DNS 服务器 dns.nyu.edu 将查询发送给权威 DNS 服务器，该服务器返回期望的映射关系给本地 DNS 服务器，本地服务器再将其返回给请求主机。在这种情况下，总共发送了 10 个 DNS 消息！</p>
<figure class="align-center" id="figure-2-19">
<img alt="../_images/166-0.png" src="../_images/166-0.png" />
</figure>
<p><strong>图 2.19 各类 DNS 服务器之间的交互</strong></p>
<p><a class="reference internal" href="#figure-2-19"><span class="std std-ref">图 2.19</span></a> 所示示例同时使用了 <strong>递归查询</strong> 和 <strong>迭代查询</strong>。从 <em>cse.nyu.edu</em> 到 <em>dns.nyu.edu</em> 的查询为递归查询，因为它要求 <code class="docutils literal notranslate"><span class="pre">dns.nyu.edu</span></code> 代表其完成整个映射查询。但接下来的三个查询为迭代查询，因为所有的回复都是直接返回给 dns.nyu.edu 的。理论上，任何 DNS 查询都可以是递归的或迭代的。例如，<a class="reference internal" href="#figure-2-20"><span class="std std-ref">图 2.20</span></a> 展示了所有查询均为递归的 DNS 查询链。在实际中，查询通常遵循 <a class="reference internal" href="#figure-2-19"><span class="std std-ref">图 2.19</span></a> 的模式：从请求主机到本地 DNS 服务器的查询是递归的，其余查询是迭代的。</p>
<div class="toggle docutils container">
<p>In order to deal with the issue of scale, the DNS uses a large number of servers, organized in a hierarchical fashion and distributed around the world. No single DNS server has all of the mappings for all of the hosts in the Internet. Instead, the mappings are distributed across the DNS servers. To a first approximation, there are three classes of DNS servers—root DNS servers, top-level domain (TLD) DNS servers, and authoritative DNS servers—organized in a hierarchy as shown in <a class="reference internal" href="#figure-2-17"><span class="std std-ref">Figure 2.17</span></a>. To understand how these three classes of servers interact, suppose a DNS client wants to determine the IP address for the hostname <strong>www.amazon.com</strong>. To a first approximation, the following events will take place. The client first contacts one of the root servers, which returns IP addresses for TLD servers for the top-level domain <strong>com</strong>. The client then contacts one of these TLD servers, which returns the IP address of an authoritative server for amazon.com. Finally, the client contacts one of the authoritative servers for amazon.com, which returns the IP address for the hostname www.amazon.com. We’ll soon examine this DNS lookup process in more detail. But let’s first take a closer look at these three classes of DNS servers:</p>
<figure class="align-center">
<img alt="../_images/164-0.png" src="../_images/164-0.png" />
</figure>
<p><strong>Figure 2.17 Portion of the hierarchy of DNS servers</strong></p>
<ul>
<li><p><strong>Root DNS servers</strong>. There are over 400 root name servers scattered all over the world. <a class="reference internal" href="#figure-2-18"><span class="std std-ref">Figure 2.18</span></a> shows the countries that have root names servers, with countries having more than ten darkly shaded. These root name servers are managed by 13 different organizations. The full list of root name servers, along with the organizations that manage them and their IP addresses can be found at <a class="reference internal" href="../references.html#root-servers-2016"><span class="std std-ref">[Root Servers 2016]</span></a> . Root name servers provide the IP addresses of the TLD servers.</p></li>
<li><p><strong>Top-level domain (TLD) servers</strong>. For each of the top-level domains — top-level domains such as com, org, net, edu, and gov, and all of the country top-level domains such as uk, fr, ca, and jp — there is TLD server (or server cluster). The company Verisign Global Registry Services maintains the TLD servers for the <strong>com</strong> top-level domain, and the company Educause maintains the TLD servers for the <strong>edu</strong> top-level domain. The network infrastructure supporting a TLD can be large and complex; see <a class="reference internal" href="../references.html#osterweil-2012"><span class="std std-ref">[Osterweil 2012]</span></a> for a nice overview of the Verisign network. See <a class="reference internal" href="../references.html#tld-list-2016"><span class="std std-ref">[TLD list 2016]</span></a> for a list of all top-level domains. TLD servers provide the IP addresses for authoritative DNS servers.</p>
<figure class="align-center">
<img alt="../_images/165-0.png" src="../_images/165-0.png" />
</figure>
<p><strong>Figure 2.18 DNS root servers in 2016</strong></p>
</li>
<li><p><strong>Authoritative DNS servers</strong>. Every organization with publicly accessible hosts (such as Web servers and mail servers) on the Internet must provide publicly accessible DNS records that map the names of those hosts to IP addresses. An organization’s authoritative DNS server houses these DNS records. An organization can choose to implement its own authoritative DNS server to hold these records; alternatively, the organization can pay to have these records stored in an authoritative DNS server of some service provider. Most universities and large companies implement and maintain their own primary and secondary (backup) authoritative DNS server.</p></li>
</ul>
<p>The root, TLD, and authoritative DNS servers all belong to the hierarchy of DNS servers, as shown in <a class="reference internal" href="#figure-2-17"><span class="std std-ref">Figure 2.17</span></a> . There is another important type of DNS server called the <strong>local DNS server</strong>. A local DNS server does not strictly belong to the hierarchy of servers but is nevertheless central to the DNS architecture. Each ISP—such as a residential ISP or an institutional ISP—has a local DNS server (also called a default name server). When a host connects to an ISP, the ISP provides the host with the IP addresses of one or more of its local DNS servers (typically through DHCP, which is discussed in <a class="reference internal" href="../c4/index.html#c4"><span class="std std-ref">Chapter 4</span></a>). You can easily determine the IP address of your local DNS server by accessing network status windows in Windows or UNIX. A host’s local DNS server is typically “close to” the host. For an institutional ISP, the local DNS server may be on the same LAN as the host; for a residential ISP, it is typically separated from the host by no more than a few routers. When a host makes a DNS query, the query is sent to the local DNS server, which acts a proxy, forwarding the query into the DNS server hierarchy, as we’ll discuss in more detail below.</p>
<p>Let’s take a look at a simple example. Suppose the host <em>cse.nyu.edu</em> desires the IP address of <em>gaia.cs.umass.edu</em>. Also suppose that NYU’s ocal DNS server for <em>cse.nyu.edu</em> is called <em>dns.nyu.edu</em> and that an authoritative DNS server for <em>gaia.cs.umass.edu</em> is called <em>dns.umass.edu</em>. As shown in <a class="reference internal" href="#figure-2-19"><span class="std std-ref">Figure 2.19</span></a> , the host <em>cse.nyu.edu</em> first sends a DNS query message to its local DNS server, <em>dns.nyu.edu</em>. The query message contains the hostname to be translated, namely, <strong>gaia.cs.umass.edu</strong>. The local DNS server forwards the query message to a root DNS server. The root DNS server takes note of the edu suffix and returns to the local DNS server a list of IP addresses for TLD servers responsible for <strong>edu</strong>. The local DNS server then resends the query message to one of these TLD servers. The TLD server takes note of the <em>umass.edu</em> suffix and responds with the IP address of the authoritative DNS server for the University of Massachusetts, namely, <em>dns.umass.edu</em>. Finally, the local DNS server resends the query message directly to <em>dns.umass.edu</em>, which responds with the IP address of <em>gaia.cs.umass.edu</em>. Note that in this example, in order to obtain the mapping for one hostname, eight DNS messages were sent: four query messages and four reply messages! We’ll soon see how DNS caching reduces this query traffic.</p>
<p>Our previous example assumed that the TLD server knows the authoritative DNS server for the hostname. In general this not always true. Instead, the TLD server may know only of an intermediate DNS server, which in turn knows the authoritative DNS server for the hostname. For example, suppose again that the University of Massachusetts has a DNS server for the university, called <em>dns.umass.edu</em>. Also suppose that each of the departments at the University of Massachusetts has its own DNS server, and that each departmental DNS server is authoritative for all hosts in the department. In this case, when the intermediate DNS server, <em>dns.umass.edu</em>, receives a query for a host with a hostname ending with cs.umass.edu, it returns to dns.nyu.edu the IP address of dns.cs.umass.edu, which is authoritative for all hostnames ending with <em>cs.umass.edu</em>. The local DNS server dns.nyu.edu then sends the query to the authoritative DNS server, which returns the desired mapping to the local DNS server, which in turn returns the mapping to the requesting host. In this case, a total of 10 DNS messages are sent!</p>
<figure class="align-center">
<img alt="../_images/166-0.png" src="../_images/166-0.png" />
</figure>
<p><strong>Figure 2.19 Interaction of the various DNS servers</strong></p>
<p>The example shown in <a class="reference internal" href="#figure-2-19"><span class="std std-ref">Figure 2.19</span></a> makes use of both <strong>recursive queries</strong> and <strong>iterative queries</strong>. The query sent from <em>cse.nyu.edu</em> to <em>dns.nyu.edu</em> is a recursive query, since the query asks <code class="docutils literal notranslate"><span class="pre">dns.nyu.edu</span></code> to obtain the mapping on its behalf. But the subsequent three queries are iterative since all of the replies are directly returned to dns.nyu.edu. In theory, any DNS query can be iterative or recursive. For example, <a class="reference internal" href="#figure-2-20"><span class="std std-ref">Figure 2.20</span></a> shows a DNS query chain for which all of the queries are recursive. In practice, the queries typically follow the pattern in <a class="reference internal" href="#figure-2-19"><span class="std std-ref">Figure 2.19</span></a>: The query from the requesting host to the local DNS server is recursive, and the remaining queries are iterative.</p>
</div>
</section>
<section id="id8">
<h3>DNS 缓存<a class="headerlink" href="#id8" title="此标题的永久链接">#</a></h3>
<p>DNS Caching</p>
<p>到目前为止的讨论忽略了 <strong>DNS 缓存</strong>，而这是 DNS 系统中至关重要的一项功能。事实上，DNS 广泛使用 DNS 缓存以改善延迟性能，并减少在互联网上来回传递的 DNS 消息数量。DNS 缓存的思想非常简单。在查询链中，当 DNS 服务器收到一个 DNS 回复（例如包含主机名到 IP 地址的映射）时，它可以将该映射缓存在本地内存中。例如，在 <a class="reference internal" href="#figure-2-19"><span class="std std-ref">图 2.19</span></a> 中，每当本地 DNS 服务器 <code class="docutils literal notranslate"><span class="pre">dns.nyu.edu</span></code> 从某个 DNS 服务器接收到回复时，它都可以缓存回复中包含的任何信息。如果某个主机名/IP 地址对已经被缓存，并且 DNS 服务器收到该主机名的新查询，即使它不是该主机名的权威服务器，也可以直接提供所需的 IP 地址。由于主机及其主机名与 IP 地址的映射并非永久有效，DNS 服务器会在一段时间后丢弃缓存信息（通常设定为两天）。</p>
<figure class="align-center" id="figure-2-20">
<img alt="../_images/168-0.png" src="../_images/168-0.png" />
</figure>
<p><strong>图 2.20 DNS 中的递归查询</strong></p>
<p>举例来说，假设主机 <em>apricot.nyu.edu</em> 向 <em>dns.nyu.edu</em> 查询主机名 <em>cnn.com</em> 的 IP 地址。此外，再假设几小时后，另一台 NYU 主机 <strong>kiwi.nyu.edu</strong> 也向 <em>dns.nyu.edu</em> 查询相同主机名。由于缓存的存在，本地 DNS 服务器可以立即将 <strong>cnn.com</strong> 的 IP 地址返回给这个第二个请求主机，而无需再次查询其他 DNS 服务器。本地 DNS 服务器还可以缓存 TLD 服务器的 IP 地址，从而允许它在查询链中绕过根 DNS 服务器。实际上，由于缓存的使用，除了极少数情况，根服务器几乎不会被访问。</p>
<div class="toggle docutils container">
<p>Our discussion thus far has ignored <strong>DNS caching</strong>, a critically important feature of the DNS system. In truth, DNS extensively exploits DNS caching in order to improve the delay performance and to reduce the number of DNS messages ricocheting around the Internet. The idea behind DNS caching is very simple. In a query chain, when a DNS server receives a DNS reply (containing, for example, a mapping from a hostname to an IP
address), it can cache the mapping in its local memory. For example, in <a class="reference internal" href="#figure-2-19"><span class="std std-ref">Figure 2.19</span></a>, each time the local DNS server <code class="docutils literal notranslate"><span class="pre">dns.nyu.edu</span></code> receives a reply from some DNS server, it can cache any of the information contained in the reply. If a hostname/IP address pair is cached in a DNS server and another query arrives to the DNS server for the same hostname, the DNS server can provide the desired IP address, even if it is not authoritative for the hostname. Because hosts and mappings between hostnames and IP addresses are by no means permanent, DNS servers discard cached information after a period of time (often set to two days).</p>
<figure class="align-center">
<img alt="../_images/168-0.png" src="../_images/168-0.png" />
</figure>
<p><strong>Figure 2.20 Recursive queries in DNS</strong></p>
<p>As an example, suppose that a host <em>apricot.nyu.edu</em> queries <em>dns.nyu.edu</em> for the IP address for the hostname <em>cnn.com</em>. Furthermore, suppose that a few hours later, another NYU host, say, <strong>kiwi.nyu.edu</strong>, also queries <em>dns.nyu.edu</em> with the same hostname. Because of caching, the local DNS server will be able to immediately return the IP address of <strong>cnn.com</strong> to this second requesting host without having to query any other DNS servers. A local DNS server can also cache the IP addresses of TLD servers, thereby allowing the local DNS server to bypass the root DNS servers in a query chain. In fact, because of caching, root servers are bypassed for all but a very small fraction of DNS queries.</p>
</div>
</section>
</section>
<section id="c2-4-3">
<span id="id9"></span><h2>2.4.3 DNS 记录与消息<a class="headerlink" href="#c2-4-3" title="此标题的永久链接">#</a></h2>
<p>2.4.3 DNS Records and Messages</p>
<p>共同实现 DNS 分布式数据库的 DNS 服务器存储了 <strong>资源记录（RRs）</strong>，其中包括提供主机名到 IP 地址映射的记录。每条 DNS 回复消息都携带一条或多条资源记录。本节和下一小节将简要概述 DNS 的资源记录和消息；更多细节可参见 <a class="reference internal" href="../references.html#albitz-1993"><span class="std std-ref">[Albitz 1993]</span></a> 或 DNS 的 RFC 文档 [ <a class="reference internal" href="../references.html#rfc-1034"><span class="std std-ref">RFC 1034</span></a>；<a class="reference internal" href="../references.html#rfc-1035"><span class="std std-ref">[RFC 1035]</span></a>]。</p>
<p>资源记录是一个四元组，包含以下字段：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(Name, Value, Type, TTL)
</pre></div>
</div>
<p><strong>TTL</strong> 是该资源记录的生存时间（time to live）；它决定何时应将该记录从缓存中移除。在下面给出的记录示例中，我们忽略 <strong>TTL</strong> 字段。<strong>Name</strong> 和 <strong>Value</strong> 的含义取决于 <strong>Type</strong>：</p>
<ul class="simple">
<li><p>若 <code class="docutils literal notranslate"><span class="pre">Type=A</span></code>，则 <strong>Name</strong> 是主机名， <strong>Value</strong> 是该主机名的 IP 地址。因此，Type A 记录提供标准的主机名到 IP 地址映射。例如， <code class="docutils literal notranslate"><span class="pre">(relay1.bar.foo.com,</span> <span class="pre">145.37.93.126,</span> <span class="pre">A)</span></code> 是一条 Type A 记录。</p></li>
<li><p>若 <code class="docutils literal notranslate"><span class="pre">Type=NS</span></code>，则 <strong>Name</strong> 是域名（如 <em>foo.com</em>）， <strong>Value</strong> 是知道如何获取该域中主机 IP 地址的权威 DNS 服务器的主机名。该记录用于将 DNS 查询沿查询链继续路由。例如， <code class="docutils literal notranslate"><span class="pre">(foo.com,</span> <span class="pre">dns.foo.com,</span> <span class="pre">NS)</span></code> 是一条 Type NS 记录。</p></li>
<li><p>若 <code class="docutils literal notranslate"><span class="pre">Type=CNAME</span></code>，则 <strong>Value</strong> 是别名主机名 <strong>Name</strong> 所对应的规范主机名。该记录可为查询主机提供某主机名的规范名称。例如， <code class="docutils literal notranslate"><span class="pre">(foo.com,</span> <span class="pre">relay1.bar.foo.com,</span> <span class="pre">CNAME)</span></code> 是一条 CNAME 记录。</p></li>
<li><p>若 <code class="docutils literal notranslate"><span class="pre">Type=MX</span></code>，则 <strong>Value</strong> 是邮件服务器的规范主机名，而 <strong>Name</strong> 是该邮件服务器的别名主机名。例如， <code class="docutils literal notranslate"><span class="pre">(foo.com,</span> <span class="pre">mail.bar.foo.com,</span> <span class="pre">MX)</span></code> 是一条 MX 记录。MX 记录允许邮件服务器的主机名使用简单的别名。注意，通过使用 MX 记录，公司可以为邮件服务器和其它服务器（例如其 Web 服务器）使用相同的别名主机名。DNS 客户端可通过查询 MX 记录获取邮件服务器的规范主机名，通过查询 CNAME 记录获取其他服务器的规范主机名。</p></li>
</ul>
<p>如果某 DNS 服务器对某主机名具有权威性，则该服务器将包含该主机名的 Type A 记录。（即使不具有权威性，该服务器也可能在缓存中包含 Type A 记录。）如果服务器对某主机名不具备权威性，则该服务器将包含包含该主机名的域的 Type NS 记录；此外，还将包含一条 Type A 记录，为该 NS 记录中 <strong>Value</strong> 字段中的 DNS 服务器提供 IP 地址。例如，假设 edu 顶级域服务器对主机 gaia.cs.umass.edu 不具有权威性，则它将包含该主机所处域的记录，例如 <code class="docutils literal notranslate"><span class="pre">(umass.edu,</span> <span class="pre">dns.umass.edu,</span> <span class="pre">NS)</span></code>。该 edu 顶级域服务器还会包含一条将 DNS 服务器 <em>dns.umass.edu</em> 映射为 IP 地址的 Type A 记录，例如 <code class="docutils literal notranslate"><span class="pre">(dns.umass.edu,</span> <span class="pre">128.119.40.111,</span> <span class="pre">A)</span></code>。</p>
<div class="toggle docutils container">
<p>The DNS servers that together implement the DNS distributed database store <strong>resource records (RRs)</strong>, including RRs that provide hostname-to-IP address mappings. Each DNS reply message carries one or more resource records. In this and the following subsection, we provide a brief overview of DNS
resource records and messages; more details can be found in <a class="reference internal" href="../references.html#albitz-1993"><span class="std std-ref">[Albitz 1993]</span></a> or in the DNS RFCs [ <a class="reference internal" href="../references.html#rfc-1034"><span class="std std-ref">RFC 1034</span></a> ; <a class="reference internal" href="../references.html#rfc-1035"><span class="std std-ref">[RFC 1035]</span></a>].</p>
<p>A resource record is a four-tuple that contains the following fields:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(Name, Value, Type, TTL)
</pre></div>
</div>
<p><strong>TTL</strong> is the time to live of the resource record; it determines when a resource should be removed from a cache. In the example records given below, we ignore the <strong>TTL</strong> field. The meaning of <strong>Name</strong> and <strong>Value</strong> depend on <strong>Type</strong>:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">Type=A</span></code>, then <strong>Name</strong> is a hostname and <strong>Value</strong> is the IP address for the hostname. Thus, a Type A record provides the standard hostname-to-IP address mapping. As an example, <code class="docutils literal notranslate"><span class="pre">(relay1.bar.foo.com,</span> <span class="pre">145.37.93.126,</span> <span class="pre">A)</span></code> is a Type A record.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">Type=NS</span></code>, then <strong>Name</strong> is a domain (such as <em>foo.com</em>) and <strong>Value</strong> is the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain. This record is used to route DNS queries further along in the query chain. As an example, <code class="docutils literal notranslate"><span class="pre">(foo.com,</span> <span class="pre">dns.foo.com,</span> <span class="pre">NS)</span></code> is a Type NS record.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">Type=CNAME</span></code>, then <strong>Value</strong> is a canonical hostname for the alias hostname <strong>Name</strong>. This record can provide querying hosts the canonical name for a hostname. As an example, <code class="docutils literal notranslate"><span class="pre">(foo.com,</span> <span class="pre">relay1.bar.foo.com,</span> <span class="pre">CNAME)</span></code> is a CNAME record.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">Type=MX</span></code>, then <strong>Value</strong> is the canonical name of a mail server that has an alias hostname <strong>Name</strong>. As an example, <code class="docutils literal notranslate"><span class="pre">(foo.com,</span> <span class="pre">mail.bar.foo.com,</span> <span class="pre">MX)</span></code> is an MX record. MX records allow the hostnames of mail servers to have simple aliases. Note that by using the MX record, a company can have the same aliased name for its mail server and for one of its other servers (such as its Web server). To obtain the canonical name for the mail server, a DNS client would query for an MX record; to obtain the canonical name for the other server, the DNS client would query for the CNAME record.</p></li>
</ul>
<p>If a DNS server is authoritative for a particular hostname, then the DNS server will contain a Type A record for the hostname. (Even if the DNS server is not authoritative, it may contain a Type A record in its cache.) If a server is not authoritative for a hostname, then the server will contain a Type NS record for the domain that includes the hostname; it will also contain a Type A record that provides the IP
address of the DNS server in the <strong>Value</strong> field of the NS record. As an example, suppose an edu TLD server is not authoritative for the host gaia.cs.umass.edu. Then this server will contain a record for a domain that includes the host <em>gaia.cs.umass.edu</em>, for example, <code class="docutils literal notranslate"><span class="pre">(umass.edu,</span> <span class="pre">dns.umass.edu,</span> <span class="pre">NS)</span></code>. The edu TLD server would also contain a Type A record, which maps the DNS server <em>dns.umass.edu</em> to an IP address, for example, <code class="docutils literal notranslate"><span class="pre">(dns.umass.edu,</span> <span class="pre">128.119.40.111,</span> <span class="pre">A)</span></code>.</p>
</div>
<section id="id10">
<h3>DNS 消息<a class="headerlink" href="#id10" title="此标题的永久链接">#</a></h3>
<p>DNS Messages</p>
<p>前文提到 DNS 查询和回复消息。这两种是 DNS 中唯一的消息类型。此外，查询与回复消息具有相同的格式，如 <a class="reference internal" href="#figure-2-21"><span class="std std-ref">图 2.21</span></a> 所示。DNS 消息中各字段的语义如下：</p>
<ul class="simple">
<li><p>前 12 字节为报文头，包含多个字段。第一个字段是一个 16 位数字，用于标识查询。该标识符会被复制到对应的回复消息中，从而使客户端能够将接收到的回复与发送的查询匹配。标志字段中有若干标志位。其中 1 位用于指示查询/回复：0 表示查询，1 表示回复。回复消息中若该 DNS 服务器是被查询主机名的权威服务器，则设置 1 位权威标志位。1 位的递归请求标志指示客户端（主机或 DNS 服务器）希望 DNS 服务器在其未包含记录时执行递归查询。若 DNS 服务器支持递归，则在回复消息中设置 1 位的递归可用标志位。头部还包含四个数值字段，用于指示后续四种数据部分的记录数目。</p></li>
</ul>
<figure class="align-center" id="figure-2-21">
<img alt="../_images/170-0.png" src="../_images/170-0.png" />
</figure>
<p><strong>图 2.21 DNS 消息格式</strong></p>
<ul class="simple">
<li><p>问题区域包含关于正在进行的查询的信息。该区域包括 (1) 一个名称字段，表示待查询的名称；(2) 一个类型字段，表示查询的记录类型，例如主机地址（Type A）或邮件服务器（Type MX）。</p></li>
<li><p>DNS 服务器的回复中的答案区域包含了与原始查询名称对应的资源记录。请记得每条资源记录中包含 <strong>Type</strong> （如 A、NS、CNAME、MX）、 <strong>Value</strong> 和 <strong>TTL</strong>。由于一个主机名可能对应多个 IP 地址（例如多个副本 Web 服务器），因此一个回复中可能包含多条资源记录。</p></li>
<li><p>权威区域包含其他权威服务器的记录。</p></li>
<li><p>附加区域包含其他有用的记录。例如，对 MX 查询的回复中的答案区域包含邮件服务器规范主机名的资源记录，附加区域则包含该邮件服务器规范主机名的 Type A 记录，从而提供其 IP 地址。</p></li>
</ul>
<p>你是否想从你当前工作的主机上直接发送一条 DNS 查询消息到某台 DNS 服务器？这可以通过 <strong>nslookup 程序</strong> 轻松实现，大多数 Windows 和 UNIX 系统都提供该程序。例如，在 Windows 主机上，打开命令提示符，输入 “nslookup” 即可启动该程序。启动后，你可以向任何 DNS 服务器（根、TLD 或权威服务器）发送 DNS 查询。DNS 服务器返回回复消息后，nslookup 会以可读格式显示其中的记录。作为替代，你也可以访问一些允许远程使用 nslookup 的网站（只需在搜索引擎中输入 “nslookup” 即可找到）。本章结尾的 Wireshark 实验将允许你更深入地探索 DNS。</p>
<div class="toggle docutils container">
<p>Earlier in this section, we referred to DNS query and reply messages. These are the only two kinds of DNS messages. Furthermore, both query and reply messages have the same format, as shown in <a class="reference internal" href="#figure-2-21"><span class="std std-ref">Figure 2.21</span></a>. The semantics of the various fields in a DNS message are as follows:</p>
<ul class="simple">
<li><p>The first 12 bytes is the header section, which has a number of fields. The first field is a 16-bit</p></li>
</ul>
<p>number that identifies the query. This identifier is copied into the reply message to a query, allowing the client to match received replies with sent queries. There are a number of flags in the flag field. A 1-bit query/reply flag indicates whether the message is a query (0) or a reply (1). A 1-bit authoritative flag is set in a reply message when a DNS server is an authoritative server for a queried name. A 1-bit recursion-desired flag is set when a client (host or DNS server) desires that the DNS server perform recursion when it doesn’t have the record. A 1-bit recursion-available field is set in a reply if the DNS server supports recursion. In the header, there are also four number-of fields. These fields indicate the number of occurrences of the four types of data sections that follow the header.</p>
<figure class="align-center">
<img alt="../_images/170-0.png" src="../_images/170-0.png" />
</figure>
<p><strong>Figure 2.21 DNS message format</strong></p>
<ul class="simple">
<li><p>The question section contains information about the query that is being made. This section includes (1) a name field that contains the name that is being queried, and (2) a type field that indicates the type of question being asked about the name—for example, a host address associated with a name (Type A) or the mail server for a name (Type MX).</p></li>
<li><p>In a reply from a DNS server, the answer section contains the resource records for the name that was originally queried. Recall that in each resource record there is the <strong>Type</strong> (for example, A, NS, CNAME, and MX), the <strong>Value</strong>, and the <strong>TTL</strong>. A reply can return multiple RRs in the answer, since a hostname can have multiple IP addresses (for example, for replicated Web servers, as discussed earlier in this section).</p></li>
<li><p>The authority section contains records of other authoritative servers.</p></li>
<li><p>The additional section contains other helpful records. For example, the answer field in a reply to an MX query contains a resource record providing the canonical hostname of a mail server. The additional section contains a Type A record providing the IP address for the canonical hostname of the mail server.</p></li>
</ul>
<p>How would you like to send a DNS query message directly from the host you’re working on to some DNS server? This can easily be done with the <strong>nslookup program</strong>, which is available from most Windows and UNIX platforms. For example, from a Windows host, open the Command Prompt and invoke the nslookup program by simply typing “nslookup.” After invoking nslookup, you can send a DNS query to any DNS server (root, TLD, or authoritative). After receiving the reply message from the DNS server, nslookup will display the records included in the reply (in a human-readable format). As an alternative to running nslookup from your own host, you can visit one of many Web sites that allow you to remotely employ nslookup. (Just type “nslookup” into a search engine and you’ll be brought to one of these sites.) The DNS Wireshark lab at the end of this chapter will allow you to explore the DNS in much more detail.</p>
</div>
</section>
<section id="id11">
<h3>向 DNS 数据库插入记录<a class="headerlink" href="#id11" title="此标题的永久链接">#</a></h3>
<p>Inserting Records into the DNS Database</p>
<p>上述讨论聚焦于如何从 DNS 数据库中检索记录。那么这些记录最初是如何插入数据库的呢？我们通过一个具体的例子来说明。假设你刚创立了一家令人兴奋的新创业公司，名为 Network Utopia。你显然需要做的第一件事就是在某个注册商处注册域名 <strong>networkutopia.com</strong>。 <strong>注册商（registrar）</strong> 是一个商业机构，其职责是验证域名的唯一性，将其写入 DNS 数据库（如下所述），并向你收取少量费用。1999 年前，Network Solutions 一家垄断了 <strong>com</strong>、 <strong>net</strong> 和 <strong>org</strong> 域名的注册服务。而现在，有许多注册商展开竞争，并由互联网名称与数字地址分配机构（ICANN）负责认证。完整的注册商列表可在 <a class="reference external" href="http://www.internic.net">http://www.internic.net</a> 查询。</p>
<p>当你在某注册商处注册 <a class="reference external" href="http://networkutopia.com/">networkutopia.com</a> 时，还需提供主权威和从权威 DNS 服务器的名称与 IP 地址。假设它们分别是 <strong>dns1.networkutopia.com</strong>、 <strong>dns2.networkutopia.com</strong>，IP 地址分别为 <code class="docutils literal notranslate"><span class="pre">212.2.212.1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">212.212.212.2</span></code>。注册商会确保将以下 Type NS 和 Type A 记录插入到 TLD com 服务器中。具体地，针对 <strong>networkutopia.com</strong> 的主权威服务器，注册商会将以下两条资源记录插入 DNS 系统：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(networkutopia.com, dns1.networkutopia.com, NS)
(dns1.networkutopia.com, 212.212.212.1, A)
</pre></div>
</div>
<p>你还需确保你的权威 DNS 服务器中包含以下记录：你网站 www.networkutopia.com 的 Type A 记录，以及你邮件服务器 mail.networkutopia.com 的 Type MX 记录。（直到最近，每台 DNS 服务器的内容都是静态配置的，例如由系统管理员通过配置文件设定。近年来，DNS 协议增加了 UPDATE 选项，允许通过 DNS 消息动态添加或删除数据库中的记录。详见 <a class="reference internal" href="../references.html#rfc-2136"><span class="std std-ref">[RFC 2136]</span></a> 与 <a class="reference internal" href="../references.html#rfc-3007"><span class="std std-ref">[RFC 3007]</span></a>。）</p>
<div class="toggle docutils container">
<p>The discussion above focused on how records are retrieved from the DNS database. You might be wondering how records get into the database in the first place. Let’s look at how this is done in the context of a specific example. Suppose you have just created an exciting new startup company called Network Utopia. The first thing you’ll surely want to do is register the domain name <strong>networkutopia.com</strong> at a registrar. A <strong>registrar</strong> is a commercial entity that verifies the uniqueness of the domain name, enters the domain name into the DNS database (as discussed below), and collects a small fee from you for its services. Prior to 1999, a single registrar, Network Solutions, had a monopoly on domain name registration for <strong>com</strong>, <strong>net</strong>, and <strong>org</strong> domains. But now there are many registrars competing for customers, and the Internet Corporation for Assigned Names and Numbers (ICANN) accredits the various registrars. A complete list of accredited registrars is available at <a class="reference external" href="http://www.internic.net">http://www.internic.net</a> .</p>
<p>When you register the domain name <a class="reference external" href="http://networkutopia.com/">networkutopia.com</a>  with some registrar, you also need to provide the registrar with the names and IP addresses of your primary and secondary authoritative DNS servers. Suppose the names and IP addresses are <strong>dns1.networkutopia.com</strong>, <strong>dns2.networkutopia.com</strong>, <code class="docutils literal notranslate"><span class="pre">212.2.212.1</span></code>, and <code class="docutils literal notranslate"><span class="pre">212.212.212.2</span></code>. For each of these two authoritative DNS servers, the registrar would then make sure that a Type NS and a Type A record are entered into the TLD com servers. Specifically, for the primary authoritative server for <strong>networkutopia.com</strong> , the registrar would insert the following two resource records into the DNS system:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(networkutopia.com, dns1.networkutopia.com, NS)
(dns1.networkutopia.com, 212.212.212.1, A)
</pre></div>
</div>
<p>You’ll also have to make sure that the Type A resource record for your Web server www.networkutopia.com and the Type MX resource record for your mail server mail.networkutopia.com are entered into your authoritative DNS servers. (Until recently, the contents of each DNS server were configured statically, for example, from a configuration file created by a system manager. More recently, an UPDATE option has been added to the DNS protocol to allow data to be dynamically added or deleted from the database via DNS messages. <a class="reference internal" href="../references.html#rfc-2136"><span class="std std-ref">[RFC 2136]</span></a> and <a class="reference internal" href="../references.html#rfc-3007"><span class="std std-ref">[RFC 3007]</span></a> specify DNS dynamic updates.)</p>
</div>
<div class="admonition-focus-on-security admonition">
<p class="admonition-title">聚焦安全(FOCUS ON SECURITY)</p>
<p>DNS 漏洞</p>
<p>我们已经看到，DNS 是互联网基础设施中的关键组成部分，许多重要服务（包括 Web 与电子邮件）无法在没有 DNS 的情况下运行。因此我们自然要问：DNS 是否可能受到攻击？它是否是不设防的目标，随时可能被击垮，进而导致大部分互联网应用瘫痪？</p>
<p>第一个想到的攻击类型是针对 DNS 服务器的 DDoS 带宽洪泛攻击（见 <a class="reference internal" href="../c1/s6.html#c1-6"><span class="std std-ref">第 1.6 节</span></a>）。例如，攻击者可以向每台 DNS 根服务器发送大量数据包，以致大多数合法 DNS 查询得不到响应。事实上，2002 年 10 月 21 日确实发生过一次大规模 DNS 根服务器 DDoS 攻击。攻击者利用僵尸网络，向 13 个 DNS 根服务器的 IP 地址发送大量 ICMP ping 消息。（ICMP 消息详见 <a class="reference internal" href="../c5/s6.html#c5-6"><span class="std std-ref">第 5.6 节</span></a>。目前只需知道 ICMP 数据包是特殊类型的 IP 数据报。）幸运的是，这场大规模攻击造成的损害极小，几乎没有影响用户的互联网体验。虽然攻击者成功地向根服务器发起了大量数据包，但多数根服务器受到包过滤保护，配置为始终阻止所有针对根服务器的 ICMP ping 消息。这些受保护的服务器因此得以正常运行。此外，大多数本地 DNS 服务器会缓存顶级域服务器的 IP 地址，使得查询过程通常可绕过 DNS 根服务器。</p>
<p>另一种更具破坏性的 DDoS 攻击可能是向顶级域服务器（如处理 .com 域名的服务器）发送洪水式 DNS 查询。这种攻击更难过滤，且 TLD 服务器不像根服务器那样容易绕过。但即便如此，本地 DNS 服务器的缓存也能在一定程度上缓解此类攻击的影响。</p>
<p>DNS 也可能遭受其它攻击。例如，中间人攻击中，攻击者拦截主机发出的查询并返回伪造的回复。在 DNS 投毒攻击中，攻击者向 DNS 服务器发送伪造回复，诱使其将虚假记录写入缓存。这些攻击可以用来将毫无戒心的 Web 用户重定向到攻击者网站。这类攻击的实施难度较高，因为它们需要拦截数据包或操控服务器，详见 <a class="reference internal" href="../references.html#skoudis-2006"><span class="std std-ref">[Skoudis 2006]</span></a>。</p>
<p>总结来说，DNS 在面对攻击时展现出了惊人的鲁棒性。迄今为止，还未出现成功阻断 DNS 服务的攻击。</p>
<div class="toggle docutils container">
<p>DNS VULNERABILITIES</p>
<p>We have seen that DNS is a critical component of the Internet infrastructure, with many important services—including the Web and e-mail—simply incapable of functioning without it. We therefore naturally ask, how can DNS be attacked? Is DNS a sitting duck, waiting to be knocked out of service, while taking most Internet applications down with it?</p>
<p>The first type of attack that comes to mind is a DDoS bandwidth-flooding attack (see <a class="reference internal" href="../c1/s6.html#c1-6"><span class="std std-ref">Section 1.6</span></a> ) against DNS servers. For example, an attacker could attempt to send to each DNS root server a deluge of packets, so many that the majority of legitimate DNS queries never get answered. Such a large-scale DDoS attack against DNS root servers actually took place on October 21, 2002. In this attack, the attackers leveraged a botnet to send truck loads of ICMP ping messages to each of the 13 DNS root IP addresses. (ICMP messages are discussed in <a class="reference internal" href="../c5/s6.html#c5-6"><span class="std std-ref">Section 5.6</span></a>. For now, it suffices to know that ICMP packets are special types of IP datagrams.) Fortunately, this large-scale attack caused minimal damage, having little or no impact on users’ Internet experience. The attackers did succeed at directing a deluge of packets at the root servers. But many of the DNS root servers were protected by packet filters, configured to always block all ICMP ping messages directed at the root servers. These protected servers were thus spared and functioned as normal. Furthermore, most local DNS servers cache the IP addresses of top-level-domain servers, allowing the query process to often bypass the DNS root servers.</p>
<p>A potentially more effective DDoS attack against DNS would be send a deluge of DNS queries to top-level-domain servers, for example, to all the top-level-domain servers that handle the .com domain. It would be harder to filter DNS queries directed to DNS servers; and top-level-domain servers are not as easily bypassed as are root servers. But the severity of such an attack would be partially mitigated by caching in local DNS servers.</p>
<p>DNS could potentially be attacked in other ways. In a man-in-the-middle attack, the attacker intercepts queries from hosts and returns bogus replies. In the DNS poisoning attack, the attacker sends bogus replies to a DNS server, tricking the server into accepting bogus records into its cache. Either of these attacks could be used, for example, to redirect an unsuspecting Web user to the attacker’s Web site. These attacks, however, are difficult to implement, as they require intercepting packets or throttling servers <a class="reference internal" href="../references.html#skoudis-2006"><span class="std std-ref">[Skoudis 2006]</span></a> .</p>
<p>In summary, DNS has demonstrated itself to be surprisingly robust against attacks. To date, there hasn’t been an attack that has successfully impeded the DNS service.</p>
</div>
</div>
<p>一旦以上步骤完成，人们就可以访问你的网站，并向你公司的员工发送电子邮件了。让我们通过验证这个过程来结束对 DNS 的讨论。这一验证也有助于巩固我们对 DNS 的理解。假设澳大利亚的 Alice 想要访问网页 <strong>www.networkutopia.com</strong>。如前所述，她的主机会首先向本地 DNS 服务器发送查询。本地 DNS 服务器随后联系一个 TLD com 服务器。（若未缓存任何 com TLD 服务器的地址，还需先联系根 DNS 服务器。）该 TLD 服务器包含注册商插入的 Type NS 与 Type A 记录。TLD com 服务器将包含这两条记录的回复返回给 Alice 的本地 DNS 服务器。本地服务器随后向 <code class="docutils literal notranslate"><span class="pre">212.212.212.1</span></code> 发送 DNS 查询，请求与 <strong>www.networkutopia.com</strong> 相应的 Type A 记录。该记录返回 Web 服务器的 IP 地址，例如 <code class="docutils literal notranslate"><span class="pre">212.212.71.4</span></code>，并由本地 DNS 服务器转交给 Alice 的主机。此时，Alice 的浏览器即可向主机 <code class="docutils literal notranslate"><span class="pre">212.212.71.4</span></code> 发起 TCP 连接，并通过该连接发送 HTTP 请求。哇！上网冲浪时的背后原来有这么多工作在进行！</p>
<div class="toggle docutils container">
<p>Once all of these steps are completed, people will be able to visit your Web site and send e-mail to the employees at your company. Let’s conclude our discussion of DNS by verifying that this statement is true. This verification also helps to solidify what we have learned about DNS. Suppose Alice in Australia wants to view the Web page <strong>www.networkutopia.com</strong>. As discussed earlier, her host will first send a DNS query to her local DNS server. The local DNS server will then contact a TLD com server. (The local DNS server will also have to contact a root DNS server if the address of a TLD <strong>com</strong> server is not cached.) This TLD server contains the Type NS and Type A resource records listed above, because the registrar had these resource records inserted into all of the TLD <strong>com</strong> servers. The TLD com server sends a reply to Alice’s local DNS server, with the reply containing the two resource records. The local DNS server then sends a DNS query to <code class="docutils literal notranslate"><span class="pre">212.212.212.1</span></code>, asking for the Type A record corresponding to <strong>www.networkutopia.com</strong>. This record provides the IP address of the desired Web server, say, <code class="docutils literal notranslate"><span class="pre">212.212.71.4</span></code>, which the local DNS server passes back to Alice’s host. Alice’s browser can now initiate a TCP connection to the host <code class="docutils literal notranslate"><span class="pre">212.212.71.4</span></code> and send an HTTP request over the connection. Whew! There’s a lot more going on than what meets the eye when one surfs the Web!</p>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="s3.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">2.3 互联网中的电子邮件</p>
      </div>
    </a>
    <a class="right-next"
       href="s5.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">2.5 对等网络应用</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-4-1">2.4.1 DNS 提供的服务</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-4-2">2.4.2 DNS 工作原理概述</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">分布式、层次化数据库</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">DNS 缓存</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c2-4-3">2.4.3 DNS 记录与消息</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">DNS 消息</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">向 DNS 数据库插入记录</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>