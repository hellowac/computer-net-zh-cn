

<!DOCTYPE html>


<html lang="zh-CN" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>9.2 流媒体存储视频 &#8212; 计算机网络: 自顶向下</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script>let toggleHintShow = '原文';</script>
    <script>let toggleHintHide = '收起';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c9/s2';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="9.3 基于 IP 的语音通信" href="s3.html" />
    <link rel="prev" title="9.1 多媒体网络应用" href="s1.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">计算机网络: 自顶向下</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">搜索</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c1/index.html">第 1 章 计算机网络与因特网</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c1/s1.html">1.1 什么是互联网？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s2.html">1.2 网络边缘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s3.html">1.3 网络核心</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s4.html">1.4 分组交换网络中的时延、丢包与吞吐量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s5.html">1.5 协议层与其服务模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s6.html">1.6 网络攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/s7.html">1.7 计算机网络与互联网的发展历史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/summary.html">1.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c1/interview.html">访谈：Leonard Kleinrock</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c2/index.html">第 2 章 应用层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c2/s1.html">2.1 网络应用程序原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s2.html">2.2 Web 与 HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s3.html">2.3 互联网中的电子邮件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s4.html">2.4 DNS——互联网的目录服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s5.html">2.5 对等网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s6.html">2.6 视频流与内容分发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/s7.html">2.7 套接字编程：创建网络应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/summary.html">2.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/socketpro.html">Socket 编程作业</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c2/interview.html">访谈: Marc Andreessen</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c3/index.html">第 3 章 传输层</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c3/s1.html">3.1 引言与传输层服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s2.html">3.2 复用与解复用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s3.html">3.3 无连接传输：UDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s4.html">3.4 可靠数据传输的原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s5.html">3.5 面向连接的传输：TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s6.html">3.6 拥塞控制原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/s7.html">3.7 TCP 拥塞控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/summary.html">3.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c3/interview.html">访谈: Van Jacobson</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c4/index.html">第 4 章 网络层：数据平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c4/s1.html">4.1 网络层概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s2.html">4.2 路由器的内部结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s3.html">4.3 Internet 协议（IP）：IPv4、地址、IPv6 等</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/s4.html">4.4 通用转发与 SDN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/summary.html">4.5 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c4/interview.html">访谈: Vinton G. Cerf</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c5/index.html">第 5 章 网络层：控制平面</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c5/s1.html">5.1 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s2.html">5.2 路由算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s3.html">5.3 互联网中的域内路由：OSPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s4.html">5.4 ISP 之间的路由：BGP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s5.html">5.5 SDN 控制平面</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s6.html">5.6 ICMP：因特网控制报文协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/s7.html">5.7 网络管理与 SNMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/summary.html">5.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c5/interview.html">访谈: Jennifer Rexford</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c6/index.html">第 6 章 链路层与局域网（LANs）</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c6/s1.html">6.1 链路层简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s2.html">6.2 错误检测与纠正技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s3.html">6.3 多路访问链路与协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s4.html">6.4 交换式局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s5.html">6.5 链路虚拟化：作为链路层的网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s6.html">6.6 数据中心网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/s7.html">6.7 回顾：网页请求生命周期中的一天</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/summary.html">6.8 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c6/interview.html">访谈：Simon S. Lam</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c7/index.html">第 7 章 无线与移动网络</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c7/s1.html">7.1 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s2.html">7.2 无线链接和网络特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s3.html">7.3 WiFi：802.11 无线局域网</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s4.html">7.4 蜂窝互联网接入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s5.html">7.5 移动性管理：原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s6.html">7.6 移动 IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s7.html">7.7 蜂窝网络中的移动性管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/s8.html">7.8 无线与移动性：对高层协议的影响</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/summary.html">7.9 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c7/interview.html">访谈: Deborah Estrin</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../c8/index.html">第 8 章 计算机网络中的安全</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../c8/s1.html">8.1 什么是网络安全？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s2.html">8.2 密码学原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s3.html">8.3 消息完整性和数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s4.html">8.4 终端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s5.html">8.5 电子邮件安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s6.html">8.6 保护 TCP 连接: SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s7.html">8.7 网络层安全: IPsec 和虚拟专用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s8.html">8.8 无线局域网的安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/s9.html">8.9 运行安全：防火墙和入侵检测系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/summary.html">8.10 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/homework.html">课后习题与问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/wiresharklab.html">Wireshark 实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c8/interview.html">访谈：Steven M. Bellovin</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">第 9 章 多媒体网络</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="s1.html">9.1 多媒体网络应用</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">9.2 流媒体存储视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="s3.html">9.3 基于 IP 的语音通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="s4.html">9.4 实时对话应用的协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="s5.html">9.5 多媒体的网络支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">9.6 小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="homework.html">家庭作业问题和疑问</a></li>
<li class="toctree-l2"><a class="reference internal" href="interview.html">访谈：Henning Schulzrinne</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">引用</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/hellowac/computer-net-zh-cn" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="源码库"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/c9/s2.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>9.2 流媒体存储视频</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#udp">9.2.1 UDP 流媒体</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#http">9.2.2 HTTP 流媒体</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">预取视频</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tcp">客户端应用程序缓冲与 TCP 缓冲</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">视频流分析</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">提前终止与视频重定位</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="c9-2">
<span id="id1"></span><h1>9.2 流媒体存储视频<a class="headerlink" href="#c9-2" title="此标题的永久链接">#</a></h1>
<p>9.2 Streaming Stored Video</p>
<p>对于流媒体视频应用，预录制的视频被放置在服务器上，用户向这些服务器发送请求以按需观看视频。用户可以从头到尾 uninterrupted 地观看视频，可以在视频结束前停止观看，或通过暂停、前进或后退等方式与视频进行交互。流媒体视频系统可分为三类： <strong>UDP 流媒体</strong>、 <strong>HTTP 流媒体</strong> 和 <strong>自适应 HTTP 流媒体</strong> （见 <a class="reference internal" href="../c2/s6.html#c2-6"><span class="std std-ref">Section 2.6</span></a>）。尽管这三种系统在实际中都被使用，但如今大多数系统采用 HTTP 流媒体和自适应 HTTP 流媒体。</p>
<p>所有三种视频流媒体形式的一个共同特点是广泛使用客户端应用程序缓冲区，以减轻服务器到客户端之间端到端延迟的变化和可用带宽变化的影响。对于流媒体视频（无论是存储的还是直播的），用户通常可以容忍在客户端请求视频和视频开始播放之间几秒钟的小延迟。因此，当视频开始到达客户端时，客户端不需要立即开始播放，而是可以先在应用程序缓冲区中积累一定的视频储备。一旦客户端积累了几秒钟尚未播放的视频储备，便可以开始播放视频。这种 <strong>客户端缓冲</strong> 提供了两个重要优势。首先，客户端缓冲可以吸收服务器到客户端延迟的变化。如果某一段视频数据延迟，只要它在已接收但尚未播放的视频储备耗尽前到达，用户就不会注意到这个长延迟。其次，如果服务器到客户端的带宽短暂下降到低于视频消费速率的水平，只要客户端应用程序缓冲区未完全耗尽，用户仍可持续播放不中断。</p>
<p><a class="reference internal" href="#figure-9-1"><span class="std std-ref">Figure 9.1</span></a> 展示了客户端缓冲。假设视频以固定比特率编码，因此每个视频块包含在固定时间 Δ 内播放的帧。服务器在 t0 发送第一个视频块，在 t0+Δ 发送第二个，在 t0+2Δ 发送第三个，以此类推。一旦客户端开始播放，每个块应在前一个块播放 Δ 时间单位后播放，以重现原始录制视频的时间序列。由于网络端到端延迟的可变性，不同视频块经历的延迟不同。第一个视频块在 t1 到达客户端，第二个在 t2 到达。第 i 个块的网络延迟是服务器发送该块的时间与客户端接收时间之间的水平距离；注意，不同视频块的网络延迟是不同的。在此示例中，如果客户端在 t1 即第一个块到达时就开始播放，则第二个块无法及时在 t1+Δ 时播放。此时，要么播放中断等待第 2 块到达，要么跳过第 2 块播放——这两种情况都会带来不良的播放体验。相反，如果客户端延迟播放到 t3，此时块 1 到 6 都已到达，则可以按照固定节奏开始播放，且每个块都能在其播放时间前到达。</p>
<figure class="align-center" id="figure-9-1">
<img alt="../_images/755-0.png" src="../_images/755-0.png" />
</figure>
<p><strong>Figure 9.1 视频流媒体中的客户端播放延迟</strong></p>
<div class="toggle docutils container">
<p>For streaming video applications, prerecorded videos are placed on servers, and users send requests to these servers to view the videos on demand. The user may watch the video from beginning to end without interruption, may stop watching the video well before it ends, or interact with the video by pausing or repositioning to a future or past scene. Streaming video systems can be classified into three categories: <strong>UDP streaming</strong>, <strong>HTTP streaming</strong>, and <strong>adaptive HTTP streaming</strong> (see <a class="reference internal" href="../c2/s6.html#c2-6"><span class="std std-ref">Section 2.6</span></a>). Although all three types of systems are used in practice, the majority of today’s systems employ HTTP streaming and adaptive HTTP streaming.</p>
<p>A common characteristic of all three forms of video streaming is the extensive use of client-side application buffering to mitigate the effects of varying end-to-end delays and varying amounts of available bandwidth between server and client. For streaming video (both stored and live), users generally can tolerate a small several-second initial delay between when the client requests a video and when video playout begins at the client. Consequently, when the video starts to arrive at the client, the client need not immediately begin playout, but can instead build up a reserve of video in an application buffer. Once the client has built up a reserve of several seconds of buffered-but-not-yet-played video, the client can then begin video playout. There are two important advantages provided by such <strong>client buffering</strong>. First, client-side buffering can absorb variations in server-to-client delay. If a particular piece of video data is delayed, as long as it arrives before the reserve of received-but-not-yet-played video is exhausted, this long delay will not be noticed. Second, if the server-to-client bandwidth briefly drops below the video consumption rate, a user can continue to enjoy continuous playback, again as long as the client application buffer does not become completely drained.</p>
<p><a class="reference internal" href="#figure-9-1"><span class="std std-ref">Figure 9.1</span></a> illustrates client-side buffering. In this simple example, suppose that video is encoded at a fixed bit rate, and thus each video block contains video frames that are to be played out over the same fixed amount of time, Δ. The server transmits the first video block at t0, the second block at t0+Δ, the third block at t0+2Δ, and so on. Once the client begins playout, each block should be played out Δ time units after the previous block in order to reproduce the timing of the original recorded video. Because of the variable end-to-end network delays, different video blocks experience different delays. The first video block arrives at the client at t1 and the second block arrives at t2. The network delay for the ith block is the horizontal distance between the time the block was transmitted by the server and the time it is received at the client; note that the network delay varies from one video block to another. In this example, if the client were to begin playout as soon as the first block arrived at t1, then the second block would not have arrived in time to be played out at out at t1+Δ. In this case, video playout would either have to stall (waiting for block 2 to arrive) or block 2 could be skipped—both resulting in undesirable playout impairments. Instead, if the client were to delay the start of playout until t3, when blocks 1 through 6 have all arrived, periodic playout can proceed with all blocks having been received before their playout time.</p>
<figure class="align-center">
<img alt="../_images/755-0.png" src="../_images/755-0.png" />
</figure>
<p><strong>Figure 9.1 Client playout delay in video streaming</strong></p>
</div>
<section id="udp">
<span id="c9-2-1"></span><h2>9.2.1 UDP 流媒体<a class="headerlink" href="#udp" title="此标题的永久链接">#</a></h2>
<p>9.2.1 UDP Streaming</p>
<p>我们这里只简要讨论 UDP 流媒体，更深入的协议内容可参考其他章节。在 UDP 流媒体中，服务器以与客户端视频消费速率匹配的速率，通过 UDP 稳定地发送视频块。例如，如果视频消费速率为 2 Mbps，每个 UDP 包携带 8,000 位视频数据，则服务器每 (8000 位)/(2 Mbps)=4 毫秒 向其套接字发送一个 UDP 包。正如我们在 <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a> 中所学，UDP 不使用拥塞控制机制，因此服务器可以按视频消费速率向网络推送数据包，不受 TCP 速率控制限制。UDP 流媒体通常使用一个很小的客户端缓冲区，仅能容纳不到一秒的视频。</p>
<p>在传递给 UDP 之前，服务器会将视频块封装在专门为传输音视频设计的传输包中，使用实时传输协议（RTP）[<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3550.html"><strong>RFC 3550</strong></a>] 或类似（可能是专有）的协议。我们将延迟到 <a class="reference internal" href="s3.html#c9-3"><span class="std std-ref">Section 9.3</span></a> 讨论 RTP，在那里我们将其与实时语音视频系统一起讨论。</p>
<p>UDP 流媒体的另一个特点是，除了服务器到客户端的视频流之外，客户端和服务器还维护一个并行的控制连接，客户端通过该连接发送有关会话状态变化的命令（如暂停、继续、跳转等）。实时流媒体协议（RTSP）[<span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2326.html"><strong>RFC 2326</strong></a>] 是一种常用的开放控制协议，详细说明见本教材网站。</p>
<p>尽管 UDP 流媒体被许多开源系统和专有产品采用，但它存在三个主要缺点。首先，由于服务器与客户端之间的可用带宽不可预测且不断变化，固定速率的 UDP 流媒体难以实现连续播放。例如，考虑视频消费速率为 1 Mbps，而服务器到客户端的可用带宽通常大于 1 Mbps，但每隔几分钟就会下降至低于 1 Mbps 几秒钟的情况。在这种情况下，以 1 Mbps 恒定速率通过 RTP/UDP 发送视频的系统可能会在带宽下降后很快出现卡顿或跳帧，导致用户体验不佳。第二个缺点是，UDP 流媒体需要一个媒体控制服务器，如 RTSP 服务器，来处理客户端发来的交互请求，并为每个客户端会话追踪状态（如播放点、播放/暂停状态等）。这会增加大规模视频点播系统部署的整体成本和复杂度。第三个缺点是，许多防火墙配置为阻止 UDP 流量，阻碍了这些防火墙后方的用户接收 UDP 视频。</p>
<div class="toggle docutils container">
<p>We only briefly discuss UDP streaming here, referring the reader to more in-depth discussions of the protocols behind these systems where appropriate. With UDP streaming, the server transmits video at a rate that matches the client’s video consumption rate by clocking out the video chunks over UDP at a steady rate. For example, if the video consumption rate is 2 Mbps and each UDP packet carries 8,000 bits of video, then the server would transmit one UDP packet into its socket every
(8000 bits)/(2 Mbps)=4 msec. As we learned in <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a>, because UDP does not employ a congestion-control mechanism, the server can push packets into the network at the consumption rate of the video without the rate-control restrictions of TCP. UDP streaming typically uses a small client-side buffer, big enough to hold less than a second of video.</p>
<p>Before passing the video chunks to UDP, the server will encapsulate the video chunks within transport packets specially designed for transporting audio and video, using the Real-Time Transport Protocol (RTP) [<span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3550.html"><strong>RFC 3550</strong></a>] or a similar (possibly proprietary) scheme. We delay our coverage of RTP until <a class="reference internal" href="s3.html#c9-3"><span class="std std-ref">Section 9.3</span></a>, where we discuss RTP in the context of conversational voice and video systems.</p>
<p>Another distinguishing property of UDP streaming is that in addition to the server-to-client video stream, the client and server also maintain, in parallel, a separate control connection over which the client sends commands regarding session state changes (such as pause, resume, reposition, and so on). The Real-Time Streaming Protocol (RTSP) [<span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2326.html"><strong>RFC 2326</strong></a>], explained in some detail in the Web site for this textbook, is a popular open protocol for such a control connection.</p>
<p>Although UDP streaming has been employed in many open-source systems and proprietary products, it suffers from three significant drawbacks. First, due to the unpredictable and varying amount of available bandwidth between server and client, constant-rate UDP streaming can fail to provide continuous playout. For example, consider the scenario where the video consumption rate is 1 Mbps and the server-to-client available bandwidth is usually more than 1 Mbps, but every few minutes the available bandwidth drops below 1 Mbps for several seconds. In such a scenario, a UDP streaming system that transmits video at a constant rate of 1 Mbps over RTP/UDP would likely provide a poor user experience, with freezing or skipped frames soon after the available bandwidth falls below 1 Mbps. The second drawback of UDP streaming is that it requires a media control server, such as an RTSP server, to process client-to-server interactivity requests and to track client state (e.g., the client’s playout point in the video, whether the video is being paused or played, and so on) for each ongoing client session. This increases the overall cost and complexity of deploying a large-scale video-on-demand system. The third drawback is that many firewalls are configured to block UDP traffic, preventing the users behind these firewalls from receiving UDP video.</p>
</div>
</section>
<section id="http">
<span id="c9-2-2"></span><h2>9.2.2 HTTP 流媒体<a class="headerlink" href="#http" title="此标题的永久链接">#</a></h2>
<p>9.2.2 HTTP Streaming</p>
<p>在 HTTP 流媒体中，视频作为一个普通文件被存储在 HTTP 服务器上，并具有一个特定的 URL。当用户想观看该视频时，客户端通过 TCP 与服务器建立连接，并发出一个针对该 URL 的 HTTP GET 请求。随后，服务器通过 HTTP 响应消息尽可能快地发送该视频文件，即在 TCP 拥塞控制和流量控制允许的范围内尽快发送。在客户端，字节被收集到客户端应用程序缓冲区中。一旦缓冲区中的字节数超过预定阈值，客户端应用程序开始播放——具体而言，它定期从应用程序缓冲区中提取视频帧，对帧进行解压缩，并在用户屏幕上显示。</p>
<p>我们在 <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a> 中了解到，通过 TCP 传输文件时，由于 TCP 拥塞控制机制，服务器到客户端的传输速率可能会显著波动。尤其常见的是传输速率以与 TCP 拥塞控制相关的“锯齿状”方式变化。此外，由于 TCP 的重传机制，数据包也可能会显著延迟。由于 TCP 具有这些特性，1990 年代的普遍看法是视频流媒体在 TCP 上无法良好运行。然而，随着时间的推移，流媒体系统的设计者认识到，若结合客户端缓冲和预取（将在下一节中讨论），TCP 的拥塞控制和可靠数据传输机制并不会妨碍连续播放。</p>
<p>在 TCP 上使用 HTTP 还可以更容易地穿越防火墙和 NAT（这些通常配置为阻止大多数 UDP 流量但允许大多数 HTTP 流量）。通过 HTTP 进行流媒体传输也消除了对媒体控制服务器（如 RTSP 服务器）的需求，从而降低了在互联网上大规模部署的成本。由于上述种种优点，如今大多数视频流媒体应用（包括 YouTube 和 Netflix）都采用基于 TCP 的 HTTP 流媒体作为其底层传输协议。</p>
<div class="toggle docutils container">
<p>In HTTP streaming, the video is simply stored in an HTTP server as an ordinary file with a specific URL. When a user wants to see the video, the client establishes a TCP connection with the server and issues an HTTP GET request for that URL. The server then sends the video file, within an HTTP response message, as quickly as possible, that is, as quickly as TCP congestion control and flow control will allow. On the client side, the bytes are collected in a client application buffer. Once the number of bytes in this buffer exceeds a predetermined threshold, the client application begins playback—specifically, it periodically grabs video frames from the client application buffer, decompresses the frames, and displays them on the user’s screen.</p>
<p>We learned in <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a> that when transferring a file over TCP, the server-to-client transmission rate can vary significantly due to TCP’s congestion control mechanism. In particular, it is not uncommon for the transmission rate to vary in a “saw-tooth” manner associated with TCP congestion control. Furthermore, packets can also be significantly delayed due to TCP’s retransmission mechanism. Because of these characteristics of TCP, the conventional wisdom in the 1990s was that video streaming would never work well over TCP. Over time, however, designers of streaming video systems learned that TCP’s congestion control and reliable-data transfer mechanisms do not necessarily preclude continuous playout when client buffering and prefetching (discussed in the next section) are used.</p>
<p>The use of HTTP over TCP also allows the video to traverse firewalls and NATs more easily (which are often configured to block most UDP traffic but to allow most HTTP traffic). Streaming over HTTP also obviates the need for a media control server, such as an RTSP server, reducing the cost of a large- scale deployment over the Internet. Due to all of these advantages, most video streaming applications today—including YouTube and Netflix—use HTTP streaming (over TCP) as its underlying streaming protocol.</p>
</div>
<section id="id2">
<h3>预取视频<a class="headerlink" href="#id2" title="此标题的永久链接">#</a></h3>
<p>Prefetching Video</p>
<p>正如我们刚刚了解的，客户端缓冲可用于缓解端到端延迟和可用带宽变化的影响。在 <a class="reference internal" href="s1.html#c9-1"><span class="std std-ref">Figure 9.1</span></a> 的示例中，服务器以与视频播放速率相同的速率传输视频。然而，对于存储视频流媒体，客户端可以尝试以高于消费速率的速率下载视频，从而 <strong>预取</strong> 未来将被消费的视频帧。预取的视频自然会存储在客户端应用程序缓冲区中。</p>
<p>在 TCP 流媒体中，预取行为会自然发生，因为 TCP 的拥塞避免机制会尝试使用服务器与客户端之间的全部可用带宽。为了更直观地理解预取，让我们来看一个简单的例子。假设视频消费速率为 1 Mbps，而网络能以恒定速率 1.5 Mbps 从服务器传送数据给客户端。那么客户端不仅可以在极小的播放延迟下播放视频，还可以每秒增加 500 Kbit 的缓冲数据。通过这种方式，如果将来客户端在某一段时间内接收速率降至低于 1 Mbps，它仍能因缓冲储备而实现连续播放。<a class="reference internal" href="../references.html#wang-2008"><span class="std std-ref">[Wang 2008]</span></a> 研究表明，当平均 TCP 吞吐量约为媒体比特率的两倍时，通过 TCP 进行流媒体传输可实现最小的播放中断和极低的缓冲延迟。</p>
<div class="toggle docutils container">
<p>As we just learned, client-side buffering can be used to mitigate the effects of varying end-to-end delays and varying available bandwidth. In our earlier example in <a class="reference internal" href="s1.html#c9-1"><span class="std std-ref">Figure 9.1</span></a>, the server transmits video at the rate at which the video is to be played out. However, for streaming stored video, the client can attempt to download the video at a rate higher than the consumption rate, thereby <strong>prefetching</strong> video frames that are to be consumed in the future. This prefetched video is naturally stored in the client application buffer.</p>
<p>Such prefetching occurs naturally with TCP streaming, since TCP’s congestion avoidance mechanism will attempt to use all of the available bandwidth between server and client. To gain some insight into prefetching, let’s take a look at a simple example. Suppose the video consumption rate is 1 Mbps but the network is capable of delivering the video from server to client at a constant rate of 1.5 Mbps. Then the client will not only be able to play out the video with a very small playout delay, but will also be able to increase the amount of buffered video data by 500 Kbits every second. In this manner, if in the future the client receives data at a rate of less than 1 Mbps for a brief period of time, the client will be able to continue to provide continuous playback due to the reserve in its buffer. <a class="reference internal" href="../references.html#wang-2008"><span class="std std-ref">[Wang 2008]</span></a> shows that when the average TCP throughput is roughly twice the media bit rate, streaming over TCP results in minimal starvation and low buffering delays.</p>
</div>
</section>
<section id="tcp">
<h3>客户端应用程序缓冲与 TCP 缓冲<a class="headerlink" href="#tcp" title="此标题的永久链接">#</a></h3>
<p>Client Application Buffer and TCP Buffers</p>
<p><a class="reference internal" href="#c9-2"><span class="std std-ref">Figure 9.2</span></a> 展示了 HTTP 流媒体中客户端与服务器的交互。在服务器端，图中白色部分代表已经发送到服务器套接字中的视频文件内容，深色部分代表尚未发送的部分。通过“套接字门”后，字节将被放入 TCP 发送缓冲区，然后传输至互联网，如 <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a> 中所述。在 <a class="reference internal" href="#figure-9-2"><span class="std std-ref">Figure 9.2</span></a> 中，由于服务器端 TCP 发送缓冲区已满，服务器暂时无法将更多视频字节写入套接字。在客户端，客户端应用程序（媒体播放器）从 TCP 接收缓冲区中读取字节（通过其客户端套接字）并放入客户端应用程序缓冲区。同时，客户端应用程序定期从应用程序缓冲区中提取视频帧、解压并在用户屏幕上显示。请注意，如果客户端应用程序缓冲区大于视频文件，则整个从服务器存储传输到客户端应用程序缓冲区的过程就等同于一个普通的 HTTP 文件下载——客户端只需以 TCP 所允许的最大速率从服务器拉取视频！</p>
<figure class="align-center" id="figure-9-2">
<img alt="../_images/758-0.png" src="../_images/758-0.png" />
</figure>
<p><strong>Figure 9.2 通过 HTTP/TCP 传输的存储视频流</strong></p>
<p>接下来考虑用户在流媒体播放过程中暂停视频时会发生什么。在暂停期间，客户端应用程序缓冲区中的位不会被消耗，即使服务器仍在继续传输数据。如果客户端应用程序缓冲区是有限的，它最终可能会被填满，这将导致“反向压力”一直传递回服务器。具体来说，一旦客户端应用程序缓冲区填满，TCP 接收缓冲区中的字节将无法被移除，也就会被填满。此后，服务器端的 TCP 发送缓冲区也将无法移除字节，因此也会填满。一旦 TCP 填满，服务器就无法再向套接字发送任何字节。因此，当用户暂停视频时，服务器可能被迫停止传输，直到用户恢复播放。</p>
<p>事实上，即使在正常播放过程中（即未暂停时），如果客户端应用程序缓冲区已满，反向压力也会导致 TCP 缓冲区填满，从而迫使服务器降低其发送速率。要确定其结果速率，请注意，当客户端应用程序移除 f 位时，会为 f 位腾出空间，从而允许服务器发送 f 位。因此，当通过 HTTP 进行流媒体传输时，服务器发送速率不能高于客户端的视频消费速率。由此可见，客户端应用程序缓冲区已满间接限制了从服务器到客户端的视频传输速率。</p>
<div class="toggle docutils container">
<p><a class="reference internal" href="#c9-2"><span class="std std-ref">Figure 9.2</span></a> illustrates the interaction between client and server for HTTP streaming. At the server side, the portion of the video file in white has already been sent into the server’s socket, while the darkened portion is what remains to be sent. After “passing through the socket door,” the bytes are placed in the
TCP send buffer before being transmitted into the Internet, as described in <a class="reference internal" href="../c3/index.html#c3"><span class="std std-ref">Chapter 3</span></a>. In <a class="reference internal" href="#figure-9-2"><span class="std std-ref">Figure 9.2</span></a>, because the TCP send buffer at the server side is shown to be full, the server is momentarily prevented from sending more bytes from the video file into the socket. On the client side, the client application (media player) reads bytes from the TCP receive buffer (through its client socket) and places the bytes into the client application buffer. At the same time, the client application periodically grabs video frames from the client application buffer, decompresses the frames, and displays them on the user’s screen. Note that if the client application buffer is larger than the video file, then the whole process of moving bytes from the server’s storage to the client’s application buffer is equivalent to an ordinary file download over HTTP—the client simply pulls the video off the server as fast as TCP will allow!</p>
<figure class="align-center">
<img alt="../_images/758-0.png" src="../_images/758-0.png" />
</figure>
<p><strong>Figure 9.2 Streaming stored video over HTTP/TCP</strong></p>
<p>Consider now what happens when the user pauses the video during the streaming process. During the pause period, bits are not removed from the client application buffer, even though bits continue to enter the buffer from the server. If the client application buffer is finite, it may eventually become full, which will cause “back pressure” all the way back to the server. Specifically, once the client application buffer becomes full, bytes can no longer be removed from the client TCP receive buffer, so it too becomes full. Once the client receive TCP buffer becomes full, bytes can no longer be removed from the server TCP send buffer, so it also becomes full. Once the TCP becomes full, the server cannot send any more bytes into the socket. Thus, if the user pauses the video, the server may be forced to stop transmitting, in which case the server will be blocked until the user resumes the video.</p>
<p>In fact, even during regular playback (that is, without pausing), if the client application buffer becomes full, back pressure will cause the TCP buffers to become full, which will force the server to reduce its rate. To determine the resulting rate, note that when the client application removes f bits, it creates room for f bits in the client application buffer, which in turn allows the server to send f additional bits. Thus, the server send rate can be no higher than the video consumption rate at the client. Therefore, a full client application buffer indirectly imposes a limit on the rate that video can be sent from server to client when streaming over HTTP.</p>
</div>
</section>
<section id="id3">
<h3>视频流分析<a class="headerlink" href="#id3" title="此标题的永久链接">#</a></h3>
<p>Analysis of Video Streaming</p>
<p>一些简单的建模可以帮助我们更深入理解初始播放延迟和因应用程序缓冲区耗尽而导致的播放冻结。如 <a class="reference internal" href="#figure-9-3"><span class="std std-ref">Figure 9.3</span></a> 所示，令 B 表示客户端应用程序缓冲区的大小（以比特为单位），Q 表示在客户端应用程序开始播放前需要缓冲的比特数（显然，Q&lt;B）。令 r 表示视频消费速率——即客户端在播放过程中从缓冲区中提取比特的速率。例如，如果视频帧率为 30 帧/秒，每帧（压缩后）为 100,000 比特，则 r=3 Mbps。为了简化分析，我们暂不考虑 TCP 的发送和接收缓冲区。</p>
<figure class="align-center" id="figure-9-3">
<img alt="../_images/759-0.png" src="../_images/759-0.png" />
</figure>
<p><strong>Figure 9.3 通过 HTTP/TCP 传输的存储视频流</strong></p>
<p>假设只要客户端缓冲区未满，服务器就以恒定速率 x 发送比特。（这显然是简化处理，因为 TCP 发送速率会随拥塞控制变化；我们将在本章末的习题中研究时间相关的速率 x(t)。）假设在 t=0 时应用程序缓冲区为空，视频开始向客户端缓冲区到达。我们现在要问的是播放将在什么时间 t=tp 开始？客户端缓冲区在什么时候 t=tf 被填满？</p>
<p>首先确定 tp，即 Q 比特进入缓冲区、播放开始的时间。由于在播放开始前比特是以速率 x 进入客户端缓冲区，且未被移除，因此积累 Q 比特所需时间为 tp=Q/x。</p>
<p>现在确定 tf，即客户端缓冲区填满的时间。如果 x&lt;r（即服务器发送速率小于消费速率），则客户端缓冲区永远不会被填满！确实，从时间 tp 起，缓冲区以速率 r 被耗尽，但仅以 x&lt;r 的速率补充。最终，客户端缓冲区将完全清空，视频将在屏幕上冻结，客户端缓冲区又需等待 tp 秒才能重新积累 Q 比特视频。也就是说，当网络可用速率低于视频速率时，播放将在连续播放与冻结之间交替。在作业中，你将被要求根据 Q、r 和 x 求出每段连续播放和冻结期的长度。现在我们来求当 x&gt;r 时的 tf。在这种情况下，从时间 tp 起，缓冲区将以 x−r 的速率从 Q 增加至 B，因为比特以 x 的速率到达，以 r 的速率被消耗，如 <a class="reference internal" href="#figure-9-3"><span class="std std-ref">Figure 9.3</span></a> 所示。根据这些提示，你将在作业中被要求求出 tf，即客户端缓冲区填满的时间。注意，在网络可用速率高于视频速率的情况下，经过初始缓冲延迟后，用户将享受持续的播放直到视频结束。</p>
<div class="toggle docutils container">
<p>Some simple modeling will provide more insight into initial playout delay and freezing due to application buffer depletion. As shown in <a class="reference internal" href="#figure-9-3"><span class="std std-ref">Figure 9.3</span></a>, let B denote the size (in bits) of the client’s application buffer, and let Q denote the number of bits that must be buffered before the client application begins playout. (Of course, Q&lt;B.) Let r denote the video consumption rate—the rate at which the client draws bits out of the client application buffer during playback. So, for example, if the video’s frame rate is 30 frames/sec, and each (compressed) frame is 100,000 bits, then r=3 Mbps. To see the forest through the trees, we’ll ignore TCP’s send and receive buffers.</p>
<figure class="align-center">
<img alt="../_images/759-0.png" src="../_images/759-0.png" />
</figure>
<p><strong>Figure 9.3 Streaming stored video over HTTP/TCP</strong></p>
<p>Let’s assume that the server sends bits at a constant rate x whenever the client buffer is not full. (This is a gross simplification, since TCP’s send rate varies due to congestion control; we’ll examine more realistic time-dependent rates x(t) in the problems at the end of this chapter.) Suppose at time t=0, the application buffer is empty and video begins arriving to the client application buffer. We now ask at what time t=tp does playout begin? And while we are at it, at what time t=tf does the client application buffer become full?</p>
<p>First, let’s determine tp, the time when Q bits have entered the application buffer and playout begins. Recall that bits arrive to the client application buffer at rate x and no bits are removed from this buffer before playout begins. Thus, the amount of time required to build up Q bits (the initial buffering delay) is tp=Q/x.</p>
<p>Now let’s determine tf, the point in time when the client application buffer becomes full. We first observe that if x&lt;r (that is, if the server send rate is less than the video consumption rate), then the client buffer will never become full! Indeed, starting at time tp, the buffer will be depleted at rate r and will only be filled at rate x&lt;r. Eventually the client buffer will empty out entirely, at which time the video will freeze on the screen while the client buffer waits another tp seconds to build up Q bits of video. Thus, when the available rate in the network is less than the video rate, playout will alternate between periods of continuous playout and periods of freezing. In a homework problem, you will be asked to determine the length of each continuous playout and freezing period as a function of Q, r, and x. Now let’s determine tf for when x&gt;r. In this case, starting at time tp, the buffer increases from Q to B at rate x−r since bits are being depleted at rate r but are arriving at rate x, as shown in <a class="reference internal" href="#figure-9-3"><span class="std std-ref">Figure 9.3</span></a>. Given these hints, you will be asked in a homework problem to determine tf, the time the client buffer becomes full. Note that when the available rate in the network is more than the video rate, after the initial buffering delay, the user will enjoy continuous playout until the video ends.</p>
</div>
</section>
<section id="id4">
<h3>提前终止与视频重定位<a class="headerlink" href="#id4" title="此标题的永久链接">#</a></h3>
<p>Early Termination and Repositioning the Video</p>
<p>HTTP 流媒体系统通常在 HTTP GET 请求消息中使用 <a href="#id5"><span class="problematic" id="id6">**</span></a>HTTP 字节范围头部**（HTTP byte-range header），该头部指定客户端当前希望从所请求视频中获取的字节范围。当用户想跳转到视频中某一未来时刻时，这项功能尤为重要。当用户跳转至新位置时，客户端会发送一个新的 HTTP 请求，并通过字节范围头部指明服务器应从文件中的哪个字节开始发送数据。当服务器收到这个新的 HTTP 请求时，可以忽略之前的请求，改为从该字节位置开始发送数据。</p>
<p>在讨论重定位时，我们还顺便提到，当用户跳转至视频中某个未来位置或提早结束观看时，服务器发送的某些已预取但尚未观看的数据将被浪费掉，这就造成了网络带宽和服务器资源的浪费。例如，假设在某个时间点 t₀，客户端缓冲区中已满（即包含 B 比特的数据），而此时用户跳转至视频中的某个时间点 t&gt;t₀+B/r，并从该点开始观看直至结束。在这种情况下，缓冲区中的全部 B 比特数据将不被观看，而这些数据所占用的带宽和服务器资源也就完全被浪费了。由于提前终止而造成的网络带宽浪费在互联网中非常普遍，尤其在无线链路中代价尤为高昂 <a class="reference internal" href="../references.html#ihm-2011"><span class="std std-ref">[Ihm 2011]</span></a>。因此，许多流媒体系统仅使用中等大小的客户端应用程序缓冲区，或通过在 HTTP 请求中使用字节范围头部限制预取视频的量 <a class="reference internal" href="../references.html#rao-2011"><span class="std std-ref">[Rao 2011]</span></a>。</p>
<p>视频重定位和提前终止就像是做了一顿大餐，却只吃了一部分，其余的都倒掉了，因而造成食物浪费。因此，下次当你的父母批评你没有吃完晚饭浪费食物时，你可以迅速反驳说他们在上网看电影时跳转画面也在浪费带宽和服务器资源！不过当然了，两件错事并不能相互抵消——无论是食物还是带宽，都不应被浪费！</p>
<p>在 <a class="reference internal" href="#c9-2-1"><span class="std std-ref">Sections 9.2.1</span></a> 和 <a class="reference internal" href="#c9-2-2"><span class="std std-ref">9.2.2</span></a> 中，我们分别介绍了 UDP 流媒体和 HTTP 流媒体。第三种流媒体类型是基于 HTTP 的动态自适应流媒体（Dynamic Adaptive Streaming over HTTP，DASH），它使用多个不同压缩率的视频版本。DASH 的详细内容在 <a class="reference internal" href="../c2/s6.html#c2-6-2"><span class="std std-ref">Section 2.6.2</span></a> 中介绍。CDN（内容分发网络）常用于分发存储视频和实时视频，相关内容将在 <a class="reference internal" href="../c2/s6.html#c2-6-3"><span class="std std-ref">Section 2.6.3</span></a> 中详细介绍。</p>
<div class="toggle docutils container">
<p>HTTP streaming systems often make use of the <strong>HTTP byte-range header</strong> in the HTTP GET request message, which specifies the specific range of bytes the client currently wants to retrieve from the desired video. This is particularly useful when the user wants to reposition (that is, jump) to a future point in time in the video. When the user repositions to a new position, the client sends a new HTTP request, indicating with the byte-range header from which byte in the file should the server send data. When the server receives the new HTTP request, it can forget about any earlier request and instead send bytes beginning with the byte indicated in the byte-range request.</p>
<p>While we are on the subject of repositioning, we briefly mention that when a user repositions to a future point in the video or terminates the video early, some prefetched-but-not-yet-viewed data transmitted by the server will go unwatched—a waste of network bandwidth and server resources. For example, suppose that the client buffer is full with B bits at some time t0 into the video, and at this time the user repositions to some instant t&gt;t0+B/r into the video, and then watches the video to completion from that point on. In this case, all B bits in the buffer will be unwatched and the bandwidth and server resources that were used to transmit those B bits have been completely wasted. There is significant wasted bandwidth in the Internet due to early termination, which can be quite costly, particularly for wireless links <a class="reference internal" href="../references.html#ihm-2011"><span class="std std-ref">[Ihm 2011]</span></a>. For this reason, many streaming systems use only a moderate-size client application buffer, or will limit the amount of prefetched video using the byte-range header in HTTP requests <a class="reference internal" href="../references.html#rao-2011"><span class="std std-ref">[Rao 2011]</span></a>.</p>
<p>Repositioning and early termination are analogous to cooking a large meal, eating only a portion of it, and throwing the rest away, thereby wasting food. So the next time your parents criticize you for wasting food by not eating all your dinner, you can quickly retort by saying they are wasting bandwidth and server resources when they reposition while watching movies over the Internet! But, of course, two wrongs do not make a right—both food and bandwidth are not to be wasted!</p>
<p>In <a class="reference internal" href="#c9-2-1"><span class="std std-ref">Sections 9.2.1</span></a> and <a class="reference internal" href="#c9-2-2"><span class="std std-ref">9.2.2</span></a>, we covered UDP streaming and HTTP streaming, respectively. A third type of streaming is Dynamic Adaptive Streaming over HTTP (DASH), which uses multiple versions of the video, each compressed at a different rate. DASH is discussed in detail in <a class="reference internal" href="../c2/s6.html#c2-6-2"><span class="std std-ref">Section 2.6.2</span></a>. CDNs are often used to distribute stored and live video. CDNs are discussed in detail in <a class="reference internal" href="../c2/s6.html#c2-6-3"><span class="std std-ref">Section 2.6.3</span></a>.</p>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="s1.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">9.1 多媒体网络应用</p>
      </div>
    </a>
    <a class="right-next"
       href="s3.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">9.3 基于 IP 的语音通信</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#udp">9.2.1 UDP 流媒体</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#http">9.2.2 HTTP 流媒体</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">预取视频</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tcp">客户端应用程序缓冲与 TCP 缓冲</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">视频流分析</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">提前终止与视频重定位</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： Jim Kurose/Keith Ross
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Jim Kurose/Keith Ross.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>